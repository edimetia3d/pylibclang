
// GENERATED AT 10/28/2023, 17:41:11

#include "clang-c/BuildSystem.h"
#include "clang-c/CXCompilationDatabase.h"
#include "clang-c/CXDiagnostic.h"
#include "clang-c/CXErrorCode.h"
#include "clang-c/CXFile.h"
#include "clang-c/CXSourceLocation.h"
#include "clang-c/CXString.h"
#include "clang-c/Documentation.h"
#include "clang-c/ExternC.h"
#include "clang-c/FatalErrorHandler.h"
#include "clang-c/Index.h"
#include "clang-c/Platform.h"
#include "clang-c/Rewrite.h"

#ifndef GITHUB_COM_PYBIND11_WEAVER
#define GITHUB_COM_PYBIND11_WEAVER
#include <atomic>
#include <functional>
#include <map>
#include <mutex>
#include <thread>
#include <utility>

#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

namespace pybind11_weaver {

template <class BindT, class PB11T> void TryAddDefaultCtor(PB11T &handle) {
  if constexpr (std::is_default_constructible<BindT>::value) {
    handle.def(pybind11::init<>());
  }
}

template <class ClassT, class MethodRetT, class... MethodArgs> struct FnPtrT {
  using type = MethodRetT (ClassT::*)(MethodArgs...);
  using const_type = MethodRetT (ClassT::*)(MethodArgs...) const;
  using const_rref_type = MethodRetT (ClassT::*)(MethodArgs...) const &&;
  using const_lref_type = MethodRetT (ClassT::*)(MethodArgs...) const &;
  using rref_type = MethodRetT (ClassT::*)(MethodArgs...) &&;
  using lref_type = MethodRetT (ClassT::*)(MethodArgs...) &;
};
template <class FnTtype> struct FnPtrT<void, FnTtype> {
  using type = FnTtype *;
};

struct _PointerWrapperBase {
  _PointerWrapperBase(void *ptr_) : ptr(ptr_) {}
  _PointerWrapperBase(intptr_t ptr_v) : ptr(reinterpret_cast<void *>(ptr_v)) {}
  intptr_t get_ptr() { return reinterpret_cast<intptr_t>(ptr); }
  void set_ptr(intptr_t ptr_v) { ptr = reinterpret_cast<void *>(ptr_v); }
  static void FastBind(pybind11::module &m) {
    pybind11::class_<_PointerWrapperBase, std::shared_ptr<_PointerWrapperBase>>(
        m, "_PointerWrapperBase", pybind11::dynamic_attr())
        .def(pybind11::init<void *>())
        .def(pybind11::init<intptr_t>())
        .def("get_ptr", &_PointerWrapperBase::get_ptr)
        .def("set_ptr", &_PointerWrapperBase::set_ptr);
  }
  void *ptr;
};

template <class T> struct PointerWrapper : public _PointerWrapperBase {
  static_assert(std::is_pointer<T>::value, "T must be a pointer type");
  using _PointerWrapperBase::_PointerWrapperBase;

  static void FastBind(pybind11::module &m, const std::string &name) {
    pybind11::class_<PointerWrapper, std::shared_ptr<PointerWrapper>,
                     _PointerWrapperBase>(m, name.c_str(),
                                          pybind11::dynamic_attr())
        .def(pybind11::init<intptr_t>())
        .def_static("from_capsule", [](pybind11::capsule o) {
          return std::make_shared<PointerWrapper<T>>(
              reinterpret_cast<void *>(o.get_pointer()));
        });
  }
  T Cptr() { return reinterpret_cast<T>(ptr); }
};
template <class T> using WrappedPtrT = std::shared_ptr<PointerWrapper<T>>;

template <class T> WrappedPtrT<T> WrapP(T ptr) {
  if (!ptr) {
    return nullptr;
  }
  return WrappedPtrT<T>{new PointerWrapper<T>((void *)ptr)};
}

struct Guardian {
  std::vector<std::function<void()>> dtor_callbacks;
  ~Guardian() {
    for (auto &fn : dtor_callbacks) {
      fn();
    }
  }
};

template <typename R, typename... Args> struct FnPointerWrapper {
  using CppFnT = R(Args...);

  template <class CR, typename... CArgs> struct GetCptr {
    using CFnPtrT = CR (*)(CArgs...);
    static CFnPtrT Run(std::function<CppFnT> to_call, Guardian &&guard,
                       CFnPtrT c_wrapper, const char *uuid0, int64_t uuid1) {
      // lock
      guard.dtor_callbacks.push_back(
          [uuid0, uuid1]() { ReleaseFnProxy(uuid0, uuid1); });
      SetFnProxy(uuid0, uuid1, to_call);
      return c_wrapper;
    }
  };

  using FnMapT =
      std::map<const char *, std::map<int64_t, std::function<CppFnT>>>;
  static void SetFnProxy(const char *uuid0, int64_t uuid1,
                         std::function<CppFnT> &fn) {
    FnMapMutex().lock();
    while (FnMap()[uuid0].count(uuid1) != 0) {
      // The chance is so low, spin lock should be fine
      FnMapMutex().unlock();
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
      FnMapMutex().lock();
    }
    FnMap()[uuid0][uuid1] = fn;
    FnMapMutex().unlock();
  }

  static std::function<CppFnT> GetFnProxy(const char *uuid0, int64_t uuid1) {
    std::lock_guard<std::mutex> _(FnMapMutex());
    auto ret = FnMap()[uuid0][uuid1];
    return ret;
  }

  static void ReleaseFnProxy(const char *uuid0, int64_t uuid1) {
    std::lock_guard<std::mutex> _(FnMapMutex());
    FnMap()[uuid0].erase(uuid1);
  }
  static FnMapT &FnMap() {
    static FnMapT fns;
    return fns;
  }

  static std::mutex &FnMapMutex() {
    static std::mutex m;
    return m;
  }
};

class CallUpdateGuard {
public:
  using Fn = std::function<void(void)>;
  CallUpdateGuard(Fn fn) : fn_(fn) {}

  CallUpdateGuard(CallUpdateGuard &&rhs) {
    this->fn_ = rhs.fn_;
    rhs.fn_ = nullptr;
  }

  void operator()() {
    if (fn_) {
      fn_();
      fn_ = nullptr;
    }
  }

  ~CallUpdateGuard() { this->operator()(); }

private:
  Fn fn_;
};

struct EntityScope {
  explicit EntityScope(int64_t, int64_t) {} // a tag for disabled scope
  explicit EntityScope(pybind11::module_ &parent_h) : module_{&parent_h} {}
  explicit EntityScope(pybind11::detail::generic_type &parent_h)
      : type_{&parent_h} {}
  explicit operator pybind11::module_ &() { return *module_; }
  explicit operator pybind11::detail::generic_type &() { return *type_; }
  operator pybind11::handle &() {
    if (module_) {
      return *module_;
    } else {
      return *type_;
    }
  }
  bool IsDisabled() const { return module_ == nullptr && type_ == nullptr; }

private:
  pybind11::detail::generic_type *type_ = nullptr;
  pybind11::module_ *module_ = nullptr;
};

struct EntityBase {
  virtual ~EntityBase() = default;

  virtual void Update() = 0;

  virtual EntityScope AsScope() = 0;
};

struct DisabledEntity : public EntityBase {
  void Update() override {}
  EntityScope AsScope() override { return EntityScope{0, 0}; }
};

struct CustomBindingRegistry {
  using CTorT = std::function<std::shared_ptr<EntityBase>(EntityScope &&)>;
  using RegistryT = std::map<std::string, CTorT>;

  bool contains(const std::string &key) const {
    return registry_.count(key) > 0;
  }
  CTorT at(const std::string &key) const { return registry_.at(key); }

  template <class BindingT> void DisableBinding() {
    auto key = std::string(BindingT::Key());
    registry_.emplace(
        key, [](EntityScope &&) { return std::make_shared<DisabledEntity>(); });
  }

  void RegCustomBinding(const std::string &key, CTorT &&ctor) {
    registry_.emplace(key, std::move(ctor));
  }

  template <class BindingT> void SetCustomBinding() {
    auto key = std::string(BindingT::Key());
    registry_.emplace(key, [](EntityScope &&parent_h) {
      return std::make_shared<BindingT>(std::move(parent_h));
    });
  }

private:
  RegistryT registry_;
};

template <class EntityT>
std::shared_ptr<EntityBase>
CreateEntity(EntityScope &&parent_h, const CustomBindingRegistry &registry) {
  if (parent_h.IsDisabled()) {
    return std::make_shared<DisabledEntity>();
  }
  auto key = std::string(EntityT::Key());
  if (!registry.contains(key)) {
    return std::make_shared<EntityT>(std::move(parent_h));
  } else {
    auto fn = registry.at(key);
    return fn(std::move(parent_h));
  }
}

} // namespace pybind11_weaver
#endif // GITHUB_COM_PYBIND11_WEAVER

namespace {

using pybind11_weaver::EntityBase;
using pybind11_weaver::EntityScope;

template <class Pybind11T = pybind11::enum_<CXAvailabilityKind>>
struct Bind_CXAvailabilityKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXAvailabilityKind(EntityScope parent_h)
      : handle{parent_h, "CXAvailabilityKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the availability of a particular entity, which indicates
 * whether the use of this entity will result in a warning or error due to
 * it being deprecated or unavailable.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXAvailabilityKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXAvailability_Available",
                 CXAvailabilityKind::CXAvailability_Available,
                 R"_pb11_weaver(/**
   * The entity is available.
   */)_pb11_weaver");
    handle.value("CXAvailability_Deprecated",
                 CXAvailabilityKind::CXAvailability_Deprecated,
                 R"_pb11_weaver(/**
   * The entity is available, but has been deprecated (and its use is
   * not recommended).
   */)_pb11_weaver");
    handle.value("CXAvailability_NotAvailable",
                 CXAvailabilityKind::CXAvailability_NotAvailable,
                 R"_pb11_weaver(/**
   * The entity is not available; any use of it will be an error.
   */)_pb11_weaver");
    handle.value("CXAvailability_NotAccessible",
                 CXAvailabilityKind::CXAvailability_NotAccessible,
                 R"_pb11_weaver(/**
   * The entity is available, but not accessible; any use of it will be
   * an error.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXAvailabilityKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXAvailabilityKind

using Entity_CXAvailabilityKind = Bind_CXAvailabilityKind<>;

#else

struct Entity_CXAvailabilityKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXAvailabilityKind(EntityScope parent_h) {}
  static const char *Key() { return "CXAvailabilityKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXAvailabilityKind

template <class Pybind11T = pybind11::enum_<CXCallingConv>>
struct Bind_CXCallingConv : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCallingConv(EntityScope parent_h)
      : handle{parent_h, "CXCallingConv", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the calling convention of a function type
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCallingConv(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCallingConv_Default", CXCallingConv::CXCallingConv_Default);
    handle.value("CXCallingConv_C", CXCallingConv::CXCallingConv_C);
    handle.value("CXCallingConv_X86StdCall",
                 CXCallingConv::CXCallingConv_X86StdCall);
    handle.value("CXCallingConv_X86FastCall",
                 CXCallingConv::CXCallingConv_X86FastCall);
    handle.value("CXCallingConv_X86ThisCall",
                 CXCallingConv::CXCallingConv_X86ThisCall);
    handle.value("CXCallingConv_X86Pascal",
                 CXCallingConv::CXCallingConv_X86Pascal);
    handle.value("CXCallingConv_AAPCS", CXCallingConv::CXCallingConv_AAPCS);
    handle.value("CXCallingConv_AAPCS_VFP",
                 CXCallingConv::CXCallingConv_AAPCS_VFP);
    handle.value("CXCallingConv_X86RegCall",
                 CXCallingConv::CXCallingConv_X86RegCall);
    handle.value("CXCallingConv_IntelOclBicc",
                 CXCallingConv::CXCallingConv_IntelOclBicc);
    handle.value("CXCallingConv_Win64", CXCallingConv::CXCallingConv_Win64);
    handle.value(
        "CXCallingConv_X86_64Win64", CXCallingConv::CXCallingConv_X86_64Win64,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_X86_64SysV", CXCallingConv::CXCallingConv_X86_64SysV,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_X86VectorCall",
        CXCallingConv::CXCallingConv_X86VectorCall,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_Swift", CXCallingConv::CXCallingConv_Swift,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_PreserveMost", CXCallingConv::CXCallingConv_PreserveMost,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_PreserveAll", CXCallingConv::CXCallingConv_PreserveAll,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_AArch64VectorCall",
        CXCallingConv::CXCallingConv_AArch64VectorCall,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_SwiftAsync", CXCallingConv::CXCallingConv_SwiftAsync,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_AArch64SVEPCS",
        CXCallingConv::CXCallingConv_AArch64SVEPCS,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_Invalid", CXCallingConv::CXCallingConv_Invalid,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
    handle.value(
        "CXCallingConv_Unexposed", CXCallingConv::CXCallingConv_Unexposed,
        R"_pb11_weaver(/* Alias for compatibility with older versions of API. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCallingConv"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCallingConv

using Entity_CXCallingConv = Bind_CXCallingConv<>;

#else

struct Entity_CXCallingConv : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCallingConv(EntityScope parent_h) {}
  static const char *Key() { return "CXCallingConv"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCallingConv

template <class Pybind11T = pybind11::enum_<CXChildVisitResult>>
struct Bind_CXChildVisitResult : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXChildVisitResult(EntityScope parent_h)
      : handle{parent_h, "CXChildVisitResult", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes how the traversal of the children of a particular
 * cursor should proceed after visiting a particular child cursor.
 *
 * A value of this enumeration type should be returned by each
 * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXChildVisitResult(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXChildVisit_Break", CXChildVisitResult::CXChildVisit_Break,
                 R"_pb11_weaver(/**
   * Terminates the cursor traversal.
   */)_pb11_weaver");
    handle.value("CXChildVisit_Continue",
                 CXChildVisitResult::CXChildVisit_Continue, R"_pb11_weaver(/**
   * Continues the cursor traversal with the next sibling of
   * the cursor just visited, without visiting its children.
   */)_pb11_weaver");
    handle.value("CXChildVisit_Recurse",
                 CXChildVisitResult::CXChildVisit_Recurse, R"_pb11_weaver(/**
   * Recursively traverse the children of this cursor, using
   * the same visitor and client data.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXChildVisitResult"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXChildVisitResult

using Entity_CXChildVisitResult = Bind_CXChildVisitResult<>;

#else

struct Entity_CXChildVisitResult : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXChildVisitResult(EntityScope parent_h) {}
  static const char *Key() { return "CXChildVisitResult"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXChildVisitResult

template <class Pybind11T = pybind11::class_<CXCodeCompleteResults>>
struct Bind_CXCodeCompleteResults : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCodeCompleteResults(EntityScope parent_h)
      : handle{parent_h, "CXCodeCompleteResults", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Contains the results of code-completion.
 *
 * This data structure contains the results of code completion, as
 * produced by \c clang_codeCompleteAt(). Its contents must be freed by
 * \c clang_disposeCodeCompleteResults.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCodeCompleteResults(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXCodeCompleteResults>(handle);
    handle.def_readwrite("NumResults", &CXCodeCompleteResults::NumResults,
                         R"_pb11_weaver(/**
   * The number of code-completion results stored in the
   * \c Results array.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCodeCompleteResults"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCodeCompleteResults

using Entity_CXCodeCompleteResults = Bind_CXCodeCompleteResults<>;

#else

struct Entity_CXCodeCompleteResults : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCodeCompleteResults(EntityScope parent_h) {}
  static const char *Key() { return "CXCodeCompleteResults"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCodeCompleteResults

template <class Pybind11T = pybind11::enum_<CXCodeComplete_Flags>>
struct Bind_CXCodeComplete_Flags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCodeComplete_Flags(EntityScope parent_h)
      : handle{parent_h, "CXCodeComplete_Flags", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Flags that can be passed to \c clang_codeCompleteAt() to
 * modify its behavior.
 *
 * The enumerators in this enumeration can be bitwise-OR'd together to
 * provide multiple options to \c clang_codeCompleteAt().
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCodeComplete_Flags(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCodeComplete_IncludeMacros",
                 CXCodeComplete_Flags::CXCodeComplete_IncludeMacros,
                 R"_pb11_weaver(/**
   * Whether to include macros within the set of code
   * completions returned.
   */)_pb11_weaver");
    handle.value("CXCodeComplete_IncludeCodePatterns",
                 CXCodeComplete_Flags::CXCodeComplete_IncludeCodePatterns,
                 R"_pb11_weaver(/**
   * Whether to include code patterns for language constructs
   * within the set of code completions, e.g., for loops.
   */)_pb11_weaver");
    handle.value("CXCodeComplete_IncludeBriefComments",
                 CXCodeComplete_Flags::CXCodeComplete_IncludeBriefComments,
                 R"_pb11_weaver(/**
   * Whether to include brief documentation within the set of code
   * completions returned.
   */)_pb11_weaver");
    handle.value("CXCodeComplete_SkipPreamble",
                 CXCodeComplete_Flags::CXCodeComplete_SkipPreamble,
                 R"_pb11_weaver(/**
   * Whether to speed up completion by omitting top- or namespace-level entities
   * defined in the preamble. There's no guarantee any particular entity is
   * omitted. This may be useful if the headers are indexed externally.
   */)_pb11_weaver");
    handle.value(
        "CXCodeComplete_IncludeCompletionsWithFixIts",
        CXCodeComplete_Flags::CXCodeComplete_IncludeCompletionsWithFixIts,
        R"_pb11_weaver(/**
   * Whether to include completions with small
   * fix-its, e.g. change '.' to '->' on member access, etc.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCodeComplete_Flags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCodeComplete_Flags

using Entity_CXCodeComplete_Flags = Bind_CXCodeComplete_Flags<>;

#else

struct Entity_CXCodeComplete_Flags : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCodeComplete_Flags(EntityScope parent_h) {}
  static const char *Key() { return "CXCodeComplete_Flags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCodeComplete_Flags

template <class Pybind11T = pybind11::class_<CXComment>>
struct Bind_CXComment : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXComment(EntityScope parent_h)
      : handle{parent_h, "CXComment", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * A parsed comment.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXComment(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXComment>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXComment"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXComment

using Entity_CXComment = Bind_CXComment<>;

#else

struct Entity_CXComment : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXComment(EntityScope parent_h) {}
  static const char *Key() { return "CXComment"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXComment

template <class Pybind11T = pybind11::enum_<CXCommentInlineCommandRenderKind>>
struct Bind_CXCommentInlineCommandRenderKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCommentInlineCommandRenderKind(EntityScope parent_h)
      : handle{parent_h, "CXCommentInlineCommandRenderKind",
               pybind11::arithmetic(), R"_pb11_weaver(/**
 * The most appropriate rendering mode for an inline command, chosen on
 * command semantics in Doxygen.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCommentInlineCommandRenderKind(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCommentInlineCommandRenderKind_Normal",
                 CXCommentInlineCommandRenderKind::
                     CXCommentInlineCommandRenderKind_Normal,
                 R"_pb11_weaver(/**
   * Command argument should be rendered in a normal font.
   */)_pb11_weaver");
    handle.value(
        "CXCommentInlineCommandRenderKind_Bold",
        CXCommentInlineCommandRenderKind::CXCommentInlineCommandRenderKind_Bold,
        R"_pb11_weaver(/**
   * Command argument should be rendered in a bold font.
   */)_pb11_weaver");
    handle.value("CXCommentInlineCommandRenderKind_Monospaced",
                 CXCommentInlineCommandRenderKind::
                     CXCommentInlineCommandRenderKind_Monospaced,
                 R"_pb11_weaver(/**
   * Command argument should be rendered in a monospaced font.
   */)_pb11_weaver");
    handle.value("CXCommentInlineCommandRenderKind_Emphasized",
                 CXCommentInlineCommandRenderKind::
                     CXCommentInlineCommandRenderKind_Emphasized,
                 R"_pb11_weaver(/**
   * Command argument should be rendered emphasized (typically italic
   * font).
   */)_pb11_weaver");
    handle.value("CXCommentInlineCommandRenderKind_Anchor",
                 CXCommentInlineCommandRenderKind::
                     CXCommentInlineCommandRenderKind_Anchor,
                 R"_pb11_weaver(/**
   * Command argument should not be rendered (since it only defines an anchor).
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCommentInlineCommandRenderKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCommentInlineCommandRenderKind

using Entity_CXCommentInlineCommandRenderKind =
    Bind_CXCommentInlineCommandRenderKind<>;

#else

struct Entity_CXCommentInlineCommandRenderKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCommentInlineCommandRenderKind(EntityScope parent_h) {}
  static const char *Key() { return "CXCommentInlineCommandRenderKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCommentInlineCommandRenderKind

template <class Pybind11T = pybind11::enum_<CXCommentKind>>
struct Bind_CXCommentKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCommentKind(EntityScope parent_h)
      : handle{parent_h, "CXCommentKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the type of the comment AST node (\c CXComment).  A comment
 * node can be considered block content (e. g., paragraph), inline content
 * (plain text) or neither (the root AST node).
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCommentKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXComment_Null", CXCommentKind::CXComment_Null,
                 R"_pb11_weaver(/**
   * Null comment.  No AST node is constructed at the requested location
   * because there is no text or a syntax error.
   */)_pb11_weaver");
    handle.value("CXComment_Text", CXCommentKind::CXComment_Text,
                 R"_pb11_weaver(/**
   * Plain text.  Inline content.
   */)_pb11_weaver");
    handle.value("CXComment_InlineCommand",
                 CXCommentKind::CXComment_InlineCommand, R"_pb11_weaver(/**
   * A command with word-like arguments that is considered inline content.
   *
   * For example: \\c command.
   */)_pb11_weaver");
    handle.value("CXComment_HTMLStartTag",
                 CXCommentKind::CXComment_HTMLStartTag, R"_pb11_weaver(/**
   * HTML start tag with attributes (name-value pairs).  Considered
   * inline content.
   *
   * For example:
   * \verbatim
   * <br> <br /> <a href="http://example.org/">
   * \endverbatim
   */)_pb11_weaver");
    handle.value("CXComment_HTMLEndTag", CXCommentKind::CXComment_HTMLEndTag,
                 R"_pb11_weaver(/**
   * HTML end tag.  Considered inline content.
   *
   * For example:
   * \verbatim
   * </a>
   * \endverbatim
   */)_pb11_weaver");
    handle.value("CXComment_Paragraph", CXCommentKind::CXComment_Paragraph,
                 R"_pb11_weaver(/**
   * A paragraph, contains inline comment.  The paragraph itself is
   * block content.
   */)_pb11_weaver");
    handle.value("CXComment_BlockCommand",
                 CXCommentKind::CXComment_BlockCommand, R"_pb11_weaver(/**
   * A command that has zero or more word-like arguments (number of
   * word-like arguments depends on command name) and a paragraph as an
   * argument.  Block command is block content.
   *
   * Paragraph argument is also a child of the block command.
   *
   * For example: \has 0 word-like arguments and a paragraph argument.
   *
   * AST nodes of special kinds that parser knows about (e. g., \\param
   * command) have their own node kinds.
   */)_pb11_weaver");
    handle.value("CXComment_ParamCommand",
                 CXCommentKind::CXComment_ParamCommand, R"_pb11_weaver(/**
   * A \\param or \\arg command that describes the function parameter
   * (name, passing direction, description).
   *
   * For example: \\param [in] ParamName description.
   */)_pb11_weaver");
    handle.value("CXComment_TParamCommand",
                 CXCommentKind::CXComment_TParamCommand, R"_pb11_weaver(/**
   * A \\tparam command that describes a template parameter (name and
   * description).
   *
   * For example: \\tparam T description.
   */)_pb11_weaver");
    handle.value("CXComment_VerbatimBlockCommand",
                 CXCommentKind::CXComment_VerbatimBlockCommand,
                 R"_pb11_weaver(/**
   * A verbatim block command (e. g., preformatted code).  Verbatim
   * block has an opening and a closing command and contains multiple lines of
   * text (\c CXComment_VerbatimBlockLine child nodes).
   *
   * For example:
   * \\verbatim
   * aaa
   * \\endverbatim
   */)_pb11_weaver");
    handle.value("CXComment_VerbatimBlockLine",
                 CXCommentKind::CXComment_VerbatimBlockLine, R"_pb11_weaver(/**
   * A line of text that is contained within a
   * CXComment_VerbatimBlockCommand node.
   */)_pb11_weaver");
    handle.value("CXComment_VerbatimLine",
                 CXCommentKind::CXComment_VerbatimLine, R"_pb11_weaver(/**
   * A verbatim line command.  Verbatim line has an opening command,
   * a single line of text (up to the newline after the opening command) and
   * has no closing command.
   */)_pb11_weaver");
    handle.value("CXComment_FullComment", CXCommentKind::CXComment_FullComment,
                 R"_pb11_weaver(/**
   * A full comment attached to a declaration, contains block content.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCommentKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCommentKind

using Entity_CXCommentKind = Bind_CXCommentKind<>;

#else

struct Entity_CXCommentKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCommentKind(EntityScope parent_h) {}
  static const char *Key() { return "CXCommentKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCommentKind

template <class Pybind11T = pybind11::enum_<CXCommentParamPassDirection>>
struct Bind_CXCommentParamPassDirection : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCommentParamPassDirection(EntityScope parent_h)
      : handle{parent_h, "CXCommentParamPassDirection", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes parameter passing direction for \\param or \\arg command.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCommentParamPassDirection(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCommentParamPassDirection_In",
                 CXCommentParamPassDirection::CXCommentParamPassDirection_In,
                 R"_pb11_weaver(/**
   * The parameter is an input parameter.
   */)_pb11_weaver");
    handle.value("CXCommentParamPassDirection_Out",
                 CXCommentParamPassDirection::CXCommentParamPassDirection_Out,
                 R"_pb11_weaver(/**
   * The parameter is an output parameter.
   */)_pb11_weaver");
    handle.value("CXCommentParamPassDirection_InOut",
                 CXCommentParamPassDirection::CXCommentParamPassDirection_InOut,
                 R"_pb11_weaver(/**
   * The parameter is an input and output parameter.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCommentParamPassDirection"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCommentParamPassDirection

using Entity_CXCommentParamPassDirection = Bind_CXCommentParamPassDirection<>;

#else

struct Entity_CXCommentParamPassDirection
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCommentParamPassDirection(EntityScope parent_h) {}
  static const char *Key() { return "CXCommentParamPassDirection"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCommentParamPassDirection

template <class Pybind11T = pybind11::enum_<CXCompilationDatabase_Error>>
struct Bind_CXCompilationDatabase_Error : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCompilationDatabase_Error(EntityScope parent_h)
      : handle{parent_h, "CXCompilationDatabase_Error", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Error codes for Compilation Database
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCompilationDatabase_Error(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCompilationDatabase_NoError",
                 CXCompilationDatabase_Error::CXCompilationDatabase_NoError,
                 R"_pb11_weaver(/*
   * No error occurred
   */)_pb11_weaver");
    handle.value(
        "CXCompilationDatabase_CanNotLoadDatabase",
        CXCompilationDatabase_Error::CXCompilationDatabase_CanNotLoadDatabase,
        R"_pb11_weaver(/*
   * Database can not be loaded
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCompilationDatabase_Error"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCompilationDatabase_Error

using Entity_CXCompilationDatabase_Error = Bind_CXCompilationDatabase_Error<>;

#else

struct Entity_CXCompilationDatabase_Error
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCompilationDatabase_Error(EntityScope parent_h) {}
  static const char *Key() { return "CXCompilationDatabase_Error"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCompilationDatabase_Error

template <class Pybind11T = pybind11::enum_<CXCompletionChunkKind>>
struct Bind_CXCompletionChunkKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCompletionChunkKind(EntityScope parent_h)
      : handle{parent_h, "CXCompletionChunkKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes a single piece of text within a code-completion string.
 *
 * Each "chunk" within a code-completion string (\c CXCompletionString) is
 * either a piece of text with a specific "kind" that describes how that text
 * should be interpreted by the client or is another completion string.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCompletionChunkKind(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCompletionChunk_Optional",
                 CXCompletionChunkKind::CXCompletionChunk_Optional,
                 R"_pb11_weaver(/**
   * A code-completion string that describes "optional" text that
   * could be a part of the template (but is not required).
   *
   * The Optional chunk is the only kind of chunk that has a code-completion
   * string for its representation, which is accessible via
   * \c clang_getCompletionChunkCompletionString(). The code-completion string
   * describes an additional part of the template that is completely optional.
   * For example, optional chunks can be used to describe the placeholders for
   * arguments that match up with defaulted function parameters, e.g. given:
   *
   * \code
   * void f(int x, float y = 3.14, double z = 2.71828);
   * \endcode
   *
   * The code-completion string for this function would contain:
   *   - a TypedText chunk for "f".
   *   - a LeftParen chunk for "(".
   *   - a Placeholder chunk for "int x"
   *   - an Optional chunk containing the remaining defaulted arguments, e.g.,
   *       - a Comma chunk for ","
   *       - a Placeholder chunk for "float y"
   *       - an Optional chunk containing the last defaulted argument:
   *           - a Comma chunk for ","
   *           - a Placeholder chunk for "double z"
   *   - a RightParen chunk for ")"
   *
   * There are many ways to handle Optional chunks. Two simple approaches are:
   *   - Completely ignore optional chunks, in which case the template for the
   *     function "f" would only include the first parameter ("int x").
   *   - Fully expand all optional chunks, in which case the template for the
   *     function "f" would have all of the parameters.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_TypedText",
                 CXCompletionChunkKind::CXCompletionChunk_TypedText,
                 R"_pb11_weaver(/**
   * Text that a user would be expected to type to get this
   * code-completion result.
   *
   * There will be exactly one "typed text" chunk in a semantic string, which
   * will typically provide the spelling of a keyword or the name of a
   * declaration that could be used at the current code point. Clients are
   * expected to filter the code-completion results based on the text in this
   * chunk.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_Text",
                 CXCompletionChunkKind::CXCompletionChunk_Text,
                 R"_pb11_weaver(/**
   * Text that should be inserted as part of a code-completion result.
   *
   * A "text" chunk represents text that is part of the template to be
   * inserted into user code should this particular code-completion result
   * be selected.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_Placeholder",
                 CXCompletionChunkKind::CXCompletionChunk_Placeholder,
                 R"_pb11_weaver(/**
   * Placeholder text that should be replaced by the user.
   *
   * A "placeholder" chunk marks a place where the user should insert text
   * into the code-completion template. For example, placeholders might mark
   * the function parameters for a function declaration, to indicate that the
   * user should provide arguments for each of those parameters. The actual
   * text in a placeholder is a suggestion for the text to display before
   * the user replaces the placeholder with real code.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_Informative",
                 CXCompletionChunkKind::CXCompletionChunk_Informative,
                 R"_pb11_weaver(/**
   * Informative text that should be displayed but never inserted as
   * part of the template.
   *
   * An "informative" chunk contains annotations that can be displayed to
   * help the user decide whether a particular code-completion result is the
   * right option, but which is not part of the actual template to be inserted
   * by code completion.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_CurrentParameter",
                 CXCompletionChunkKind::CXCompletionChunk_CurrentParameter,
                 R"_pb11_weaver(/**
   * Text that describes the current parameter when code-completion is
   * referring to function call, message send, or template specialization.
   *
   * A "current parameter" chunk occurs when code-completion is providing
   * information about a parameter corresponding to the argument at the
   * code-completion point. For example, given a function
   *
   * \code
   * int add(int x, int y);
   * \endcode
   *
   * and the source code \c add(, where the code-completion point is after the
   * "(", the code-completion string will contain a "current parameter" chunk
   * for "int x", indicating that the current argument will initialize that
   * parameter. After typing further, to \c add(17, (where the code-completion
   * point is after the ","), the code-completion string will contain a
   * "current parameter" chunk to "int y".
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_LeftParen",
                 CXCompletionChunkKind::CXCompletionChunk_LeftParen,
                 R"_pb11_weaver(/**
   * A left parenthesis ('('), used to initiate a function call or
   * signal the beginning of a function parameter list.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_RightParen",
                 CXCompletionChunkKind::CXCompletionChunk_RightParen,
                 R"_pb11_weaver(/**
   * A right parenthesis (')'), used to finish a function call or
   * signal the end of a function parameter list.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_LeftBracket",
                 CXCompletionChunkKind::CXCompletionChunk_LeftBracket,
                 R"_pb11_weaver(/**
   * A left bracket ('[').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_RightBracket",
                 CXCompletionChunkKind::CXCompletionChunk_RightBracket,
                 R"_pb11_weaver(/**
   * A right bracket (']').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_LeftBrace",
                 CXCompletionChunkKind::CXCompletionChunk_LeftBrace,
                 R"_pb11_weaver(/**
   * A left brace ('{').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_RightBrace",
                 CXCompletionChunkKind::CXCompletionChunk_RightBrace,
                 R"_pb11_weaver(/**
   * A right brace ('}').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_LeftAngle",
                 CXCompletionChunkKind::CXCompletionChunk_LeftAngle,
                 R"_pb11_weaver(/**
   * A left angle bracket ('<').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_RightAngle",
                 CXCompletionChunkKind::CXCompletionChunk_RightAngle,
                 R"_pb11_weaver(/**
   * A right angle bracket ('>').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_Comma",
                 CXCompletionChunkKind::CXCompletionChunk_Comma,
                 R"_pb11_weaver(/**
   * A comma separator (',').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_ResultType",
                 CXCompletionChunkKind::CXCompletionChunk_ResultType,
                 R"_pb11_weaver(/**
   * Text that specifies the result type of a given result.
   *
   * This special kind of informative chunk is not meant to be inserted into
   * the text buffer. Rather, it is meant to illustrate the type that an
   * expression using the given completion string would have.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_Colon",
                 CXCompletionChunkKind::CXCompletionChunk_Colon,
                 R"_pb11_weaver(/**
   * A colon (':').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_SemiColon",
                 CXCompletionChunkKind::CXCompletionChunk_SemiColon,
                 R"_pb11_weaver(/**
   * A semicolon (';').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_Equal",
                 CXCompletionChunkKind::CXCompletionChunk_Equal,
                 R"_pb11_weaver(/**
   * An '=' sign.
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_HorizontalSpace",
                 CXCompletionChunkKind::CXCompletionChunk_HorizontalSpace,
                 R"_pb11_weaver(/**
   * Horizontal space (' ').
   */)_pb11_weaver");
    handle.value("CXCompletionChunk_VerticalSpace",
                 CXCompletionChunkKind::CXCompletionChunk_VerticalSpace,
                 R"_pb11_weaver(/**
   * Vertical space ('\\n'), after which it is generally a good idea to
   * perform indentation.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCompletionChunkKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCompletionChunkKind

using Entity_CXCompletionChunkKind = Bind_CXCompletionChunkKind<>;

#else

struct Entity_CXCompletionChunkKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCompletionChunkKind(EntityScope parent_h) {}
  static const char *Key() { return "CXCompletionChunkKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCompletionChunkKind

template <class Pybind11T = pybind11::enum_<CXCompletionContext>>
struct Bind_CXCompletionContext : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCompletionContext(EntityScope parent_h)
      : handle{parent_h, "CXCompletionContext", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Bits that represent the context under which completion is occurring.
 *
 * The enumerators in this enumeration may be bitwise-OR'd together if multiple
 * contexts are occurring simultaneously.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCompletionContext(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCompletionContext_Unexposed",
                 CXCompletionContext::CXCompletionContext_Unexposed,
                 R"_pb11_weaver(/**
   * The context for completions is unexposed, as only Clang results
   * should be included. (This is equivalent to having no context bits set.)
   */)_pb11_weaver");
    handle.value("CXCompletionContext_AnyType",
                 CXCompletionContext::CXCompletionContext_AnyType,
                 R"_pb11_weaver(/**
   * Completions for any possible type should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_AnyValue",
                 CXCompletionContext::CXCompletionContext_AnyValue,
                 R"_pb11_weaver(/**
   * Completions for any possible value (variables, function calls, etc.)
   * should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCObjectValue",
                 CXCompletionContext::CXCompletionContext_ObjCObjectValue,
                 R"_pb11_weaver(/**
   * Completions for values that resolve to an Objective-C object should
   * be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCSelectorValue",
                 CXCompletionContext::CXCompletionContext_ObjCSelectorValue,
                 R"_pb11_weaver(/**
   * Completions for values that resolve to an Objective-C selector
   * should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_CXXClassTypeValue",
                 CXCompletionContext::CXCompletionContext_CXXClassTypeValue,
                 R"_pb11_weaver(/**
   * Completions for values that resolve to a C++ class type should be
   * included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_DotMemberAccess",
                 CXCompletionContext::CXCompletionContext_DotMemberAccess,
                 R"_pb11_weaver(/**
   * Completions for fields of the member being accessed using the dot
   * operator should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ArrowMemberAccess",
                 CXCompletionContext::CXCompletionContext_ArrowMemberAccess,
                 R"_pb11_weaver(/**
   * Completions for fields of the member being accessed using the arrow
   * operator should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCPropertyAccess",
                 CXCompletionContext::CXCompletionContext_ObjCPropertyAccess,
                 R"_pb11_weaver(/**
   * Completions for properties of the Objective-C object being accessed
   * using the dot operator should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_EnumTag",
                 CXCompletionContext::CXCompletionContext_EnumTag,
                 R"_pb11_weaver(/**
   * Completions for enum tags should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_UnionTag",
                 CXCompletionContext::CXCompletionContext_UnionTag,
                 R"_pb11_weaver(/**
   * Completions for union tags should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_StructTag",
                 CXCompletionContext::CXCompletionContext_StructTag,
                 R"_pb11_weaver(/**
   * Completions for struct tags should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ClassTag",
                 CXCompletionContext::CXCompletionContext_ClassTag,
                 R"_pb11_weaver(/**
   * Completions for C++ class names should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_Namespace",
                 CXCompletionContext::CXCompletionContext_Namespace,
                 R"_pb11_weaver(/**
   * Completions for C++ namespaces and namespace aliases should be
   * included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_NestedNameSpecifier",
                 CXCompletionContext::CXCompletionContext_NestedNameSpecifier,
                 R"_pb11_weaver(/**
   * Completions for C++ nested name specifiers should be included in
   * the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCInterface",
                 CXCompletionContext::CXCompletionContext_ObjCInterface,
                 R"_pb11_weaver(/**
   * Completions for Objective-C interfaces (classes) should be included
   * in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCProtocol",
                 CXCompletionContext::CXCompletionContext_ObjCProtocol,
                 R"_pb11_weaver(/**
   * Completions for Objective-C protocols should be included in
   * the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCCategory",
                 CXCompletionContext::CXCompletionContext_ObjCCategory,
                 R"_pb11_weaver(/**
   * Completions for Objective-C categories should be included in
   * the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCInstanceMessage",
                 CXCompletionContext::CXCompletionContext_ObjCInstanceMessage,
                 R"_pb11_weaver(/**
   * Completions for Objective-C instance messages should be included
   * in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCClassMessage",
                 CXCompletionContext::CXCompletionContext_ObjCClassMessage,
                 R"_pb11_weaver(/**
   * Completions for Objective-C class messages should be included in
   * the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_ObjCSelectorName",
                 CXCompletionContext::CXCompletionContext_ObjCSelectorName,
                 R"_pb11_weaver(/**
   * Completions for Objective-C selector names should be included in
   * the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_MacroName",
                 CXCompletionContext::CXCompletionContext_MacroName,
                 R"_pb11_weaver(/**
   * Completions for preprocessor macro names should be included in
   * the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_NaturalLanguage",
                 CXCompletionContext::CXCompletionContext_NaturalLanguage,
                 R"_pb11_weaver(/**
   * Natural language completions should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_IncludedFile",
                 CXCompletionContext::CXCompletionContext_IncludedFile,
                 R"_pb11_weaver(/**
   * #include file completions should be included in the results.
   */)_pb11_weaver");
    handle.value("CXCompletionContext_Unknown",
                 CXCompletionContext::CXCompletionContext_Unknown,
                 R"_pb11_weaver(/**
   * The current context is unknown, so set all contexts.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCompletionContext"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCompletionContext

using Entity_CXCompletionContext = Bind_CXCompletionContext<>;

#else

struct Entity_CXCompletionContext : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCompletionContext(EntityScope parent_h) {}
  static const char *Key() { return "CXCompletionContext"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCompletionContext

template <class Pybind11T = pybind11::class_<CXCompletionResult>>
struct Bind_CXCompletionResult : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCompletionResult(EntityScope parent_h)
      : handle{parent_h, "CXCompletionResult", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * A single result of code completion.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCompletionResult(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXCompletionResult>(handle);
    handle.def_readwrite("CursorKind", &CXCompletionResult::CursorKind,
                         R"_pb11_weaver(/**
   * The kind of entity that this completion refers to.
   *
   * The cursor kind will be a macro, keyword, or a declaration (one of the
   * *Decl cursor kinds), describing the entity that the completion is
   * referring to.
   *
   * \todo In the future, we would like to provide a full cursor, to allow
   * the client to extract additional information from declaration.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCompletionResult"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCompletionResult

using Entity_CXCompletionResult = Bind_CXCompletionResult<>;

#else

struct Entity_CXCompletionResult : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCompletionResult(EntityScope parent_h) {}
  static const char *Key() { return "CXCompletionResult"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCompletionResult

template <class Pybind11T = pybind11::class_<CXCursor>>
struct Bind_CXCursor : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCursor(EntityScope parent_h)
      : handle{parent_h, "CXCursor", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * A cursor representing some element in the abstract syntax tree for
 * a translation unit.
 *
 * The cursor abstraction unifies the different kinds of entities in a
 * program--declaration, statements, expressions, references to declarations,
 * etc.--under a single "cursor" abstraction with a common set of operations.
 * Common operation for a cursor include: getting the physical location in
 * a source file where the cursor points, getting the name associated with a
 * cursor, and retrieving cursors for any child nodes of a particular cursor.
 *
 * Cursors can be produced in two specific ways.
 * clang_getTranslationUnitCursor() produces a cursor for a translation unit,
 * from which one can use clang_visitChildren() to explore the rest of the
 * translation unit. clang_getCursor() maps from a physical source location
 * to the entity that resides at that location, allowing one to map from the
 * source code into the AST.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCursor(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXCursor>(handle);
    handle.def_readwrite("kind", &CXCursor::kind);
    handle.def_readwrite("xdata", &CXCursor::xdata);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCursor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCursor

using Entity_CXCursor = Bind_CXCursor<>;

#else

struct Entity_CXCursor : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCursor(EntityScope parent_h) {}
  static const char *Key() { return "CXCursor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCursor

template <class Pybind11T = pybind11::class_<CXCursorAndRangeVisitor>>
struct Bind_CXCursorAndRangeVisitor : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCursorAndRangeVisitor(EntityScope parent_h)
      : handle{parent_h, "CXCursorAndRangeVisitor", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXCursorAndRangeVisitor(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXCursorAndRangeVisitor>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCursorAndRangeVisitor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCursorAndRangeVisitor

using Entity_CXCursorAndRangeVisitor = Bind_CXCursorAndRangeVisitor<>;

#else

struct Entity_CXCursorAndRangeVisitor : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCursorAndRangeVisitor(EntityScope parent_h) {}
  static const char *Key() { return "CXCursorAndRangeVisitor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCursorAndRangeVisitor

template <class Pybind11T = pybind11::enum_<CXCursorKind>>
struct Bind_CXCursorKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCursorKind(EntityScope parent_h)
      : handle{parent_h, "CXCursorKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the kind of entity that a cursor refers to.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCursorKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCursor_UnexposedDecl", CXCursorKind::CXCursor_UnexposedDecl,
                 R"_pb11_weaver(/* Declarations */
  /**
   * A declaration whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed declarations have the same operations as any other kind
   * of declaration; one can extract their location information,
   * spelling, find their definitions, etc. However, the specific kind
   * of the declaration is not reported.
   */)_pb11_weaver");
    handle.value("CXCursor_StructDecl", CXCursorKind::CXCursor_StructDecl,
                 R"_pb11_weaver(/** A C or C++ struct. */)_pb11_weaver");
    handle.value("CXCursor_UnionDecl", CXCursorKind::CXCursor_UnionDecl,
                 R"_pb11_weaver(/** A C or C++ union. */)_pb11_weaver");
    handle.value("CXCursor_ClassDecl", CXCursorKind::CXCursor_ClassDecl,
                 R"_pb11_weaver(/** A C++ class. */)_pb11_weaver");
    handle.value("CXCursor_EnumDecl", CXCursorKind::CXCursor_EnumDecl,
                 R"_pb11_weaver(/** An enumeration. */)_pb11_weaver");
    handle.value("CXCursor_FieldDecl", CXCursorKind::CXCursor_FieldDecl,
                 R"_pb11_weaver(/**
   * A field (in C) or non-static data member (in C++) in a
   * struct, union, or C++ class.
   */)_pb11_weaver");
    handle.value("CXCursor_EnumConstantDecl",
                 CXCursorKind::CXCursor_EnumConstantDecl,
                 R"_pb11_weaver(/** An enumerator constant. */)_pb11_weaver");
    handle.value("CXCursor_FunctionDecl", CXCursorKind::CXCursor_FunctionDecl,
                 R"_pb11_weaver(/** A function. */)_pb11_weaver");
    handle.value("CXCursor_VarDecl", CXCursorKind::CXCursor_VarDecl,
                 R"_pb11_weaver(/** A variable. */)_pb11_weaver");
    handle.value(
        "CXCursor_ParmDecl", CXCursorKind::CXCursor_ParmDecl,
        R"_pb11_weaver(/** A function or method parameter. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCInterfaceDecl", CXCursorKind::CXCursor_ObjCInterfaceDecl,
        R"_pb11_weaver(/** An Objective-C \@interface. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCCategoryDecl", CXCursorKind::CXCursor_ObjCCategoryDecl,
        R"_pb11_weaver(/** An Objective-C \@interface for a category. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCProtocolDecl", CXCursorKind::CXCursor_ObjCProtocolDecl,
        R"_pb11_weaver(/** An Objective-C \@protocol declaration. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCPropertyDecl", CXCursorKind::CXCursor_ObjCPropertyDecl,
        R"_pb11_weaver(/** An Objective-C \@property declaration. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCIvarDecl", CXCursorKind::CXCursor_ObjCIvarDecl,
        R"_pb11_weaver(/** An Objective-C instance variable. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCInstanceMethodDecl",
        CXCursorKind::CXCursor_ObjCInstanceMethodDecl,
        R"_pb11_weaver(/** An Objective-C instance method. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCClassMethodDecl",
        CXCursorKind::CXCursor_ObjCClassMethodDecl,
        R"_pb11_weaver(/** An Objective-C class method. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCImplementationDecl",
        CXCursorKind::CXCursor_ObjCImplementationDecl,
        R"_pb11_weaver(/** An Objective-C \@implementation. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCCategoryImplDecl",
        CXCursorKind::CXCursor_ObjCCategoryImplDecl,
        R"_pb11_weaver(/** An Objective-C \@implementation for a category. */)_pb11_weaver");
    handle.value("CXCursor_TypedefDecl", CXCursorKind::CXCursor_TypedefDecl,
                 R"_pb11_weaver(/** A typedef. */)_pb11_weaver");
    handle.value("CXCursor_CXXMethod", CXCursorKind::CXCursor_CXXMethod,
                 R"_pb11_weaver(/** A C++ class method. */)_pb11_weaver");
    handle.value("CXCursor_Namespace", CXCursorKind::CXCursor_Namespace,
                 R"_pb11_weaver(/** A C++ namespace. */)_pb11_weaver");
    handle.value(
        "CXCursor_LinkageSpec", CXCursorKind::CXCursor_LinkageSpec,
        R"_pb11_weaver(/** A linkage specification, e.g. 'extern "C"'. */)_pb11_weaver");
    handle.value("CXCursor_Constructor", CXCursorKind::CXCursor_Constructor,
                 R"_pb11_weaver(/** A C++ constructor. */)_pb11_weaver");
    handle.value("CXCursor_Destructor", CXCursorKind::CXCursor_Destructor,
                 R"_pb11_weaver(/** A C++ destructor. */)_pb11_weaver");
    handle.value(
        "CXCursor_ConversionFunction",
        CXCursorKind::CXCursor_ConversionFunction,
        R"_pb11_weaver(/** A C++ conversion function. */)_pb11_weaver");
    handle.value(
        "CXCursor_TemplateTypeParameter",
        CXCursorKind::CXCursor_TemplateTypeParameter,
        R"_pb11_weaver(/** A C++ template type parameter. */)_pb11_weaver");
    handle.value(
        "CXCursor_NonTypeTemplateParameter",
        CXCursorKind::CXCursor_NonTypeTemplateParameter,
        R"_pb11_weaver(/** A C++ non-type template parameter. */)_pb11_weaver");
    handle.value(
        "CXCursor_TemplateTemplateParameter",
        CXCursorKind::CXCursor_TemplateTemplateParameter,
        R"_pb11_weaver(/** A C++ template template parameter. */)_pb11_weaver");
    handle.value("CXCursor_FunctionTemplate",
                 CXCursorKind::CXCursor_FunctionTemplate,
                 R"_pb11_weaver(/** A C++ function template. */)_pb11_weaver");
    handle.value("CXCursor_ClassTemplate", CXCursorKind::CXCursor_ClassTemplate,
                 R"_pb11_weaver(/** A C++ class template. */)_pb11_weaver");
    handle.value(
        "CXCursor_ClassTemplatePartialSpecialization",
        CXCursorKind::CXCursor_ClassTemplatePartialSpecialization,
        R"_pb11_weaver(/** A C++ class template partial specialization. */)_pb11_weaver");
    handle.value(
        "CXCursor_NamespaceAlias", CXCursorKind::CXCursor_NamespaceAlias,
        R"_pb11_weaver(/** A C++ namespace alias declaration. */)_pb11_weaver");
    handle.value("CXCursor_UsingDirective",
                 CXCursorKind::CXCursor_UsingDirective,
                 R"_pb11_weaver(/** A C++ using directive. */)_pb11_weaver");
    handle.value("CXCursor_UsingDeclaration",
                 CXCursorKind::CXCursor_UsingDeclaration,
                 R"_pb11_weaver(/** A C++ using declaration. */)_pb11_weaver");
    handle.value("CXCursor_TypeAliasDecl", CXCursorKind::CXCursor_TypeAliasDecl,
                 R"_pb11_weaver(/** A C++ alias declaration */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCSynthesizeDecl",
        CXCursorKind::CXCursor_ObjCSynthesizeDecl,
        R"_pb11_weaver(/** An Objective-C \@synthesize definition. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCDynamicDecl", CXCursorKind::CXCursor_ObjCDynamicDecl,
        R"_pb11_weaver(/** An Objective-C \@dynamic definition. */)_pb11_weaver");
    handle.value("CXCursor_CXXAccessSpecifier",
                 CXCursorKind::CXCursor_CXXAccessSpecifier,
                 R"_pb11_weaver(/** An access specifier. */)_pb11_weaver");
    handle.value("CXCursor_FirstDecl", CXCursorKind::CXCursor_FirstDecl,
                 R"_pb11_weaver(/** An access specifier. */)_pb11_weaver");
    handle.value("CXCursor_LastDecl", CXCursorKind::CXCursor_LastDecl,
                 R"_pb11_weaver(/** An access specifier. */)_pb11_weaver");
    handle.value("CXCursor_FirstRef", CXCursorKind::CXCursor_FirstRef,
                 R"_pb11_weaver(/* Decl references */)_pb11_weaver");
    handle.value("CXCursor_ObjCSuperClassRef",
                 CXCursorKind::CXCursor_ObjCSuperClassRef);
    handle.value("CXCursor_ObjCProtocolRef",
                 CXCursorKind::CXCursor_ObjCProtocolRef);
    handle.value("CXCursor_ObjCClassRef", CXCursorKind::CXCursor_ObjCClassRef);
    handle.value("CXCursor_TypeRef", CXCursorKind::CXCursor_TypeRef,
                 R"_pb11_weaver(/**
   * A reference to a type declaration.
   *
   * A type reference occurs anywhere where a type is named but not
   * declared. For example, given:
   *
   * \code
   * typedef unsigned size_type;
   * size_type size;
   * \endcode
   *
   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),
   * while the type of the variable "size" is referenced. The cursor
   * referenced by the type of size is the typedef for size_type.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXBaseSpecifier",
                 CXCursorKind::CXCursor_CXXBaseSpecifier, R"_pb11_weaver(/**
   * A reference to a type declaration.
   *
   * A type reference occurs anywhere where a type is named but not
   * declared. For example, given:
   *
   * \code
   * typedef unsigned size_type;
   * size_type size;
   * \endcode
   *
   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),
   * while the type of the variable "size" is referenced. The cursor
   * referenced by the type of size is the typedef for size_type.
   */)_pb11_weaver");
    handle.value("CXCursor_TemplateRef", CXCursorKind::CXCursor_TemplateRef,
                 R"_pb11_weaver(/**
   * A reference to a class template, function template, template
   * template parameter, or class template partial specialization.
   */)_pb11_weaver");
    handle.value("CXCursor_NamespaceRef", CXCursorKind::CXCursor_NamespaceRef,
                 R"_pb11_weaver(/**
   * A reference to a namespace or namespace alias.
   */)_pb11_weaver");
    handle.value("CXCursor_MemberRef", CXCursorKind::CXCursor_MemberRef,
                 R"_pb11_weaver(/**
   * A reference to a member of a struct, union, or class that occurs in
   * some non-expression context, e.g., a designated initializer.
   */)_pb11_weaver");
    handle.value("CXCursor_LabelRef", CXCursorKind::CXCursor_LabelRef,
                 R"_pb11_weaver(/**
   * A reference to a labeled statement.
   *
   * This cursor kind is used to describe the jump to "start_over" in the
   * goto statement in the following example:
   *
   * \code
   *   start_over:
   *     ++counter;
   *
   *     goto start_over;
   * \endcode
   *
   * A label reference cursor refers to a label statement.
   */)_pb11_weaver");
    handle.value("CXCursor_OverloadedDeclRef",
                 CXCursorKind::CXCursor_OverloadedDeclRef, R"_pb11_weaver(/**
   * A reference to a set of overloaded functions or function templates
   * that has not yet been resolved to a specific function or function template.
   *
   * An overloaded declaration reference cursor occurs in C++ templates where
   * a dependent name refers to a function. For example:
   *
   * \code
   * template<typename T> void swap(T&, T&);
   *
   * struct X { ... };
   * void swap(X&, X&);
   *
   * template<typename T>
   * void reverse(T* first, T* last) {
   *   while (first < last - 1) {
   *     swap(*first, *--last);
   *     ++first;
   *   }
   * }
   *
   * struct Y { };
   * void swap(Y&, Y&);
   * \endcode
   *
   * Here, the identifier "swap" is associated with an overloaded declaration
   * reference. In the template definition, "swap" refers to either of the two
   * "swap" functions declared above, so both results will be available. At
   * instantiation time, "swap" may also refer to other functions found via
   * argument-dependent lookup (e.g., the "swap" function at the end of the
   * example).
   *
   * The functions \c clang_getNumOverloadedDecls() and
   * \c clang_getOverloadedDecl() can be used to retrieve the definitions
   * referenced by this cursor.
   */)_pb11_weaver");
    handle.value("CXCursor_VariableRef", CXCursorKind::CXCursor_VariableRef,
                 R"_pb11_weaver(/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */)_pb11_weaver");
    handle.value("CXCursor_LastRef", CXCursorKind::CXCursor_LastRef,
                 R"_pb11_weaver(/**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */)_pb11_weaver");
    handle.value("CXCursor_FirstInvalid", CXCursorKind::CXCursor_FirstInvalid,
                 R"_pb11_weaver(/* Error conditions */)_pb11_weaver");
    handle.value("CXCursor_InvalidFile", CXCursorKind::CXCursor_InvalidFile,
                 R"_pb11_weaver(/* Error conditions */)_pb11_weaver");
    handle.value("CXCursor_NoDeclFound", CXCursorKind::CXCursor_NoDeclFound,
                 R"_pb11_weaver(/* Error conditions */)_pb11_weaver");
    handle.value("CXCursor_NotImplemented",
                 CXCursorKind::CXCursor_NotImplemented,
                 R"_pb11_weaver(/* Error conditions */)_pb11_weaver");
    handle.value("CXCursor_InvalidCode", CXCursorKind::CXCursor_InvalidCode,
                 R"_pb11_weaver(/* Error conditions */)_pb11_weaver");
    handle.value("CXCursor_LastInvalid", CXCursorKind::CXCursor_LastInvalid,
                 R"_pb11_weaver(/* Error conditions */)_pb11_weaver");
    handle.value("CXCursor_FirstExpr", CXCursorKind::CXCursor_FirstExpr,
                 R"_pb11_weaver(/* Expressions */)_pb11_weaver");
    handle.value("CXCursor_UnexposedExpr", CXCursorKind::CXCursor_UnexposedExpr,
                 R"_pb11_weaver(/**
   * An expression whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed expressions have the same operations as any other kind
   * of expression; one can extract their location information,
   * spelling, children, etc. However, the specific kind of the
   * expression is not reported.
   */)_pb11_weaver");
    handle.value("CXCursor_DeclRefExpr", CXCursorKind::CXCursor_DeclRefExpr,
                 R"_pb11_weaver(/**
   * An expression that refers to some value declaration, such
   * as a function, variable, or enumerator.
   */)_pb11_weaver");
    handle.value("CXCursor_MemberRefExpr", CXCursorKind::CXCursor_MemberRefExpr,
                 R"_pb11_weaver(/**
   * An expression that refers to a member of a struct, union,
   * class, Objective-C class, etc.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_CallExpr", CXCursorKind::CXCursor_CallExpr,
        R"_pb11_weaver(/** An expression that calls a function. */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCMessageExpr", CXCursorKind::CXCursor_ObjCMessageExpr,
        R"_pb11_weaver(/** An expression that sends a message to an Objective-C
   object or class. */)_pb11_weaver");
    handle.value(
        "CXCursor_BlockExpr", CXCursorKind::CXCursor_BlockExpr,
        R"_pb11_weaver(/** An expression that represents a block literal. */)_pb11_weaver");
    handle.value("CXCursor_IntegerLiteral",
                 CXCursorKind::CXCursor_IntegerLiteral,
                 R"_pb11_weaver(/** An integer literal.
   */)_pb11_weaver");
    handle.value("CXCursor_FloatingLiteral",
                 CXCursorKind::CXCursor_FloatingLiteral,
                 R"_pb11_weaver(/** A floating point number literal.
   */)_pb11_weaver");
    handle.value("CXCursor_ImaginaryLiteral",
                 CXCursorKind::CXCursor_ImaginaryLiteral,
                 R"_pb11_weaver(/** An imaginary number literal.
   */)_pb11_weaver");
    handle.value("CXCursor_StringLiteral", CXCursorKind::CXCursor_StringLiteral,
                 R"_pb11_weaver(/** A string literal.
   */)_pb11_weaver");
    handle.value("CXCursor_CharacterLiteral",
                 CXCursorKind::CXCursor_CharacterLiteral,
                 R"_pb11_weaver(/** A character literal.
   */)_pb11_weaver");
    handle.value("CXCursor_ParenExpr", CXCursorKind::CXCursor_ParenExpr,
                 R"_pb11_weaver(/** A parenthesized expression, e.g. "(1)".
   *
   * This AST node is only formed if full location information is requested.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_UnaryOperator", CXCursorKind::CXCursor_UnaryOperator,
        R"_pb11_weaver(/** This represents the unary-expression's (except sizeof and
   * alignof).
   */)_pb11_weaver");
    handle.value("CXCursor_ArraySubscriptExpr",
                 CXCursorKind::CXCursor_ArraySubscriptExpr,
                 R"_pb11_weaver(/** [C99 6.5.2.1] Array Subscripting.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_BinaryOperator", CXCursorKind::CXCursor_BinaryOperator,
        R"_pb11_weaver(/** A builtin binary operation expression such as "x + y" or
   * "x <= y".
   */)_pb11_weaver");
    handle.value("CXCursor_CompoundAssignOperator",
                 CXCursorKind::CXCursor_CompoundAssignOperator,
                 R"_pb11_weaver(/** Compound assignment such as "+=".
   */)_pb11_weaver");
    handle.value("CXCursor_ConditionalOperator",
                 CXCursorKind::CXCursor_ConditionalOperator,
                 R"_pb11_weaver(/** The ?: ternary operator.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_CStyleCastExpr", CXCursorKind::CXCursor_CStyleCastExpr,
        R"_pb11_weaver(/** An explicit cast in C (C99 6.5.4) or a C-style cast in C++
   * (C++ [expr.cast]), which uses the syntax (Type)expr.
   *
   * For example: (int)f.
   */)_pb11_weaver");
    handle.value("CXCursor_CompoundLiteralExpr",
                 CXCursorKind::CXCursor_CompoundLiteralExpr,
                 R"_pb11_weaver(/** [C99 6.5.2.5]
   */)_pb11_weaver");
    handle.value("CXCursor_InitListExpr", CXCursorKind::CXCursor_InitListExpr,
                 R"_pb11_weaver(/** Describes an C or C++ initializer list.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_AddrLabelExpr", CXCursorKind::CXCursor_AddrLabelExpr,
        R"_pb11_weaver(/** The GNU address of label extension, representing &&label.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_StmtExpr", CXCursorKind::CXCursor_StmtExpr,
        R"_pb11_weaver(/** This is the GNU Statement Expression extension: ({int X=4; X;})
   */)_pb11_weaver");
    handle.value("CXCursor_GenericSelectionExpr",
                 CXCursorKind::CXCursor_GenericSelectionExpr,
                 R"_pb11_weaver(/** Represents a C11 generic selection.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_GNUNullExpr", CXCursorKind::CXCursor_GNUNullExpr,
        R"_pb11_weaver(/** Implements the GNU __null extension, which is a name for a null
   * pointer constant that has integral type (e.g., int or long) and is the same
   * size and alignment as a pointer.
   *
   * The __null extension is typically only used by system headers, which define
   * NULL as __null in C++ rather than using 0 (which is an integer that may not
   * match the size of a pointer).
   */)_pb11_weaver");
    handle.value("CXCursor_CXXStaticCastExpr",
                 CXCursorKind::CXCursor_CXXStaticCastExpr,
                 R"_pb11_weaver(/** C++'s static_cast<> expression.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXDynamicCastExpr",
                 CXCursorKind::CXCursor_CXXDynamicCastExpr,
                 R"_pb11_weaver(/** C++'s dynamic_cast<> expression.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXReinterpretCastExpr",
                 CXCursorKind::CXCursor_CXXReinterpretCastExpr,
                 R"_pb11_weaver(/** C++'s reinterpret_cast<> expression.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXConstCastExpr",
                 CXCursorKind::CXCursor_CXXConstCastExpr,
                 R"_pb11_weaver(/** C++'s const_cast<> expression.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_CXXFunctionalCastExpr",
        CXCursorKind::CXCursor_CXXFunctionalCastExpr,
        R"_pb11_weaver(/** Represents an explicit C++ type conversion that uses "functional"
   * notion (C++ [expr.type.conv]).
   *
   * Example:
   * \code
   *   x = int(0.5);
   * \endcode
   */)_pb11_weaver");
    handle.value("CXCursor_CXXTypeidExpr", CXCursorKind::CXCursor_CXXTypeidExpr,
                 R"_pb11_weaver(/** A C++ typeid expression (C++ [expr.typeid]).
   */)_pb11_weaver");
    handle.value("CXCursor_CXXBoolLiteralExpr",
                 CXCursorKind::CXCursor_CXXBoolLiteralExpr,
                 R"_pb11_weaver(/** [C++ 2.13.5] C++ Boolean Literal.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXNullPtrLiteralExpr",
                 CXCursorKind::CXCursor_CXXNullPtrLiteralExpr,
                 R"_pb11_weaver(/** [C++0x 2.14.7] C++ Pointer Literal.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXThisExpr", CXCursorKind::CXCursor_CXXThisExpr,
                 R"_pb11_weaver(/** Represents the "this" expression in C++
   */)_pb11_weaver");
    handle.value("CXCursor_CXXThrowExpr", CXCursorKind::CXCursor_CXXThrowExpr,
                 R"_pb11_weaver(/** [C++ 15] C++ Throw Expression.
   *
   * This handles 'throw' and 'throw' assignment-expression. When
   * assignment-expression isn't present, Op will be null.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_CXXNewExpr", CXCursorKind::CXCursor_CXXNewExpr,
        R"_pb11_weaver(/** A new expression for memory allocation and constructor calls, e.g:
   * "new CXXNewExpr(foo)".
   */)_pb11_weaver");
    handle.value(
        "CXCursor_CXXDeleteExpr", CXCursorKind::CXCursor_CXXDeleteExpr,
        R"_pb11_weaver(/** A delete expression for memory deallocation and destructor calls,
   * e.g. "delete[] pArray".
   */)_pb11_weaver");
    handle.value(
        "CXCursor_UnaryExpr", CXCursorKind::CXCursor_UnaryExpr,
        R"_pb11_weaver(/** A unary expression. (noexcept, sizeof, or other traits)
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCStringLiteral",
                 CXCursorKind::CXCursor_ObjCStringLiteral,
                 R"_pb11_weaver(/** An Objective-C string literal i.e. @"foo".
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCEncodeExpr",
                 CXCursorKind::CXCursor_ObjCEncodeExpr,
                 R"_pb11_weaver(/** An Objective-C \@encode expression.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCSelectorExpr",
                 CXCursorKind::CXCursor_ObjCSelectorExpr,
                 R"_pb11_weaver(/** An Objective-C \@selector expression.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCProtocolExpr",
                 CXCursorKind::CXCursor_ObjCProtocolExpr,
                 R"_pb11_weaver(/** An Objective-C \@protocol expression.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCBridgedCastExpr",
        CXCursorKind::CXCursor_ObjCBridgedCastExpr,
        R"_pb11_weaver(/** An Objective-C "bridged" cast expression, which casts between
   * Objective-C pointers and C pointers, transferring ownership in the process.
   *
   * \code
   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();
   * \endcode
   */)_pb11_weaver");
    handle.value(
        "CXCursor_PackExpansionExpr", CXCursorKind::CXCursor_PackExpansionExpr,
        R"_pb11_weaver(/** Represents a C++0x pack expansion that produces a sequence of
   * expressions.
   *
   * A pack expansion expression contains a pattern (which itself is an
   * expression) followed by an ellipsis. For example:
   *
   * \code
   * template<typename F, typename ...Types>
   * void forward(F f, Types &&...args) {
   *  f(static_cast<Types&&>(args)...);
   * }
   * \endcode
   */)_pb11_weaver");
    handle.value(
        "CXCursor_SizeOfPackExpr", CXCursorKind::CXCursor_SizeOfPackExpr,
        R"_pb11_weaver(/** Represents an expression that computes the length of a parameter
   * pack.
   *
   * \code
   * template<typename ...Types>
   * struct count {
   *   static const unsigned value = sizeof...(Types);
   * };
   * \endcode
   */)_pb11_weaver");
    handle.value(
        "CXCursor_LambdaExpr", CXCursorKind::CXCursor_LambdaExpr,
        R"_pb11_weaver(/* Represents a C++ lambda expression that produces a local function
   * object.
   *
   * \code
   * void abssort(float *x, unsigned N) {
   *   std::sort(x, x + N,
   *             [](float a, float b) {
   *               return std::abs(a) < std::abs(b);
   *             });
   * }
   * \endcode
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCBoolLiteralExpr",
                 CXCursorKind::CXCursor_ObjCBoolLiteralExpr,
                 R"_pb11_weaver(/** Objective-c Boolean Literal.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCSelfExpr", CXCursorKind::CXCursor_ObjCSelfExpr,
        R"_pb11_weaver(/** Represents the "self" expression in an Objective-C method.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPArraySectionExpr",
                 CXCursorKind::CXCursor_OMPArraySectionExpr,
                 R"_pb11_weaver(/** OpenMP 5.0 [2.1.5, Array Section].
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCAvailabilityCheckExpr",
                 CXCursorKind::CXCursor_ObjCAvailabilityCheckExpr,
                 R"_pb11_weaver(/** Represents an @available(...) check.
   */)_pb11_weaver");
    handle.value("CXCursor_FixedPointLiteral",
                 CXCursorKind::CXCursor_FixedPointLiteral, R"_pb11_weaver(/**
   * Fixed point literal
   */)_pb11_weaver");
    handle.value("CXCursor_OMPArrayShapingExpr",
                 CXCursorKind::CXCursor_OMPArrayShapingExpr,
                 R"_pb11_weaver(/** OpenMP 5.0 [2.1.4, Array Shaping].
   */)_pb11_weaver");
    handle.value("CXCursor_OMPIteratorExpr",
                 CXCursorKind::CXCursor_OMPIteratorExpr, R"_pb11_weaver(/**
   * OpenMP 5.0 [2.1.6 Iterators]
   */)_pb11_weaver");
    handle.value("CXCursor_CXXAddrspaceCastExpr",
                 CXCursorKind::CXCursor_CXXAddrspaceCastExpr,
                 R"_pb11_weaver(/** OpenCL's addrspace_cast<> expression.
   */)_pb11_weaver");
    handle.value("CXCursor_ConceptSpecializationExpr",
                 CXCursorKind::CXCursor_ConceptSpecializationExpr,
                 R"_pb11_weaver(/**
   * Expression that references a C++20 concept.
   */)_pb11_weaver");
    handle.value("CXCursor_RequiresExpr", CXCursorKind::CXCursor_RequiresExpr,
                 R"_pb11_weaver(/**
   * Expression that references a C++20 concept.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXParenListInitExpr",
                 CXCursorKind::CXCursor_CXXParenListInitExpr, R"_pb11_weaver(/**
   * Expression that references a C++20 parenthesized list aggregate
   * initializer.
   */)_pb11_weaver");
    handle.value("CXCursor_LastExpr", CXCursorKind::CXCursor_LastExpr,
                 R"_pb11_weaver(/**
   * Expression that references a C++20 parenthesized list aggregate
   * initializer.
   */)_pb11_weaver");
    handle.value("CXCursor_FirstStmt", CXCursorKind::CXCursor_FirstStmt,
                 R"_pb11_weaver(/* Statements */)_pb11_weaver");
    handle.value("CXCursor_UnexposedStmt", CXCursorKind::CXCursor_UnexposedStmt,
                 R"_pb11_weaver(/**
   * A statement whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed statements have the same operations as any other kind of
   * statement; one can extract their location information, spelling,
   * children, etc. However, the specific kind of the statement is not
   * reported.
   */)_pb11_weaver");
    handle.value("CXCursor_LabelStmt", CXCursorKind::CXCursor_LabelStmt,
                 R"_pb11_weaver(/** A labelled statement in a function.
   *
   * This cursor kind is used to describe the "start_over:" label statement in
   * the following example:
   *
   * \code
   *   start_over:
   *     ++counter;
   * \endcode
   *
   */)_pb11_weaver");
    handle.value("CXCursor_CompoundStmt", CXCursorKind::CXCursor_CompoundStmt,
                 R"_pb11_weaver(/** A group of statements like { stmt stmt }.
   *
   * This cursor kind is used to describe compound statements, e.g. function
   * bodies.
   */)_pb11_weaver");
    handle.value("CXCursor_CaseStmt", CXCursorKind::CXCursor_CaseStmt,
                 R"_pb11_weaver(/** A case statement.
   */)_pb11_weaver");
    handle.value("CXCursor_DefaultStmt", CXCursorKind::CXCursor_DefaultStmt,
                 R"_pb11_weaver(/** A default statement.
   */)_pb11_weaver");
    handle.value("CXCursor_IfStmt", CXCursorKind::CXCursor_IfStmt,
                 R"_pb11_weaver(/** An if statement
   */)_pb11_weaver");
    handle.value("CXCursor_SwitchStmt", CXCursorKind::CXCursor_SwitchStmt,
                 R"_pb11_weaver(/** A switch statement.
   */)_pb11_weaver");
    handle.value("CXCursor_WhileStmt", CXCursorKind::CXCursor_WhileStmt,
                 R"_pb11_weaver(/** A while statement.
   */)_pb11_weaver");
    handle.value("CXCursor_DoStmt", CXCursorKind::CXCursor_DoStmt,
                 R"_pb11_weaver(/** A do statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ForStmt", CXCursorKind::CXCursor_ForStmt,
                 R"_pb11_weaver(/** A for statement.
   */)_pb11_weaver");
    handle.value("CXCursor_GotoStmt", CXCursorKind::CXCursor_GotoStmt,
                 R"_pb11_weaver(/** A goto statement.
   */)_pb11_weaver");
    handle.value("CXCursor_IndirectGotoStmt",
                 CXCursorKind::CXCursor_IndirectGotoStmt,
                 R"_pb11_weaver(/** An indirect goto statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ContinueStmt", CXCursorKind::CXCursor_ContinueStmt,
                 R"_pb11_weaver(/** A continue statement.
   */)_pb11_weaver");
    handle.value("CXCursor_BreakStmt", CXCursorKind::CXCursor_BreakStmt,
                 R"_pb11_weaver(/** A break statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ReturnStmt", CXCursorKind::CXCursor_ReturnStmt,
                 R"_pb11_weaver(/** A return statement.
   */)_pb11_weaver");
    handle.value("CXCursor_GCCAsmStmt", CXCursorKind::CXCursor_GCCAsmStmt,
                 R"_pb11_weaver(/** A GCC inline assembly statement extension.
   */)_pb11_weaver");
    handle.value("CXCursor_AsmStmt", CXCursorKind::CXCursor_AsmStmt,
                 R"_pb11_weaver(/** A GCC inline assembly statement extension.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_ObjCAtTryStmt", CXCursorKind::CXCursor_ObjCAtTryStmt,
        R"_pb11_weaver(/** Objective-C's overall \@try-\@catch-\@finally statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCAtCatchStmt",
                 CXCursorKind::CXCursor_ObjCAtCatchStmt,
                 R"_pb11_weaver(/** Objective-C's \@catch statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCAtFinallyStmt",
                 CXCursorKind::CXCursor_ObjCAtFinallyStmt,
                 R"_pb11_weaver(/** Objective-C's \@finally statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCAtThrowStmt",
                 CXCursorKind::CXCursor_ObjCAtThrowStmt,
                 R"_pb11_weaver(/** Objective-C's \@throw statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCAtSynchronizedStmt",
                 CXCursorKind::CXCursor_ObjCAtSynchronizedStmt,
                 R"_pb11_weaver(/** Objective-C's \@synchronized statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCAutoreleasePoolStmt",
                 CXCursorKind::CXCursor_ObjCAutoreleasePoolStmt,
                 R"_pb11_weaver(/** Objective-C's autorelease pool statement.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCForCollectionStmt",
                 CXCursorKind::CXCursor_ObjCForCollectionStmt,
                 R"_pb11_weaver(/** Objective-C's collection statement.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXCatchStmt", CXCursorKind::CXCursor_CXXCatchStmt,
                 R"_pb11_weaver(/** C++'s catch statement.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXTryStmt", CXCursorKind::CXCursor_CXXTryStmt,
                 R"_pb11_weaver(/** C++'s try statement.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXForRangeStmt",
                 CXCursorKind::CXCursor_CXXForRangeStmt,
                 R"_pb11_weaver(/** C++'s for (* : *) statement.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_SEHTryStmt", CXCursorKind::CXCursor_SEHTryStmt,
        R"_pb11_weaver(/** Windows Structured Exception Handling's try statement.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_SEHExceptStmt", CXCursorKind::CXCursor_SEHExceptStmt,
        R"_pb11_weaver(/** Windows Structured Exception Handling's except statement.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_SEHFinallyStmt", CXCursorKind::CXCursor_SEHFinallyStmt,
        R"_pb11_weaver(/** Windows Structured Exception Handling's finally statement.
   */)_pb11_weaver");
    handle.value("CXCursor_MSAsmStmt", CXCursorKind::CXCursor_MSAsmStmt,
                 R"_pb11_weaver(/** A MS inline assembly statement extension.
   */)_pb11_weaver");
    handle.value("CXCursor_NullStmt", CXCursorKind::CXCursor_NullStmt,
                 R"_pb11_weaver(/** The null statement ";": C99 6.8.3p3.
   *
   * This cursor kind is used to describe the null statement.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_DeclStmt", CXCursorKind::CXCursor_DeclStmt,
        R"_pb11_weaver(/** Adaptor class for mixing declarations with statements and
   * expressions.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelDirective",
                 CXCursorKind::CXCursor_OMPParallelDirective,
                 R"_pb11_weaver(/** OpenMP parallel directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPSimdDirective",
                 CXCursorKind::CXCursor_OMPSimdDirective,
                 R"_pb11_weaver(/** OpenMP SIMD directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPForDirective",
                 CXCursorKind::CXCursor_OMPForDirective,
                 R"_pb11_weaver(/** OpenMP for directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPSectionsDirective",
                 CXCursorKind::CXCursor_OMPSectionsDirective,
                 R"_pb11_weaver(/** OpenMP sections directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPSectionDirective",
                 CXCursorKind::CXCursor_OMPSectionDirective,
                 R"_pb11_weaver(/** OpenMP section directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPSingleDirective",
                 CXCursorKind::CXCursor_OMPSingleDirective,
                 R"_pb11_weaver(/** OpenMP single directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelForDirective",
                 CXCursorKind::CXCursor_OMPParallelForDirective,
                 R"_pb11_weaver(/** OpenMP parallel for directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelSectionsDirective",
                 CXCursorKind::CXCursor_OMPParallelSectionsDirective,
                 R"_pb11_weaver(/** OpenMP parallel sections directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTaskDirective",
                 CXCursorKind::CXCursor_OMPTaskDirective,
                 R"_pb11_weaver(/** OpenMP task directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPMasterDirective",
                 CXCursorKind::CXCursor_OMPMasterDirective,
                 R"_pb11_weaver(/** OpenMP master directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPCriticalDirective",
                 CXCursorKind::CXCursor_OMPCriticalDirective,
                 R"_pb11_weaver(/** OpenMP critical directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTaskyieldDirective",
                 CXCursorKind::CXCursor_OMPTaskyieldDirective,
                 R"_pb11_weaver(/** OpenMP taskyield directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPBarrierDirective",
                 CXCursorKind::CXCursor_OMPBarrierDirective,
                 R"_pb11_weaver(/** OpenMP barrier directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTaskwaitDirective",
                 CXCursorKind::CXCursor_OMPTaskwaitDirective,
                 R"_pb11_weaver(/** OpenMP taskwait directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPFlushDirective",
                 CXCursorKind::CXCursor_OMPFlushDirective,
                 R"_pb11_weaver(/** OpenMP flush directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_SEHLeaveStmt", CXCursorKind::CXCursor_SEHLeaveStmt,
        R"_pb11_weaver(/** Windows Structured Exception Handling's leave statement.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPOrderedDirective",
                 CXCursorKind::CXCursor_OMPOrderedDirective,
                 R"_pb11_weaver(/** OpenMP ordered directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPAtomicDirective",
                 CXCursorKind::CXCursor_OMPAtomicDirective,
                 R"_pb11_weaver(/** OpenMP atomic directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPForSimdDirective",
                 CXCursorKind::CXCursor_OMPForSimdDirective,
                 R"_pb11_weaver(/** OpenMP for SIMD directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelForSimdDirective",
                 CXCursorKind::CXCursor_OMPParallelForSimdDirective,
                 R"_pb11_weaver(/** OpenMP parallel for SIMD directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetDirective",
                 CXCursorKind::CXCursor_OMPTargetDirective,
                 R"_pb11_weaver(/** OpenMP target directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTeamsDirective",
                 CXCursorKind::CXCursor_OMPTeamsDirective,
                 R"_pb11_weaver(/** OpenMP teams directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTaskgroupDirective",
                 CXCursorKind::CXCursor_OMPTaskgroupDirective,
                 R"_pb11_weaver(/** OpenMP taskgroup directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPCancellationPointDirective",
                 CXCursorKind::CXCursor_OMPCancellationPointDirective,
                 R"_pb11_weaver(/** OpenMP cancellation point directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPCancelDirective",
                 CXCursorKind::CXCursor_OMPCancelDirective,
                 R"_pb11_weaver(/** OpenMP cancel directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetDataDirective",
                 CXCursorKind::CXCursor_OMPTargetDataDirective,
                 R"_pb11_weaver(/** OpenMP target data directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTaskLoopDirective",
                 CXCursorKind::CXCursor_OMPTaskLoopDirective,
                 R"_pb11_weaver(/** OpenMP taskloop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTaskLoopSimdDirective",
                 CXCursorKind::CXCursor_OMPTaskLoopSimdDirective,
                 R"_pb11_weaver(/** OpenMP taskloop simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPDistributeDirective",
                 CXCursorKind::CXCursor_OMPDistributeDirective,
                 R"_pb11_weaver(/** OpenMP distribute directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetEnterDataDirective",
                 CXCursorKind::CXCursor_OMPTargetEnterDataDirective,
                 R"_pb11_weaver(/** OpenMP target enter data directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetExitDataDirective",
                 CXCursorKind::CXCursor_OMPTargetExitDataDirective,
                 R"_pb11_weaver(/** OpenMP target exit data directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetParallelDirective",
                 CXCursorKind::CXCursor_OMPTargetParallelDirective,
                 R"_pb11_weaver(/** OpenMP target parallel directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetParallelForDirective",
                 CXCursorKind::CXCursor_OMPTargetParallelForDirective,
                 R"_pb11_weaver(/** OpenMP target parallel for directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetUpdateDirective",
                 CXCursorKind::CXCursor_OMPTargetUpdateDirective,
                 R"_pb11_weaver(/** OpenMP target update directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPDistributeParallelForDirective",
                 CXCursorKind::CXCursor_OMPDistributeParallelForDirective,
                 R"_pb11_weaver(/** OpenMP distribute parallel for directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPDistributeParallelForSimdDirective",
        CXCursorKind::CXCursor_OMPDistributeParallelForSimdDirective,
        R"_pb11_weaver(/** OpenMP distribute parallel for simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPDistributeSimdDirective",
                 CXCursorKind::CXCursor_OMPDistributeSimdDirective,
                 R"_pb11_weaver(/** OpenMP distribute simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetParallelForSimdDirective",
                 CXCursorKind::CXCursor_OMPTargetParallelForSimdDirective,
                 R"_pb11_weaver(/** OpenMP target parallel for simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetSimdDirective",
                 CXCursorKind::CXCursor_OMPTargetSimdDirective,
                 R"_pb11_weaver(/** OpenMP target simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTeamsDistributeDirective",
                 CXCursorKind::CXCursor_OMPTeamsDistributeDirective,
                 R"_pb11_weaver(/** OpenMP teams distribute directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTeamsDistributeSimdDirective",
                 CXCursorKind::CXCursor_OMPTeamsDistributeSimdDirective,
                 R"_pb11_weaver(/** OpenMP teams distribute simd directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPTeamsDistributeParallelForSimdDirective",
        CXCursorKind::CXCursor_OMPTeamsDistributeParallelForSimdDirective,
        R"_pb11_weaver(/** OpenMP teams distribute parallel for simd directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPTeamsDistributeParallelForDirective",
        CXCursorKind::CXCursor_OMPTeamsDistributeParallelForDirective,
        R"_pb11_weaver(/** OpenMP teams distribute parallel for directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetTeamsDirective",
                 CXCursorKind::CXCursor_OMPTargetTeamsDirective,
                 R"_pb11_weaver(/** OpenMP target teams directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetTeamsDistributeDirective",
                 CXCursorKind::CXCursor_OMPTargetTeamsDistributeDirective,
                 R"_pb11_weaver(/** OpenMP target teams distribute directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPTargetTeamsDistributeParallelForDirective",
        CXCursorKind::CXCursor_OMPTargetTeamsDistributeParallelForDirective,
        R"_pb11_weaver(/** OpenMP target teams distribute parallel for directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective",
        CXCursorKind::CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective,
        R"_pb11_weaver(/** OpenMP target teams distribute parallel for simd directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPTargetTeamsDistributeSimdDirective",
        CXCursorKind::CXCursor_OMPTargetTeamsDistributeSimdDirective,
        R"_pb11_weaver(/** OpenMP target teams distribute simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_BuiltinBitCastExpr",
                 CXCursorKind::CXCursor_BuiltinBitCastExpr,
                 R"_pb11_weaver(/** C++2a std::bit_cast expression.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPMasterTaskLoopDirective",
                 CXCursorKind::CXCursor_OMPMasterTaskLoopDirective,
                 R"_pb11_weaver(/** OpenMP master taskloop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelMasterTaskLoopDirective",
                 CXCursorKind::CXCursor_OMPParallelMasterTaskLoopDirective,
                 R"_pb11_weaver(/** OpenMP parallel master taskloop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPMasterTaskLoopSimdDirective",
                 CXCursorKind::CXCursor_OMPMasterTaskLoopSimdDirective,
                 R"_pb11_weaver(/** OpenMP master taskloop simd directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPParallelMasterTaskLoopSimdDirective",
        CXCursorKind::CXCursor_OMPParallelMasterTaskLoopSimdDirective,
        R"_pb11_weaver(/** OpenMP parallel master taskloop simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelMasterDirective",
                 CXCursorKind::CXCursor_OMPParallelMasterDirective,
                 R"_pb11_weaver(/** OpenMP parallel master directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPDepobjDirective",
                 CXCursorKind::CXCursor_OMPDepobjDirective,
                 R"_pb11_weaver(/** OpenMP depobj directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPScanDirective",
                 CXCursorKind::CXCursor_OMPScanDirective,
                 R"_pb11_weaver(/** OpenMP scan directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTileDirective",
                 CXCursorKind::CXCursor_OMPTileDirective,
                 R"_pb11_weaver(/** OpenMP tile directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPCanonicalLoop",
                 CXCursorKind::CXCursor_OMPCanonicalLoop,
                 R"_pb11_weaver(/** OpenMP canonical loop.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPInteropDirective",
                 CXCursorKind::CXCursor_OMPInteropDirective,
                 R"_pb11_weaver(/** OpenMP interop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPDispatchDirective",
                 CXCursorKind::CXCursor_OMPDispatchDirective,
                 R"_pb11_weaver(/** OpenMP dispatch directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPMaskedDirective",
                 CXCursorKind::CXCursor_OMPMaskedDirective,
                 R"_pb11_weaver(/** OpenMP masked directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPUnrollDirective",
                 CXCursorKind::CXCursor_OMPUnrollDirective,
                 R"_pb11_weaver(/** OpenMP unroll directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPMetaDirective",
                 CXCursorKind::CXCursor_OMPMetaDirective,
                 R"_pb11_weaver(/** OpenMP metadirective directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPGenericLoopDirective",
                 CXCursorKind::CXCursor_OMPGenericLoopDirective,
                 R"_pb11_weaver(/** OpenMP loop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTeamsGenericLoopDirective",
                 CXCursorKind::CXCursor_OMPTeamsGenericLoopDirective,
                 R"_pb11_weaver(/** OpenMP teams loop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetTeamsGenericLoopDirective",
                 CXCursorKind::CXCursor_OMPTargetTeamsGenericLoopDirective,
                 R"_pb11_weaver(/** OpenMP target teams loop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelGenericLoopDirective",
                 CXCursorKind::CXCursor_OMPParallelGenericLoopDirective,
                 R"_pb11_weaver(/** OpenMP parallel loop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPTargetParallelGenericLoopDirective",
                 CXCursorKind::CXCursor_OMPTargetParallelGenericLoopDirective,
                 R"_pb11_weaver(/** OpenMP target parallel loop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelMaskedDirective",
                 CXCursorKind::CXCursor_OMPParallelMaskedDirective,
                 R"_pb11_weaver(/** OpenMP parallel masked directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPMaskedTaskLoopDirective",
                 CXCursorKind::CXCursor_OMPMaskedTaskLoopDirective,
                 R"_pb11_weaver(/** OpenMP masked taskloop directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPMaskedTaskLoopSimdDirective",
                 CXCursorKind::CXCursor_OMPMaskedTaskLoopSimdDirective,
                 R"_pb11_weaver(/** OpenMP masked taskloop simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPParallelMaskedTaskLoopDirective",
                 CXCursorKind::CXCursor_OMPParallelMaskedTaskLoopDirective,
                 R"_pb11_weaver(/** OpenMP parallel masked taskloop directive.
   */)_pb11_weaver");
    handle.value(
        "CXCursor_OMPParallelMaskedTaskLoopSimdDirective",
        CXCursorKind::CXCursor_OMPParallelMaskedTaskLoopSimdDirective,
        R"_pb11_weaver(/** OpenMP parallel masked taskloop simd directive.
   */)_pb11_weaver");
    handle.value("CXCursor_OMPErrorDirective",
                 CXCursorKind::CXCursor_OMPErrorDirective,
                 R"_pb11_weaver(/** OpenMP error directive.
   */)_pb11_weaver");
    handle.value("CXCursor_LastStmt", CXCursorKind::CXCursor_LastStmt,
                 R"_pb11_weaver(/** OpenMP error directive.
   */)_pb11_weaver");
    handle.value("CXCursor_TranslationUnit",
                 CXCursorKind::CXCursor_TranslationUnit, R"_pb11_weaver(/**
   * Cursor that represents the translation unit itself.
   *
   * The translation unit cursor exists primarily to act as the root
   * cursor for traversing the contents of a translation unit.
   */)_pb11_weaver");
    handle.value("CXCursor_FirstAttr", CXCursorKind::CXCursor_FirstAttr,
                 R"_pb11_weaver(/* Attributes */)_pb11_weaver");
    handle.value("CXCursor_UnexposedAttr", CXCursorKind::CXCursor_UnexposedAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_IBActionAttr", CXCursorKind::CXCursor_IBActionAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_IBOutletAttr", CXCursorKind::CXCursor_IBOutletAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_IBOutletCollectionAttr",
                 CXCursorKind::CXCursor_IBOutletCollectionAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXFinalAttr", CXCursorKind::CXCursor_CXXFinalAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_CXXOverrideAttr",
                 CXCursorKind::CXCursor_CXXOverrideAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_AnnotateAttr", CXCursorKind::CXCursor_AnnotateAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_AsmLabelAttr", CXCursorKind::CXCursor_AsmLabelAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_PackedAttr", CXCursorKind::CXCursor_PackedAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_PureAttr", CXCursorKind::CXCursor_PureAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ConstAttr", CXCursorKind::CXCursor_ConstAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_NoDuplicateAttr",
                 CXCursorKind::CXCursor_NoDuplicateAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_CUDAConstantAttr",
                 CXCursorKind::CXCursor_CUDAConstantAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_CUDADeviceAttr",
                 CXCursorKind::CXCursor_CUDADeviceAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_CUDAGlobalAttr",
                 CXCursorKind::CXCursor_CUDAGlobalAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_CUDAHostAttr", CXCursorKind::CXCursor_CUDAHostAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_CUDASharedAttr",
                 CXCursorKind::CXCursor_CUDASharedAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_VisibilityAttr",
                 CXCursorKind::CXCursor_VisibilityAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_DLLExport", CXCursorKind::CXCursor_DLLExport,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_DLLImport", CXCursorKind::CXCursor_DLLImport,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_NSReturnsRetained",
                 CXCursorKind::CXCursor_NSReturnsRetained, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_NSReturnsNotRetained",
                 CXCursorKind::CXCursor_NSReturnsNotRetained, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_NSReturnsAutoreleased",
                 CXCursorKind::CXCursor_NSReturnsAutoreleased,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_NSConsumesSelf",
                 CXCursorKind::CXCursor_NSConsumesSelf, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_NSConsumed", CXCursorKind::CXCursor_NSConsumed,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCException", CXCursorKind::CXCursor_ObjCException,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCNSObject", CXCursorKind::CXCursor_ObjCNSObject,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCIndependentClass",
                 CXCursorKind::CXCursor_ObjCIndependentClass, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCPreciseLifetime",
                 CXCursorKind::CXCursor_ObjCPreciseLifetime, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCReturnsInnerPointer",
                 CXCursorKind::CXCursor_ObjCReturnsInnerPointer,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCRequiresSuper",
                 CXCursorKind::CXCursor_ObjCRequiresSuper, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCRootClass", CXCursorKind::CXCursor_ObjCRootClass,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCSubclassingRestricted",
                 CXCursorKind::CXCursor_ObjCSubclassingRestricted,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCExplicitProtocolImpl",
                 CXCursorKind::CXCursor_ObjCExplicitProtocolImpl,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCDesignatedInitializer",
                 CXCursorKind::CXCursor_ObjCDesignatedInitializer,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCRuntimeVisible",
                 CXCursorKind::CXCursor_ObjCRuntimeVisible, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ObjCBoxable", CXCursorKind::CXCursor_ObjCBoxable,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_FlagEnum", CXCursorKind::CXCursor_FlagEnum,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_ConvergentAttr",
                 CXCursorKind::CXCursor_ConvergentAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_WarnUnusedAttr",
                 CXCursorKind::CXCursor_WarnUnusedAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_WarnUnusedResultAttr",
                 CXCursorKind::CXCursor_WarnUnusedResultAttr, R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_AlignedAttr", CXCursorKind::CXCursor_AlignedAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_LastAttr", CXCursorKind::CXCursor_LastAttr,
                 R"_pb11_weaver(/**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXCursor_PreprocessingDirective",
                 CXCursorKind::CXCursor_PreprocessingDirective,
                 R"_pb11_weaver(/* Preprocessing */)_pb11_weaver");
    handle.value("CXCursor_MacroDefinition",
                 CXCursorKind::CXCursor_MacroDefinition,
                 R"_pb11_weaver(/* Preprocessing */)_pb11_weaver");
    handle.value("CXCursor_MacroExpansion",
                 CXCursorKind::CXCursor_MacroExpansion,
                 R"_pb11_weaver(/* Preprocessing */)_pb11_weaver");
    handle.value("CXCursor_MacroInstantiation",
                 CXCursorKind::CXCursor_MacroInstantiation,
                 R"_pb11_weaver(/* Preprocessing */)_pb11_weaver");
    handle.value("CXCursor_InclusionDirective",
                 CXCursorKind::CXCursor_InclusionDirective,
                 R"_pb11_weaver(/* Preprocessing */)_pb11_weaver");
    handle.value("CXCursor_FirstPreprocessing",
                 CXCursorKind::CXCursor_FirstPreprocessing,
                 R"_pb11_weaver(/* Preprocessing */)_pb11_weaver");
    handle.value("CXCursor_LastPreprocessing",
                 CXCursorKind::CXCursor_LastPreprocessing,
                 R"_pb11_weaver(/* Preprocessing */)_pb11_weaver");
    handle.value("CXCursor_ModuleImportDecl",
                 CXCursorKind::CXCursor_ModuleImportDecl,
                 R"_pb11_weaver(/* Extra Declarations */
  /**
   * A module import declaration.
   */)_pb11_weaver");
    handle.value("CXCursor_TypeAliasTemplateDecl",
                 CXCursorKind::CXCursor_TypeAliasTemplateDecl,
                 R"_pb11_weaver(/* Extra Declarations */
  /**
   * A module import declaration.
   */)_pb11_weaver");
    handle.value("CXCursor_StaticAssert", CXCursorKind::CXCursor_StaticAssert,
                 R"_pb11_weaver(/**
   * A static_assert or _Static_assert node
   */)_pb11_weaver");
    handle.value("CXCursor_FriendDecl", CXCursorKind::CXCursor_FriendDecl,
                 R"_pb11_weaver(/**
   * a friend declaration.
   */)_pb11_weaver");
    handle.value("CXCursor_ConceptDecl", CXCursorKind::CXCursor_ConceptDecl,
                 R"_pb11_weaver(/**
   * a concept declaration.
   */)_pb11_weaver");
    handle.value("CXCursor_FirstExtraDecl",
                 CXCursorKind::CXCursor_FirstExtraDecl, R"_pb11_weaver(/**
   * a concept declaration.
   */)_pb11_weaver");
    handle.value("CXCursor_LastExtraDecl", CXCursorKind::CXCursor_LastExtraDecl,
                 R"_pb11_weaver(/**
   * a concept declaration.
   */)_pb11_weaver");
    handle.value("CXCursor_OverloadCandidate",
                 CXCursorKind::CXCursor_OverloadCandidate, R"_pb11_weaver(/**
   * A code completion overload candidate.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCursorKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCursorKind

using Entity_CXCursorKind = Bind_CXCursorKind<>;

#else

struct Entity_CXCursorKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCursorKind(EntityScope parent_h) {}
  static const char *Key() { return "CXCursorKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCursorKind

template <class Pybind11T =
              pybind11::enum_<CXCursor_ExceptionSpecificationKind>>
struct Bind_CXCursor_ExceptionSpecificationKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXCursor_ExceptionSpecificationKind(EntityScope parent_h)
      : handle{parent_h, "CXCursor_ExceptionSpecificationKind",
               pybind11::arithmetic(), R"_pb11_weaver(/**
 * Describes the exception specification of a cursor.
 *
 * A negative value indicates that the cursor is not a function declaration.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXCursor_ExceptionSpecificationKind(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXCursor_ExceptionSpecificationKind_None",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_None,
                 R"_pb11_weaver(/**
   * The cursor has no exception specification.
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_DynamicNone",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_DynamicNone,
                 R"_pb11_weaver(/**
   * The cursor has exception specification throw()
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_Dynamic",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_Dynamic,
                 R"_pb11_weaver(/**
   * The cursor has exception specification throw(T1, T2)
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_MSAny",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_MSAny,
                 R"_pb11_weaver(/**
   * The cursor has exception specification throw(...).
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_BasicNoexcept",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_BasicNoexcept,
                 R"_pb11_weaver(/**
   * The cursor has exception specification basic noexcept.
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_ComputedNoexcept",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_ComputedNoexcept,
                 R"_pb11_weaver(/**
   * The cursor has exception specification computed noexcept.
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_Unevaluated",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_Unevaluated,
                 R"_pb11_weaver(/**
   * The exception specification has not yet been evaluated.
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_Uninstantiated",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_Uninstantiated,
                 R"_pb11_weaver(/**
   * The exception specification has not yet been instantiated.
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_Unparsed",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_Unparsed,
                 R"_pb11_weaver(/**
   * The exception specification has not been parsed yet.
   */)_pb11_weaver");
    handle.value("CXCursor_ExceptionSpecificationKind_NoThrow",
                 CXCursor_ExceptionSpecificationKind::
                     CXCursor_ExceptionSpecificationKind_NoThrow,
                 R"_pb11_weaver(/**
   * The cursor has a __declspec(nothrow) exception specification.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXCursor_ExceptionSpecificationKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXCursor_ExceptionSpecificationKind

using Entity_CXCursor_ExceptionSpecificationKind =
    Bind_CXCursor_ExceptionSpecificationKind<>;

#else

struct Entity_CXCursor_ExceptionSpecificationKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXCursor_ExceptionSpecificationKind(EntityScope parent_h) {}
  static const char *Key() { return "CXCursor_ExceptionSpecificationKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXCursor_ExceptionSpecificationKind

template <class Pybind11T = pybind11::enum_<CXDiagnosticDisplayOptions>>
struct Bind_CXDiagnosticDisplayOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXDiagnosticDisplayOptions(EntityScope parent_h)
      : handle{parent_h, "CXDiagnosticDisplayOptions", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Options to control the display of diagnostics.
 *
 * The values in this enum are meant to be combined to customize the
 * behavior of \c clang_formatDiagnostic().
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXDiagnosticDisplayOptions(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXDiagnostic_DisplaySourceLocation",
                 CXDiagnosticDisplayOptions::CXDiagnostic_DisplaySourceLocation,
                 R"_pb11_weaver(/**
   * Display the source-location information where the
   * diagnostic was located.
   *
   * When set, diagnostics will be prefixed by the file, line, and
   * (optionally) column to which the diagnostic refers. For example,
   *
   * \code
   * test.c:28: warning: extra tokens at end of #endif directive
   * \endcode
   *
   * This option corresponds to the clang flag \c -fshow-source-location.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_DisplayColumn",
                 CXDiagnosticDisplayOptions::CXDiagnostic_DisplayColumn,
                 R"_pb11_weaver(/**
   * If displaying the source-location information of the
   * diagnostic, also include the column number.
   *
   * This option corresponds to the clang flag \c -fshow-column.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_DisplaySourceRanges",
                 CXDiagnosticDisplayOptions::CXDiagnostic_DisplaySourceRanges,
                 R"_pb11_weaver(/**
   * If displaying the source-location information of the
   * diagnostic, also include information about source ranges in a
   * machine-parsable format.
   *
   * This option corresponds to the clang flag
   * \c -fdiagnostics-print-source-range-info.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_DisplayOption",
                 CXDiagnosticDisplayOptions::CXDiagnostic_DisplayOption,
                 R"_pb11_weaver(/**
   * Display the option name associated with this diagnostic, if any.
   *
   * The option name displayed (e.g., -Wconversion) will be placed in brackets
   * after the diagnostic text. This option corresponds to the clang flag
   * \c -fdiagnostics-show-option.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_DisplayCategoryId",
                 CXDiagnosticDisplayOptions::CXDiagnostic_DisplayCategoryId,
                 R"_pb11_weaver(/**
   * Display the category number associated with this diagnostic, if any.
   *
   * The category number is displayed within brackets after the diagnostic text.
   * This option corresponds to the clang flag
   * \c -fdiagnostics-show-category=id.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_DisplayCategoryName",
                 CXDiagnosticDisplayOptions::CXDiagnostic_DisplayCategoryName,
                 R"_pb11_weaver(/**
   * Display the category name associated with this diagnostic, if any.
   *
   * The category name is displayed within brackets after the diagnostic text.
   * This option corresponds to the clang flag
   * \c -fdiagnostics-show-category=name.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXDiagnosticDisplayOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXDiagnosticDisplayOptions

using Entity_CXDiagnosticDisplayOptions = Bind_CXDiagnosticDisplayOptions<>;

#else

struct Entity_CXDiagnosticDisplayOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXDiagnosticDisplayOptions(EntityScope parent_h) {}
  static const char *Key() { return "CXDiagnosticDisplayOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXDiagnosticDisplayOptions

template <class Pybind11T = pybind11::enum_<CXDiagnosticSeverity>>
struct Bind_CXDiagnosticSeverity : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXDiagnosticSeverity(EntityScope parent_h)
      : handle{parent_h, "CXDiagnosticSeverity", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the severity of a particular diagnostic.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXDiagnosticSeverity(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXDiagnostic_Ignored",
                 CXDiagnosticSeverity::CXDiagnostic_Ignored, R"_pb11_weaver(/**
   * A diagnostic that has been suppressed, e.g., by a command-line
   * option.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_Note", CXDiagnosticSeverity::CXDiagnostic_Note,
                 R"_pb11_weaver(/**
   * This diagnostic is a note that should be attached to the
   * previous (non-note) diagnostic.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_Warning",
                 CXDiagnosticSeverity::CXDiagnostic_Warning, R"_pb11_weaver(/**
   * This diagnostic indicates suspicious code that may not be
   * wrong.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_Error", CXDiagnosticSeverity::CXDiagnostic_Error,
                 R"_pb11_weaver(/**
   * This diagnostic indicates that the code is ill-formed.
   */)_pb11_weaver");
    handle.value("CXDiagnostic_Fatal", CXDiagnosticSeverity::CXDiagnostic_Fatal,
                 R"_pb11_weaver(/**
   * This diagnostic indicates that the code is ill-formed such
   * that future parser recovery is unlikely to produce useful
   * results.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXDiagnosticSeverity"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXDiagnosticSeverity

using Entity_CXDiagnosticSeverity = Bind_CXDiagnosticSeverity<>;

#else

struct Entity_CXDiagnosticSeverity : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXDiagnosticSeverity(EntityScope parent_h) {}
  static const char *Key() { return "CXDiagnosticSeverity"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXDiagnosticSeverity

template <class Pybind11T = pybind11::enum_<CXErrorCode>>
struct Bind_CXErrorCode : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXErrorCode(EntityScope parent_h)
      : handle{parent_h, "CXErrorCode", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Error codes returned by libclang routines.
 *
 * Zero (\c CXError_Success) is the only error code indicating success.  Other
 * error codes, including not yet assigned non-zero values, indicate errors.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXErrorCode(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXError_Success", CXErrorCode::CXError_Success,
                 R"_pb11_weaver(/**
   * No error.
   */)_pb11_weaver");
    handle.value("CXError_Failure", CXErrorCode::CXError_Failure,
                 R"_pb11_weaver(/**
   * A generic error code, no further details are available.
   *
   * Errors of this kind can get their own specific error codes in future
   * libclang versions.
   */)_pb11_weaver");
    handle.value("CXError_Crashed", CXErrorCode::CXError_Crashed,
                 R"_pb11_weaver(/**
   * libclang crashed while performing the requested operation.
   */)_pb11_weaver");
    handle.value("CXError_InvalidArguments",
                 CXErrorCode::CXError_InvalidArguments, R"_pb11_weaver(/**
   * The function detected that the arguments violate the function
   * contract.
   */)_pb11_weaver");
    handle.value("CXError_ASTReadError", CXErrorCode::CXError_ASTReadError,
                 R"_pb11_weaver(/**
   * An AST deserialization error has occurred.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXErrorCode"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXErrorCode

using Entity_CXErrorCode = Bind_CXErrorCode<>;

#else

struct Entity_CXErrorCode : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXErrorCode(EntityScope parent_h) {}
  static const char *Key() { return "CXErrorCode"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXErrorCode

template <class Pybind11T = pybind11::enum_<CXEvalResultKind>>
struct Bind_CXEvalResultKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXEvalResultKind(EntityScope parent_h)
      : handle{parent_h, "CXEvalResultKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXEvalResultKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXEval_Int", CXEvalResultKind::CXEval_Int);
    handle.value("CXEval_Float", CXEvalResultKind::CXEval_Float);
    handle.value("CXEval_ObjCStrLiteral",
                 CXEvalResultKind::CXEval_ObjCStrLiteral);
    handle.value("CXEval_StrLiteral", CXEvalResultKind::CXEval_StrLiteral);
    handle.value("CXEval_CFStr", CXEvalResultKind::CXEval_CFStr);
    handle.value("CXEval_Other", CXEvalResultKind::CXEval_Other);
    handle.value("CXEval_UnExposed", CXEvalResultKind::CXEval_UnExposed);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXEvalResultKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXEvalResultKind

using Entity_CXEvalResultKind = Bind_CXEvalResultKind<>;

#else

struct Entity_CXEvalResultKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXEvalResultKind(EntityScope parent_h) {}
  static const char *Key() { return "CXEvalResultKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXEvalResultKind

template <class Pybind11T = pybind11::class_<CXFileUniqueID>>
struct Bind_CXFileUniqueID : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXFileUniqueID(EntityScope parent_h)
      : handle{parent_h, "CXFileUniqueID", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Uniquely identifies a CXFile, that refers to the same underlying file,
 * across an indexing session.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXFileUniqueID(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXFileUniqueID>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXFileUniqueID"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXFileUniqueID

using Entity_CXFileUniqueID = Bind_CXFileUniqueID<>;

#else

struct Entity_CXFileUniqueID : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXFileUniqueID(EntityScope parent_h) {}
  static const char *Key() { return "CXFileUniqueID"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXFileUniqueID

template <class Pybind11T = pybind11::enum_<CXGlobalOptFlags>>
struct Bind_CXGlobalOptFlags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXGlobalOptFlags(EntityScope parent_h)
      : handle{parent_h, "CXGlobalOptFlags", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXGlobalOptFlags(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXGlobalOpt_None", CXGlobalOptFlags::CXGlobalOpt_None,
                 R"_pb11_weaver(/**
   * Used to indicate that no special CXIndex options are needed.
   */)_pb11_weaver");
    handle.value(
        "CXGlobalOpt_ThreadBackgroundPriorityForIndexing",
        CXGlobalOptFlags::CXGlobalOpt_ThreadBackgroundPriorityForIndexing,
        R"_pb11_weaver(/**
   * Used to indicate that threads that libclang creates for indexing
   * purposes should use background priority.
   *
   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,
   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.
   */)_pb11_weaver");
    handle.value(
        "CXGlobalOpt_ThreadBackgroundPriorityForEditing",
        CXGlobalOptFlags::CXGlobalOpt_ThreadBackgroundPriorityForEditing,
        R"_pb11_weaver(/**
   * Used to indicate that threads that libclang creates for editing
   * purposes should use background priority.
   *
   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,
   * #clang_annotateTokens
   */)_pb11_weaver");
    handle.value("CXGlobalOpt_ThreadBackgroundPriorityForAll",
                 CXGlobalOptFlags::CXGlobalOpt_ThreadBackgroundPriorityForAll,
                 R"_pb11_weaver(/**
   * Used to indicate that all threads that libclang creates should use
   * background priority.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXGlobalOptFlags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXGlobalOptFlags

using Entity_CXGlobalOptFlags = Bind_CXGlobalOptFlags<>;

#else

struct Entity_CXGlobalOptFlags : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXGlobalOptFlags(EntityScope parent_h) {}
  static const char *Key() { return "CXGlobalOptFlags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXGlobalOptFlags

template <class Pybind11T = pybind11::class_<CXIdxAttrInfo>>
struct Bind_CXIdxAttrInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxAttrInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxAttrInfo", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxAttrInfo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxAttrInfo>(handle);
    handle.def_readwrite("kind", &CXIdxAttrInfo::kind);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxAttrInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxAttrInfo

using Entity_CXIdxAttrInfo = Bind_CXIdxAttrInfo<>;

#else

struct Entity_CXIdxAttrInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxAttrInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxAttrInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxAttrInfo

template <class Pybind11T = pybind11::enum_<CXIdxAttrKind>>
struct Bind_CXIdxAttrKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxAttrKind(EntityScope parent_h)
      : handle{parent_h, "CXIdxAttrKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxAttrKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIdxAttr_Unexposed", CXIdxAttrKind::CXIdxAttr_Unexposed);
    handle.value("CXIdxAttr_IBAction", CXIdxAttrKind::CXIdxAttr_IBAction);
    handle.value("CXIdxAttr_IBOutlet", CXIdxAttrKind::CXIdxAttr_IBOutlet);
    handle.value("CXIdxAttr_IBOutletCollection",
                 CXIdxAttrKind::CXIdxAttr_IBOutletCollection);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxAttrKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxAttrKind

using Entity_CXIdxAttrKind = Bind_CXIdxAttrKind<>;

#else

struct Entity_CXIdxAttrKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxAttrKind(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxAttrKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxAttrKind

template <class Pybind11T = pybind11::class_<CXIdxBaseClassInfo>>
struct Bind_CXIdxBaseClassInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxBaseClassInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxBaseClassInfo", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxBaseClassInfo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxBaseClassInfo>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxBaseClassInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxBaseClassInfo

using Entity_CXIdxBaseClassInfo = Bind_CXIdxBaseClassInfo<>;

#else

struct Entity_CXIdxBaseClassInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxBaseClassInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxBaseClassInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxBaseClassInfo

template <class Pybind11T = pybind11::class_<CXIdxCXXClassDeclInfo>>
struct Bind_CXIdxCXXClassDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxCXXClassDeclInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxCXXClassDeclInfo", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxCXXClassDeclInfo(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxCXXClassDeclInfo>(handle);
    handle.def_readwrite("numBases", &CXIdxCXXClassDeclInfo::numBases);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxCXXClassDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxCXXClassDeclInfo

using Entity_CXIdxCXXClassDeclInfo = Bind_CXIdxCXXClassDeclInfo<>;

#else

struct Entity_CXIdxCXXClassDeclInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxCXXClassDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxCXXClassDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxCXXClassDeclInfo

template <class Pybind11T = pybind11::class_<CXIdxContainerInfo>>
struct Bind_CXIdxContainerInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxContainerInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxContainerInfo", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxContainerInfo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxContainerInfo>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxContainerInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxContainerInfo

using Entity_CXIdxContainerInfo = Bind_CXIdxContainerInfo<>;

#else

struct Entity_CXIdxContainerInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxContainerInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxContainerInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxContainerInfo

template <class Pybind11T = pybind11::class_<CXIdxDeclInfo>>
struct Bind_CXIdxDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxDeclInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxDeclInfo", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxDeclInfo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxDeclInfo>(handle);
    handle.def_readwrite("isRedeclaration", &CXIdxDeclInfo::isRedeclaration);
    handle.def_readwrite("isDefinition", &CXIdxDeclInfo::isDefinition);
    handle.def_readwrite("isContainer", &CXIdxDeclInfo::isContainer);
    handle.def_readwrite("isImplicit", &CXIdxDeclInfo::isImplicit,
                         R"_pb11_weaver(/**
   * Whether the declaration exists in code or was created implicitly
   * by the compiler, e.g. implicit Objective-C methods for properties.
   */)_pb11_weaver");
    handle.def_readwrite("numAttributes", &CXIdxDeclInfo::numAttributes);
    handle.def_readwrite("flags", &CXIdxDeclInfo::flags);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxDeclInfo

using Entity_CXIdxDeclInfo = Bind_CXIdxDeclInfo<>;

#else

struct Entity_CXIdxDeclInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxDeclInfo

template <class Pybind11T = pybind11::enum_<CXIdxDeclInfoFlags>>
struct Bind_CXIdxDeclInfoFlags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxDeclInfoFlags(EntityScope parent_h)
      : handle{parent_h, "CXIdxDeclInfoFlags", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxDeclInfoFlags(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIdxDeclFlag_Skipped",
                 CXIdxDeclInfoFlags::CXIdxDeclFlag_Skipped);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxDeclInfoFlags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxDeclInfoFlags

using Entity_CXIdxDeclInfoFlags = Bind_CXIdxDeclInfoFlags<>;

#else

struct Entity_CXIdxDeclInfoFlags : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxDeclInfoFlags(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxDeclInfoFlags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxDeclInfoFlags

template <class Pybind11T = pybind11::enum_<CXIdxEntityCXXTemplateKind>>
struct Bind_CXIdxEntityCXXTemplateKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxEntityCXXTemplateKind(EntityScope parent_h)
      : handle{parent_h, "CXIdxEntityCXXTemplateKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Extra C++ template information for an entity. This can apply to:
 * CXIdxEntity_Function
 * CXIdxEntity_CXXClass
 * CXIdxEntity_CXXStaticMethod
 * CXIdxEntity_CXXInstanceMethod
 * CXIdxEntity_CXXConstructor
 * CXIdxEntity_CXXConversionFunction
 * CXIdxEntity_CXXTypeAlias
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxEntityCXXTemplateKind(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIdxEntity_NonTemplate",
                 CXIdxEntityCXXTemplateKind::CXIdxEntity_NonTemplate);
    handle.value("CXIdxEntity_Template",
                 CXIdxEntityCXXTemplateKind::CXIdxEntity_Template);
    handle.value(
        "CXIdxEntity_TemplatePartialSpecialization",
        CXIdxEntityCXXTemplateKind::CXIdxEntity_TemplatePartialSpecialization);
    handle.value(
        "CXIdxEntity_TemplateSpecialization",
        CXIdxEntityCXXTemplateKind::CXIdxEntity_TemplateSpecialization);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxEntityCXXTemplateKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxEntityCXXTemplateKind

using Entity_CXIdxEntityCXXTemplateKind = Bind_CXIdxEntityCXXTemplateKind<>;

#else

struct Entity_CXIdxEntityCXXTemplateKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxEntityCXXTemplateKind(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxEntityCXXTemplateKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxEntityCXXTemplateKind

template <class Pybind11T = pybind11::class_<CXIdxEntityInfo>>
struct Bind_CXIdxEntityInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxEntityInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxEntityInfo", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxEntityInfo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxEntityInfo>(handle);
    handle.def_readwrite("kind", &CXIdxEntityInfo::kind);
    handle.def_readwrite("templateKind", &CXIdxEntityInfo::templateKind);
    handle.def_readwrite("lang", &CXIdxEntityInfo::lang);
    handle.def_readwrite("name", &CXIdxEntityInfo::name);
    handle.def_readwrite("USR", &CXIdxEntityInfo::USR);
    handle.def_readwrite("numAttributes", &CXIdxEntityInfo::numAttributes);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxEntityInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxEntityInfo

using Entity_CXIdxEntityInfo = Bind_CXIdxEntityInfo<>;

#else

struct Entity_CXIdxEntityInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxEntityInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxEntityInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxEntityInfo

template <class Pybind11T = pybind11::enum_<CXIdxEntityKind>>
struct Bind_CXIdxEntityKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxEntityKind(EntityScope parent_h)
      : handle{parent_h, "CXIdxEntityKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxEntityKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIdxEntity_Unexposed",
                 CXIdxEntityKind::CXIdxEntity_Unexposed);
    handle.value("CXIdxEntity_Typedef", CXIdxEntityKind::CXIdxEntity_Typedef);
    handle.value("CXIdxEntity_Function", CXIdxEntityKind::CXIdxEntity_Function);
    handle.value("CXIdxEntity_Variable", CXIdxEntityKind::CXIdxEntity_Variable);
    handle.value("CXIdxEntity_Field", CXIdxEntityKind::CXIdxEntity_Field);
    handle.value("CXIdxEntity_EnumConstant",
                 CXIdxEntityKind::CXIdxEntity_EnumConstant);
    handle.value("CXIdxEntity_ObjCClass",
                 CXIdxEntityKind::CXIdxEntity_ObjCClass);
    handle.value("CXIdxEntity_ObjCProtocol",
                 CXIdxEntityKind::CXIdxEntity_ObjCProtocol);
    handle.value("CXIdxEntity_ObjCCategory",
                 CXIdxEntityKind::CXIdxEntity_ObjCCategory);
    handle.value("CXIdxEntity_ObjCInstanceMethod",
                 CXIdxEntityKind::CXIdxEntity_ObjCInstanceMethod);
    handle.value("CXIdxEntity_ObjCClassMethod",
                 CXIdxEntityKind::CXIdxEntity_ObjCClassMethod);
    handle.value("CXIdxEntity_ObjCProperty",
                 CXIdxEntityKind::CXIdxEntity_ObjCProperty);
    handle.value("CXIdxEntity_ObjCIvar", CXIdxEntityKind::CXIdxEntity_ObjCIvar);
    handle.value("CXIdxEntity_Enum", CXIdxEntityKind::CXIdxEntity_Enum);
    handle.value("CXIdxEntity_Struct", CXIdxEntityKind::CXIdxEntity_Struct);
    handle.value("CXIdxEntity_Union", CXIdxEntityKind::CXIdxEntity_Union);
    handle.value("CXIdxEntity_CXXClass", CXIdxEntityKind::CXIdxEntity_CXXClass);
    handle.value("CXIdxEntity_CXXNamespace",
                 CXIdxEntityKind::CXIdxEntity_CXXNamespace);
    handle.value("CXIdxEntity_CXXNamespaceAlias",
                 CXIdxEntityKind::CXIdxEntity_CXXNamespaceAlias);
    handle.value("CXIdxEntity_CXXStaticVariable",
                 CXIdxEntityKind::CXIdxEntity_CXXStaticVariable);
    handle.value("CXIdxEntity_CXXStaticMethod",
                 CXIdxEntityKind::CXIdxEntity_CXXStaticMethod);
    handle.value("CXIdxEntity_CXXInstanceMethod",
                 CXIdxEntityKind::CXIdxEntity_CXXInstanceMethod);
    handle.value("CXIdxEntity_CXXConstructor",
                 CXIdxEntityKind::CXIdxEntity_CXXConstructor);
    handle.value("CXIdxEntity_CXXDestructor",
                 CXIdxEntityKind::CXIdxEntity_CXXDestructor);
    handle.value("CXIdxEntity_CXXConversionFunction",
                 CXIdxEntityKind::CXIdxEntity_CXXConversionFunction);
    handle.value("CXIdxEntity_CXXTypeAlias",
                 CXIdxEntityKind::CXIdxEntity_CXXTypeAlias);
    handle.value("CXIdxEntity_CXXInterface",
                 CXIdxEntityKind::CXIdxEntity_CXXInterface);
    handle.value("CXIdxEntity_CXXConcept",
                 CXIdxEntityKind::CXIdxEntity_CXXConcept);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxEntityKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxEntityKind

using Entity_CXIdxEntityKind = Bind_CXIdxEntityKind<>;

#else

struct Entity_CXIdxEntityKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxEntityKind(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxEntityKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxEntityKind

template <class Pybind11T = pybind11::enum_<CXIdxEntityLanguage>>
struct Bind_CXIdxEntityLanguage : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxEntityLanguage(EntityScope parent_h)
      : handle{parent_h, "CXIdxEntityLanguage", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxEntityLanguage(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIdxEntityLang_None",
                 CXIdxEntityLanguage::CXIdxEntityLang_None);
    handle.value("CXIdxEntityLang_C", CXIdxEntityLanguage::CXIdxEntityLang_C);
    handle.value("CXIdxEntityLang_ObjC",
                 CXIdxEntityLanguage::CXIdxEntityLang_ObjC);
    handle.value("CXIdxEntityLang_CXX",
                 CXIdxEntityLanguage::CXIdxEntityLang_CXX);
    handle.value("CXIdxEntityLang_Swift",
                 CXIdxEntityLanguage::CXIdxEntityLang_Swift);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxEntityLanguage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxEntityLanguage

using Entity_CXIdxEntityLanguage = Bind_CXIdxEntityLanguage<>;

#else

struct Entity_CXIdxEntityLanguage : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxEntityLanguage(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxEntityLanguage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxEntityLanguage

template <class Pybind11T = pybind11::class_<CXIdxEntityRefInfo>>
struct Bind_CXIdxEntityRefInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxEntityRefInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxEntityRefInfo", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Data for IndexerCallbacks#indexEntityReference.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxEntityRefInfo(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxEntityRefInfo>(handle);
    handle.def_readwrite("kind", &CXIdxEntityRefInfo::kind);
    handle.def_readwrite("role", &CXIdxEntityRefInfo::role, R"_pb11_weaver(/**
   * Sets of symbol roles of the reference.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxEntityRefInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxEntityRefInfo

using Entity_CXIdxEntityRefInfo = Bind_CXIdxEntityRefInfo<>;

#else

struct Entity_CXIdxEntityRefInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxEntityRefInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxEntityRefInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxEntityRefInfo

template <class Pybind11T = pybind11::enum_<CXIdxEntityRefKind>>
struct Bind_CXIdxEntityRefKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxEntityRefKind(EntityScope parent_h)
      : handle{parent_h, "CXIdxEntityRefKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Data for IndexerCallbacks#indexEntityReference.
 *
 * This may be deprecated in a future version as this duplicates
 * the \c CXSymbolRole_Implicit bit in \c CXSymbolRole.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxEntityRefKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIdxEntityRef_Direct",
                 CXIdxEntityRefKind::CXIdxEntityRef_Direct, R"_pb11_weaver(/**
   * The entity is referenced directly in user's code.
   */)_pb11_weaver");
    handle.value("CXIdxEntityRef_Implicit",
                 CXIdxEntityRefKind::CXIdxEntityRef_Implicit, R"_pb11_weaver(/**
   * An implicit reference, e.g. a reference of an Objective-C method
   * via the dot syntax.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxEntityRefKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxEntityRefKind

using Entity_CXIdxEntityRefKind = Bind_CXIdxEntityRefKind<>;

#else

struct Entity_CXIdxEntityRefKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxEntityRefKind(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxEntityRefKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxEntityRefKind

template <class Pybind11T = pybind11::class_<CXIdxIBOutletCollectionAttrInfo>>
struct Bind_CXIdxIBOutletCollectionAttrInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxIBOutletCollectionAttrInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxIBOutletCollectionAttrInfo",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxIBOutletCollectionAttrInfo(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxIBOutletCollectionAttrInfo>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxIBOutletCollectionAttrInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxIBOutletCollectionAttrInfo

using Entity_CXIdxIBOutletCollectionAttrInfo =
    Bind_CXIdxIBOutletCollectionAttrInfo<>;

#else

struct Entity_CXIdxIBOutletCollectionAttrInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxIBOutletCollectionAttrInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxIBOutletCollectionAttrInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxIBOutletCollectionAttrInfo

template <class Pybind11T = pybind11::class_<CXIdxImportedASTFileInfo>>
struct Bind_CXIdxImportedASTFileInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxImportedASTFileInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxImportedASTFileInfo", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Data for IndexerCallbacks#importedASTFile.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxImportedASTFileInfo(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxImportedASTFileInfo>(handle);
    handle.def_readwrite("isImplicit", &CXIdxImportedASTFileInfo::isImplicit,
                         R"_pb11_weaver(/**
   * Non-zero if an inclusion directive was automatically turned into
   * a module import. Applicable only for modules.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxImportedASTFileInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxImportedASTFileInfo

using Entity_CXIdxImportedASTFileInfo = Bind_CXIdxImportedASTFileInfo<>;

#else

struct Entity_CXIdxImportedASTFileInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxImportedASTFileInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxImportedASTFileInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxImportedASTFileInfo

template <class Pybind11T = pybind11::class_<CXIdxIncludedFileInfo>>
struct Bind_CXIdxIncludedFileInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxIncludedFileInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxIncludedFileInfo", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Data for ppIncludedFile callback.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxIncludedFileInfo(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxIncludedFileInfo>(handle);
    handle.def_readwrite("filename", &CXIdxIncludedFileInfo::filename,
                         R"_pb11_weaver(/**
   * Filename as written in the \#include/\#import directive.
   */)_pb11_weaver");
    handle.def_readwrite("isImport", &CXIdxIncludedFileInfo::isImport);
    handle.def_readwrite("isAngled", &CXIdxIncludedFileInfo::isAngled);
    handle.def_readwrite("isModuleImport",
                         &CXIdxIncludedFileInfo::isModuleImport,
                         R"_pb11_weaver(/**
   * Non-zero if the directive was automatically turned into a module
   * import.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxIncludedFileInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxIncludedFileInfo

using Entity_CXIdxIncludedFileInfo = Bind_CXIdxIncludedFileInfo<>;

#else

struct Entity_CXIdxIncludedFileInfo : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxIncludedFileInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxIncludedFileInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxIncludedFileInfo

template <class Pybind11T = pybind11::class_<CXIdxLoc>>
struct Bind_CXIdxLoc : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxLoc(EntityScope parent_h)
      : handle{parent_h, "CXIdxLoc", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Source location passed to index callbacks.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxLoc(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxLoc>(handle);
    handle.def_readwrite("int_data", &CXIdxLoc::int_data);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxLoc"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxLoc

using Entity_CXIdxLoc = Bind_CXIdxLoc<>;

#else

struct Entity_CXIdxLoc : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxLoc(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxLoc"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxLoc

template <class Pybind11T = pybind11::class_<CXIdxObjCCategoryDeclInfo>>
struct Bind_CXIdxObjCCategoryDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxObjCCategoryDeclInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxObjCCategoryDeclInfo",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxObjCCategoryDeclInfo(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxObjCCategoryDeclInfo>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxObjCCategoryDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxObjCCategoryDeclInfo

using Entity_CXIdxObjCCategoryDeclInfo = Bind_CXIdxObjCCategoryDeclInfo<>;

#else

struct Entity_CXIdxObjCCategoryDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxObjCCategoryDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxObjCCategoryDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxObjCCategoryDeclInfo

template <class Pybind11T = pybind11::class_<CXIdxObjCContainerDeclInfo>>
struct Bind_CXIdxObjCContainerDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxObjCContainerDeclInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxObjCContainerDeclInfo",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxObjCContainerDeclInfo(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxObjCContainerDeclInfo>(handle);
    handle.def_readwrite("kind", &CXIdxObjCContainerDeclInfo::kind);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxObjCContainerDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxObjCContainerDeclInfo

using Entity_CXIdxObjCContainerDeclInfo = Bind_CXIdxObjCContainerDeclInfo<>;

#else

struct Entity_CXIdxObjCContainerDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxObjCContainerDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxObjCContainerDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxObjCContainerDeclInfo

template <class Pybind11T = pybind11::enum_<CXIdxObjCContainerKind>>
struct Bind_CXIdxObjCContainerKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxObjCContainerKind(EntityScope parent_h)
      : handle{parent_h, "CXIdxObjCContainerKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxObjCContainerKind(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIdxObjCContainer_ForwardRef",
                 CXIdxObjCContainerKind::CXIdxObjCContainer_ForwardRef);
    handle.value("CXIdxObjCContainer_Interface",
                 CXIdxObjCContainerKind::CXIdxObjCContainer_Interface);
    handle.value("CXIdxObjCContainer_Implementation",
                 CXIdxObjCContainerKind::CXIdxObjCContainer_Implementation);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxObjCContainerKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxObjCContainerKind

using Entity_CXIdxObjCContainerKind = Bind_CXIdxObjCContainerKind<>;

#else

struct Entity_CXIdxObjCContainerKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxObjCContainerKind(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxObjCContainerKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxObjCContainerKind

template <class Pybind11T = pybind11::class_<CXIdxObjCInterfaceDeclInfo>>
struct Bind_CXIdxObjCInterfaceDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxObjCInterfaceDeclInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxObjCInterfaceDeclInfo",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxObjCInterfaceDeclInfo(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxObjCInterfaceDeclInfo>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxObjCInterfaceDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxObjCInterfaceDeclInfo

using Entity_CXIdxObjCInterfaceDeclInfo = Bind_CXIdxObjCInterfaceDeclInfo<>;

#else

struct Entity_CXIdxObjCInterfaceDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxObjCInterfaceDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxObjCInterfaceDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxObjCInterfaceDeclInfo

template <class Pybind11T = pybind11::class_<CXIdxObjCPropertyDeclInfo>>
struct Bind_CXIdxObjCPropertyDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxObjCPropertyDeclInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxObjCPropertyDeclInfo",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxObjCPropertyDeclInfo(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxObjCPropertyDeclInfo>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxObjCPropertyDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxObjCPropertyDeclInfo

using Entity_CXIdxObjCPropertyDeclInfo = Bind_CXIdxObjCPropertyDeclInfo<>;

#else

struct Entity_CXIdxObjCPropertyDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxObjCPropertyDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxObjCPropertyDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxObjCPropertyDeclInfo

template <class Pybind11T = pybind11::class_<CXIdxObjCProtocolRefInfo>>
struct Bind_CXIdxObjCProtocolRefInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxObjCProtocolRefInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxObjCProtocolRefInfo", pybind11::dynamic_attr()} {
  }

  template <class... HandleArgsT>
  explicit Bind_CXIdxObjCProtocolRefInfo(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxObjCProtocolRefInfo>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxObjCProtocolRefInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxObjCProtocolRefInfo

using Entity_CXIdxObjCProtocolRefInfo = Bind_CXIdxObjCProtocolRefInfo<>;

#else

struct Entity_CXIdxObjCProtocolRefInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxObjCProtocolRefInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxObjCProtocolRefInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxObjCProtocolRefInfo

template <class Pybind11T = pybind11::class_<CXIdxObjCProtocolRefListInfo>>
struct Bind_CXIdxObjCProtocolRefListInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIdxObjCProtocolRefListInfo(EntityScope parent_h)
      : handle{parent_h, "CXIdxObjCProtocolRefListInfo",
               pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIdxObjCProtocolRefListInfo(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXIdxObjCProtocolRefListInfo>(handle);
    handle.def_readwrite("numProtocols",
                         &CXIdxObjCProtocolRefListInfo::numProtocols);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIdxObjCProtocolRefListInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIdxObjCProtocolRefListInfo

using Entity_CXIdxObjCProtocolRefListInfo = Bind_CXIdxObjCProtocolRefListInfo<>;

#else

struct Entity_CXIdxObjCProtocolRefListInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIdxObjCProtocolRefListInfo(EntityScope parent_h) {}
  static const char *Key() { return "CXIdxObjCProtocolRefListInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIdxObjCProtocolRefListInfo

template <class Pybind11T = pybind11::enum_<CXIndexOptFlags>>
struct Bind_CXIndexOptFlags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXIndexOptFlags(EntityScope parent_h)
      : handle{parent_h, "CXIndexOptFlags", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXIndexOptFlags(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXIndexOpt_None", CXIndexOptFlags::CXIndexOpt_None,
                 R"_pb11_weaver(/**
   * Used to indicate that no special indexing options are needed.
   */)_pb11_weaver");
    handle.value("CXIndexOpt_SuppressRedundantRefs",
                 CXIndexOptFlags::CXIndexOpt_SuppressRedundantRefs,
                 R"_pb11_weaver(/**
   * Used to indicate that IndexerCallbacks#indexEntityReference should
   * be invoked for only one reference of an entity per source file that does
   * not also include a declaration/definition of the entity.
   */)_pb11_weaver");
    handle.value("CXIndexOpt_IndexFunctionLocalSymbols",
                 CXIndexOptFlags::CXIndexOpt_IndexFunctionLocalSymbols,
                 R"_pb11_weaver(/**
   * Function-local symbols should be indexed. If this is not set
   * function-local symbols will be ignored.
   */)_pb11_weaver");
    handle.value(
        "CXIndexOpt_IndexImplicitTemplateInstantiations",
        CXIndexOptFlags::CXIndexOpt_IndexImplicitTemplateInstantiations,
        R"_pb11_weaver(/**
   * Implicit function/class template instantiations should be indexed.
   * If this is not set, implicit instantiations will be ignored.
   */)_pb11_weaver");
    handle.value("CXIndexOpt_SuppressWarnings",
                 CXIndexOptFlags::CXIndexOpt_SuppressWarnings,
                 R"_pb11_weaver(/**
   * Suppress all compiler warnings when parsing for indexing.
   */)_pb11_weaver");
    handle.value("CXIndexOpt_SkipParsedBodiesInSession",
                 CXIndexOptFlags::CXIndexOpt_SkipParsedBodiesInSession,
                 R"_pb11_weaver(/**
   * Skip a function/method body that was already parsed during an
   * indexing session associated with a \c CXIndexAction object.
   * Bodies in system headers are always skipped.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXIndexOptFlags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXIndexOptFlags

using Entity_CXIndexOptFlags = Bind_CXIndexOptFlags<>;

#else

struct Entity_CXIndexOptFlags : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXIndexOptFlags(EntityScope parent_h) {}
  static const char *Key() { return "CXIndexOptFlags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXIndexOptFlags

template <class Pybind11T = pybind11::enum_<CXLanguageKind>>
struct Bind_CXLanguageKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXLanguageKind(EntityScope parent_h)
      : handle{parent_h, "CXLanguageKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describe the "language" of the entity referred to by a cursor.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXLanguageKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXLanguage_Invalid", CXLanguageKind::CXLanguage_Invalid);
    handle.value("CXLanguage_C", CXLanguageKind::CXLanguage_C);
    handle.value("CXLanguage_ObjC", CXLanguageKind::CXLanguage_ObjC);
    handle.value("CXLanguage_CPlusPlus", CXLanguageKind::CXLanguage_CPlusPlus);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXLanguageKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXLanguageKind

using Entity_CXLanguageKind = Bind_CXLanguageKind<>;

#else

struct Entity_CXLanguageKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXLanguageKind(EntityScope parent_h) {}
  static const char *Key() { return "CXLanguageKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXLanguageKind

template <class Pybind11T = pybind11::enum_<CXLinkageKind>>
struct Bind_CXLinkageKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXLinkageKind(EntityScope parent_h)
      : handle{parent_h, "CXLinkageKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describe the linkage of the entity referred to by a cursor.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXLinkageKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "CXLinkage_Invalid", CXLinkageKind::CXLinkage_Invalid,
        R"_pb11_weaver(/** This value indicates that no linkage information is available
   * for a provided CXCursor. */)_pb11_weaver");
    handle.value("CXLinkage_NoLinkage", CXLinkageKind::CXLinkage_NoLinkage,
                 R"_pb11_weaver(/**
   * This is the linkage for variables, parameters, and so on that
   *  have automatic storage.  This covers normal (non-extern) local variables.
   */)_pb11_weaver");
    handle.value(
        "CXLinkage_Internal", CXLinkageKind::CXLinkage_Internal,
        R"_pb11_weaver(/** This is the linkage for static variables and static functions. */)_pb11_weaver");
    handle.value(
        "CXLinkage_UniqueExternal", CXLinkageKind::CXLinkage_UniqueExternal,
        R"_pb11_weaver(/** This is the linkage for entities with external linkage that live
   * in C++ anonymous namespaces.*/)_pb11_weaver");
    handle.value(
        "CXLinkage_External", CXLinkageKind::CXLinkage_External,
        R"_pb11_weaver(/** This is the linkage for entities with true, external linkage. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXLinkageKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXLinkageKind

using Entity_CXLinkageKind = Bind_CXLinkageKind<>;

#else

struct Entity_CXLinkageKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXLinkageKind(EntityScope parent_h) {}
  static const char *Key() { return "CXLinkageKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXLinkageKind

template <class Pybind11T = pybind11::enum_<CXLoadDiag_Error>>
struct Bind_CXLoadDiag_Error : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXLoadDiag_Error(EntityScope parent_h)
      : handle{parent_h, "CXLoadDiag_Error", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the kind of error that occurred (if any) in a call to
 * \c clang_loadDiagnostics.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXLoadDiag_Error(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXLoadDiag_None", CXLoadDiag_Error::CXLoadDiag_None,
                 R"_pb11_weaver(/**
   * Indicates that no error occurred.
   */)_pb11_weaver");
    handle.value("CXLoadDiag_Unknown", CXLoadDiag_Error::CXLoadDiag_Unknown,
                 R"_pb11_weaver(/**
   * Indicates that an unknown error occurred while attempting to
   * deserialize diagnostics.
   */)_pb11_weaver");
    handle.value("CXLoadDiag_CannotLoad",
                 CXLoadDiag_Error::CXLoadDiag_CannotLoad, R"_pb11_weaver(/**
   * Indicates that the file containing the serialized diagnostics
   * could not be opened.
   */)_pb11_weaver");
    handle.value("CXLoadDiag_InvalidFile",
                 CXLoadDiag_Error::CXLoadDiag_InvalidFile, R"_pb11_weaver(/**
   * Indicates that the serialized diagnostics file is invalid or
   * corrupt.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXLoadDiag_Error"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXLoadDiag_Error

using Entity_CXLoadDiag_Error = Bind_CXLoadDiag_Error<>;

#else

struct Entity_CXLoadDiag_Error : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXLoadDiag_Error(EntityScope parent_h) {}
  static const char *Key() { return "CXLoadDiag_Error"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXLoadDiag_Error

template <class Pybind11T = pybind11::enum_<CXNameRefFlags>>
struct Bind_CXNameRefFlags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXNameRefFlags(EntityScope parent_h)
      : handle{parent_h, "CXNameRefFlags", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXNameRefFlags(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXNameRange_WantQualifier",
                 CXNameRefFlags::CXNameRange_WantQualifier, R"_pb11_weaver(/**
   * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the
   * range.
   */)_pb11_weaver");
    handle.value("CXNameRange_WantTemplateArgs",
                 CXNameRefFlags::CXNameRange_WantTemplateArgs,
                 R"_pb11_weaver(/**
   * Include the explicit template arguments, e.g. \<int> in x.f<int>,
   * in the range.
   */)_pb11_weaver");
    handle.value("CXNameRange_WantSinglePiece",
                 CXNameRefFlags::CXNameRange_WantSinglePiece, R"_pb11_weaver(/**
   * If the name is non-contiguous, return the full spanning range.
   *
   * Non-contiguous names occur in Objective-C when a selector with two or more
   * parameters is used, or in C++ when using an operator:
   * \code
   * [object doSomething:here withValue:there]; // Objective-C
   * return some_vector[1]; // C++
   * \endcode
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXNameRefFlags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXNameRefFlags

using Entity_CXNameRefFlags = Bind_CXNameRefFlags<>;

#else

struct Entity_CXNameRefFlags : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXNameRefFlags(EntityScope parent_h) {}
  static const char *Key() { return "CXNameRefFlags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXNameRefFlags

template <class Pybind11T = pybind11::enum_<CXObjCDeclQualifierKind>>
struct Bind_CXObjCDeclQualifierKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXObjCDeclQualifierKind(EntityScope parent_h)
      : handle{parent_h, "CXObjCDeclQualifierKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * 'Qualifiers' written next to the return and parameter types in
 * Objective-C method declarations.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXObjCDeclQualifierKind(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXObjCDeclQualifier_None",
                 CXObjCDeclQualifierKind::CXObjCDeclQualifier_None);
    handle.value("CXObjCDeclQualifier_In",
                 CXObjCDeclQualifierKind::CXObjCDeclQualifier_In);
    handle.value("CXObjCDeclQualifier_Inout",
                 CXObjCDeclQualifierKind::CXObjCDeclQualifier_Inout);
    handle.value("CXObjCDeclQualifier_Out",
                 CXObjCDeclQualifierKind::CXObjCDeclQualifier_Out);
    handle.value("CXObjCDeclQualifier_Bycopy",
                 CXObjCDeclQualifierKind::CXObjCDeclQualifier_Bycopy);
    handle.value("CXObjCDeclQualifier_Byref",
                 CXObjCDeclQualifierKind::CXObjCDeclQualifier_Byref);
    handle.value("CXObjCDeclQualifier_Oneway",
                 CXObjCDeclQualifierKind::CXObjCDeclQualifier_Oneway);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXObjCDeclQualifierKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXObjCDeclQualifierKind

using Entity_CXObjCDeclQualifierKind = Bind_CXObjCDeclQualifierKind<>;

#else

struct Entity_CXObjCDeclQualifierKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXObjCDeclQualifierKind(EntityScope parent_h) {}
  static const char *Key() { return "CXObjCDeclQualifierKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXObjCDeclQualifierKind

template <class Pybind11T = pybind11::enum_<CXObjCPropertyAttrKind>>
struct Bind_CXObjCPropertyAttrKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXObjCPropertyAttrKind(EntityScope parent_h)
      : handle{parent_h, "CXObjCPropertyAttrKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Property attributes for a \c CXCursor_ObjCPropertyDecl.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXObjCPropertyAttrKind(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXObjCPropertyAttr_noattr",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_noattr);
    handle.value("CXObjCPropertyAttr_readonly",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_readonly);
    handle.value("CXObjCPropertyAttr_getter",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_getter);
    handle.value("CXObjCPropertyAttr_assign",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_assign);
    handle.value("CXObjCPropertyAttr_readwrite",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_readwrite);
    handle.value("CXObjCPropertyAttr_retain",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_retain);
    handle.value("CXObjCPropertyAttr_copy",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_copy);
    handle.value("CXObjCPropertyAttr_nonatomic",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_nonatomic);
    handle.value("CXObjCPropertyAttr_setter",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_setter);
    handle.value("CXObjCPropertyAttr_atomic",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_atomic);
    handle.value("CXObjCPropertyAttr_weak",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_weak);
    handle.value("CXObjCPropertyAttr_strong",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_strong);
    handle.value("CXObjCPropertyAttr_unsafe_unretained",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_unsafe_unretained);
    handle.value("CXObjCPropertyAttr_class",
                 CXObjCPropertyAttrKind::CXObjCPropertyAttr_class);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXObjCPropertyAttrKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXObjCPropertyAttrKind

using Entity_CXObjCPropertyAttrKind = Bind_CXObjCPropertyAttrKind<>;

#else

struct Entity_CXObjCPropertyAttrKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXObjCPropertyAttrKind(EntityScope parent_h) {}
  static const char *Key() { return "CXObjCPropertyAttrKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXObjCPropertyAttrKind

template <class Pybind11T = pybind11::class_<CXPlatformAvailability>>
struct Bind_CXPlatformAvailability : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXPlatformAvailability(EntityScope parent_h)
      : handle{parent_h, "CXPlatformAvailability", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Describes the availability of a given entity on a particular platform, e.g.,
 * a particular class might only be available on Mac OS 10.7 or newer.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXPlatformAvailability(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXPlatformAvailability>(handle);
    handle.def_readwrite("Unavailable", &CXPlatformAvailability::Unavailable,
                         R"_pb11_weaver(/**
   * Whether the entity is unconditionally unavailable on this platform.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXPlatformAvailability"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXPlatformAvailability

using Entity_CXPlatformAvailability = Bind_CXPlatformAvailability<>;

#else

struct Entity_CXPlatformAvailability : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXPlatformAvailability(EntityScope parent_h) {}
  static const char *Key() { return "CXPlatformAvailability"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXPlatformAvailability

template <class Pybind11T = pybind11::enum_<CXPrintingPolicyProperty>>
struct Bind_CXPrintingPolicyProperty : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXPrintingPolicyProperty(EntityScope parent_h)
      : handle{parent_h, "CXPrintingPolicyProperty", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Properties for the printing policy.
 *
 * See \c clang::PrintingPolicy for more information.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXPrintingPolicyProperty(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXPrintingPolicy_Indentation",
                 CXPrintingPolicyProperty::CXPrintingPolicy_Indentation);
    handle.value("CXPrintingPolicy_SuppressSpecifiers",
                 CXPrintingPolicyProperty::CXPrintingPolicy_SuppressSpecifiers);
    handle.value("CXPrintingPolicy_SuppressTagKeyword",
                 CXPrintingPolicyProperty::CXPrintingPolicy_SuppressTagKeyword);
    handle.value(
        "CXPrintingPolicy_IncludeTagDefinition",
        CXPrintingPolicyProperty::CXPrintingPolicy_IncludeTagDefinition);
    handle.value("CXPrintingPolicy_SuppressScope",
                 CXPrintingPolicyProperty::CXPrintingPolicy_SuppressScope);
    handle.value(
        "CXPrintingPolicy_SuppressUnwrittenScope",
        CXPrintingPolicyProperty::CXPrintingPolicy_SuppressUnwrittenScope);
    handle.value(
        "CXPrintingPolicy_SuppressInitializers",
        CXPrintingPolicyProperty::CXPrintingPolicy_SuppressInitializers);
    handle.value(
        "CXPrintingPolicy_ConstantArraySizeAsWritten",
        CXPrintingPolicyProperty::CXPrintingPolicy_ConstantArraySizeAsWritten);
    handle.value(
        "CXPrintingPolicy_AnonymousTagLocations",
        CXPrintingPolicyProperty::CXPrintingPolicy_AnonymousTagLocations);
    handle.value(
        "CXPrintingPolicy_SuppressStrongLifetime",
        CXPrintingPolicyProperty::CXPrintingPolicy_SuppressStrongLifetime);
    handle.value(
        "CXPrintingPolicy_SuppressLifetimeQualifiers",
        CXPrintingPolicyProperty::CXPrintingPolicy_SuppressLifetimeQualifiers);
    handle.value("CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors",
                 CXPrintingPolicyProperty::
                     CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors);
    handle.value("CXPrintingPolicy_Bool",
                 CXPrintingPolicyProperty::CXPrintingPolicy_Bool);
    handle.value("CXPrintingPolicy_Restrict",
                 CXPrintingPolicyProperty::CXPrintingPolicy_Restrict);
    handle.value("CXPrintingPolicy_Alignof",
                 CXPrintingPolicyProperty::CXPrintingPolicy_Alignof);
    handle.value("CXPrintingPolicy_UnderscoreAlignof",
                 CXPrintingPolicyProperty::CXPrintingPolicy_UnderscoreAlignof);
    handle.value(
        "CXPrintingPolicy_UseVoidForZeroParams",
        CXPrintingPolicyProperty::CXPrintingPolicy_UseVoidForZeroParams);
    handle.value("CXPrintingPolicy_TerseOutput",
                 CXPrintingPolicyProperty::CXPrintingPolicy_TerseOutput);
    handle.value(
        "CXPrintingPolicy_PolishForDeclaration",
        CXPrintingPolicyProperty::CXPrintingPolicy_PolishForDeclaration);
    handle.value("CXPrintingPolicy_Half",
                 CXPrintingPolicyProperty::CXPrintingPolicy_Half);
    handle.value("CXPrintingPolicy_MSWChar",
                 CXPrintingPolicyProperty::CXPrintingPolicy_MSWChar);
    handle.value("CXPrintingPolicy_IncludeNewlines",
                 CXPrintingPolicyProperty::CXPrintingPolicy_IncludeNewlines);
    handle.value("CXPrintingPolicy_MSVCFormatting",
                 CXPrintingPolicyProperty::CXPrintingPolicy_MSVCFormatting);
    handle.value("CXPrintingPolicy_ConstantsAsWritten",
                 CXPrintingPolicyProperty::CXPrintingPolicy_ConstantsAsWritten);
    handle.value(
        "CXPrintingPolicy_SuppressImplicitBase",
        CXPrintingPolicyProperty::CXPrintingPolicy_SuppressImplicitBase);
    handle.value("CXPrintingPolicy_FullyQualifiedName",
                 CXPrintingPolicyProperty::CXPrintingPolicy_FullyQualifiedName);
    handle.value("CXPrintingPolicy_LastProperty",
                 CXPrintingPolicyProperty::CXPrintingPolicy_LastProperty);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXPrintingPolicyProperty"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXPrintingPolicyProperty

using Entity_CXPrintingPolicyProperty = Bind_CXPrintingPolicyProperty<>;

#else

struct Entity_CXPrintingPolicyProperty
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXPrintingPolicyProperty(EntityScope parent_h) {}
  static const char *Key() { return "CXPrintingPolicyProperty"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXPrintingPolicyProperty

template <class Pybind11T = pybind11::enum_<CXRefQualifierKind>>
struct Bind_CXRefQualifierKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXRefQualifierKind(EntityScope parent_h)
      : handle{parent_h, "CXRefQualifierKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXRefQualifierKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "CXRefQualifier_None", CXRefQualifierKind::CXRefQualifier_None,
        R"_pb11_weaver(/** No ref-qualifier was provided. */)_pb11_weaver");
    handle.value(
        "CXRefQualifier_LValue", CXRefQualifierKind::CXRefQualifier_LValue,
        R"_pb11_weaver(/** An lvalue ref-qualifier was provided (\c &). */)_pb11_weaver");
    handle.value(
        "CXRefQualifier_RValue", CXRefQualifierKind::CXRefQualifier_RValue,
        R"_pb11_weaver(/** An rvalue ref-qualifier was provided (\c &&). */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXRefQualifierKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXRefQualifierKind

using Entity_CXRefQualifierKind = Bind_CXRefQualifierKind<>;

#else

struct Entity_CXRefQualifierKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXRefQualifierKind(EntityScope parent_h) {}
  static const char *Key() { return "CXRefQualifierKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXRefQualifierKind

template <class Pybind11T = pybind11::enum_<CXReparse_Flags>>
struct Bind_CXReparse_Flags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXReparse_Flags(EntityScope parent_h)
      : handle{parent_h, "CXReparse_Flags", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Flags that control the reparsing of translation units.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * reparsing the translation unit.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXReparse_Flags(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXReparse_None", CXReparse_Flags::CXReparse_None,
                 R"_pb11_weaver(/**
   * Used to indicate that no special reparsing options are needed.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXReparse_Flags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXReparse_Flags

using Entity_CXReparse_Flags = Bind_CXReparse_Flags<>;

#else

struct Entity_CXReparse_Flags : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXReparse_Flags(EntityScope parent_h) {}
  static const char *Key() { return "CXReparse_Flags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXReparse_Flags

template <class Pybind11T = pybind11::enum_<CXResult>>
struct Bind_CXResult : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXResult(EntityScope parent_h)
      : handle{parent_h, "CXResult", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXResult(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXResult_Success", CXResult::CXResult_Success,
                 R"_pb11_weaver(/**
   * Function returned successfully.
   */)_pb11_weaver");
    handle.value("CXResult_Invalid", CXResult::CXResult_Invalid,
                 R"_pb11_weaver(/**
   * One of the parameters was invalid for the function.
   */)_pb11_weaver");
    handle.value("CXResult_VisitBreak", CXResult::CXResult_VisitBreak,
                 R"_pb11_weaver(/**
   * The function was terminated by a callback (e.g. it returned
   * CXVisit_Break)
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXResult"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXResult

using Entity_CXResult = Bind_CXResult<>;

#else

struct Entity_CXResult : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXResult(EntityScope parent_h) {}
  static const char *Key() { return "CXResult"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXResult

template <class Pybind11T = pybind11::enum_<CXSaveError>>
struct Bind_CXSaveError : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXSaveError(EntityScope parent_h)
      : handle{parent_h, "CXSaveError", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the kind of error that occurred (if any) in a call to
 * \c clang_saveTranslationUnit().
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXSaveError(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXSaveError_None", CXSaveError::CXSaveError_None,
                 R"_pb11_weaver(/**
   * Indicates that no error occurred while saving a translation unit.
   */)_pb11_weaver");
    handle.value("CXSaveError_Unknown", CXSaveError::CXSaveError_Unknown,
                 R"_pb11_weaver(/**
   * Indicates that an unknown error occurred while attempting to save
   * the file.
   *
   * This error typically indicates that file I/O failed when attempting to
   * write the file.
   */)_pb11_weaver");
    handle.value("CXSaveError_TranslationErrors",
                 CXSaveError::CXSaveError_TranslationErrors, R"_pb11_weaver(/**
   * Indicates that errors during translation prevented this attempt
   * to save the translation unit.
   *
   * Errors that prevent the translation unit from being saved can be
   * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().
   */)_pb11_weaver");
    handle.value("CXSaveError_InvalidTU", CXSaveError::CXSaveError_InvalidTU,
                 R"_pb11_weaver(/**
   * Indicates that the translation unit to be saved was somehow
   * invalid (e.g., NULL).
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXSaveError"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXSaveError

using Entity_CXSaveError = Bind_CXSaveError<>;

#else

struct Entity_CXSaveError : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXSaveError(EntityScope parent_h) {}
  static const char *Key() { return "CXSaveError"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXSaveError

template <class Pybind11T = pybind11::enum_<CXSaveTranslationUnit_Flags>>
struct Bind_CXSaveTranslationUnit_Flags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXSaveTranslationUnit_Flags(EntityScope parent_h)
      : handle{parent_h, "CXSaveTranslationUnit_Flags", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Flags that control how translation units are saved.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * saving the translation unit.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXSaveTranslationUnit_Flags(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXSaveTranslationUnit_None",
                 CXSaveTranslationUnit_Flags::CXSaveTranslationUnit_None,
                 R"_pb11_weaver(/**
   * Used to indicate that no special saving options are needed.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXSaveTranslationUnit_Flags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXSaveTranslationUnit_Flags

using Entity_CXSaveTranslationUnit_Flags = Bind_CXSaveTranslationUnit_Flags<>;

#else

struct Entity_CXSaveTranslationUnit_Flags
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXSaveTranslationUnit_Flags(EntityScope parent_h) {}
  static const char *Key() { return "CXSaveTranslationUnit_Flags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXSaveTranslationUnit_Flags

template <class Pybind11T = pybind11::class_<CXSourceLocation>>
struct Bind_CXSourceLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXSourceLocation(EntityScope parent_h)
      : handle{parent_h, "CXSourceLocation", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Identifies a specific source location within a translation
 * unit.
 *
 * Use clang_getExpansionLocation() or clang_getSpellingLocation()
 * to map a source location to a particular file, line, and column.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXSourceLocation(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXSourceLocation>(handle);
    handle.def_readwrite("int_data", &CXSourceLocation::int_data);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXSourceLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXSourceLocation

using Entity_CXSourceLocation = Bind_CXSourceLocation<>;

#else

struct Entity_CXSourceLocation : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXSourceLocation(EntityScope parent_h) {}
  static const char *Key() { return "CXSourceLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXSourceLocation

template <class Pybind11T = pybind11::class_<CXSourceRange>>
struct Bind_CXSourceRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXSourceRange(EntityScope parent_h)
      : handle{parent_h, "CXSourceRange", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Identifies a half-open character range in the source code.
 *
 * Use clang_getRangeStart() and clang_getRangeEnd() to retrieve the
 * starting and end locations from a source range, respectively.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXSourceRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXSourceRange>(handle);
    handle.def_readwrite("begin_int_data", &CXSourceRange::begin_int_data);
    handle.def_readwrite("end_int_data", &CXSourceRange::end_int_data);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXSourceRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXSourceRange

using Entity_CXSourceRange = Bind_CXSourceRange<>;

#else

struct Entity_CXSourceRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXSourceRange(EntityScope parent_h) {}
  static const char *Key() { return "CXSourceRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXSourceRange

template <class Pybind11T = pybind11::class_<CXSourceRangeList>>
struct Bind_CXSourceRangeList : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXSourceRangeList(EntityScope parent_h)
      : handle{parent_h, "CXSourceRangeList", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Identifies an array of ranges.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXSourceRangeList(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXSourceRangeList>(handle);
    handle.def_readwrite(
        "count", &CXSourceRangeList::count,
        R"_pb11_weaver(/** The number of ranges in the \c ranges array. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXSourceRangeList"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXSourceRangeList

using Entity_CXSourceRangeList = Bind_CXSourceRangeList<>;

#else

struct Entity_CXSourceRangeList : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXSourceRangeList(EntityScope parent_h) {}
  static const char *Key() { return "CXSourceRangeList"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXSourceRangeList

template <class Pybind11T = pybind11::class_<CXString>>
struct Bind_CXString : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXString(EntityScope parent_h)
      : handle{parent_h, "CXString", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * A character string.
 *
 * The \c CXString type is used to return strings from the interface when
 * the ownership of that string might differ from one call to the next.
 * Use \c clang_getCString() to retrieve the string data and, once finished
 * with the string data, call \c clang_disposeString() to free the string.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXString(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXString>(handle);
    handle.def_readwrite("private_flags", &CXString::private_flags);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXString"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXString

using Entity_CXString = Bind_CXString<>;

#else

struct Entity_CXString : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXString(EntityScope parent_h) {}
  static const char *Key() { return "CXString"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXString

template <class Pybind11T = pybind11::class_<CXStringSet>>
struct Bind_CXStringSet : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXStringSet(EntityScope parent_h)
      : handle{parent_h, "CXStringSet", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXStringSet(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXStringSet>(handle);
    handle.def_readwrite("Count", &CXStringSet::Count);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXStringSet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXStringSet

using Entity_CXStringSet = Bind_CXStringSet<>;

#else

struct Entity_CXStringSet : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXStringSet(EntityScope parent_h) {}
  static const char *Key() { return "CXStringSet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXStringSet

template <class Pybind11T = pybind11::enum_<CXSymbolRole>>
struct Bind_CXSymbolRole : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXSymbolRole(EntityScope parent_h)
      : handle{parent_h, "CXSymbolRole", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Roles that are attributed to symbol occurrences.
 *
 * Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with
 * higher bits zeroed. These high bits may be exposed in the future.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXSymbolRole(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXSymbolRole_None", CXSymbolRole::CXSymbolRole_None);
    handle.value("CXSymbolRole_Declaration",
                 CXSymbolRole::CXSymbolRole_Declaration);
    handle.value("CXSymbolRole_Definition",
                 CXSymbolRole::CXSymbolRole_Definition);
    handle.value("CXSymbolRole_Reference",
                 CXSymbolRole::CXSymbolRole_Reference);
    handle.value("CXSymbolRole_Read", CXSymbolRole::CXSymbolRole_Read);
    handle.value("CXSymbolRole_Write", CXSymbolRole::CXSymbolRole_Write);
    handle.value("CXSymbolRole_Call", CXSymbolRole::CXSymbolRole_Call);
    handle.value("CXSymbolRole_Dynamic", CXSymbolRole::CXSymbolRole_Dynamic);
    handle.value("CXSymbolRole_AddressOf",
                 CXSymbolRole::CXSymbolRole_AddressOf);
    handle.value("CXSymbolRole_Implicit", CXSymbolRole::CXSymbolRole_Implicit);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXSymbolRole"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXSymbolRole

using Entity_CXSymbolRole = Bind_CXSymbolRole<>;

#else

struct Entity_CXSymbolRole : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXSymbolRole(EntityScope parent_h) {}
  static const char *Key() { return "CXSymbolRole"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXSymbolRole

template <class Pybind11T = pybind11::enum_<CXTLSKind>>
struct Bind_CXTLSKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTLSKind(EntityScope parent_h)
      : handle{parent_h, "CXTLSKind", pybind11::arithmetic(), R"_pb11_weaver(/**
 * Describe the "thread-local storage (TLS) kind" of the declaration
 * referred to by a cursor.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTLSKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXTLS_None", CXTLSKind::CXTLS_None);
    handle.value("CXTLS_Dynamic", CXTLSKind::CXTLS_Dynamic);
    handle.value("CXTLS_Static", CXTLSKind::CXTLS_Static);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTLSKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTLSKind

using Entity_CXTLSKind = Bind_CXTLSKind<>;

#else

struct Entity_CXTLSKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTLSKind(EntityScope parent_h) {}
  static const char *Key() { return "CXTLSKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTLSKind

template <class Pybind11T = pybind11::class_<CXTUResourceUsage>>
struct Bind_CXTUResourceUsage : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTUResourceUsage(EntityScope parent_h)
      : handle{parent_h, "CXTUResourceUsage", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * The memory usage of a CXTranslationUnit, broken into categories.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTUResourceUsage(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXTUResourceUsage>(handle);
    handle.def_readwrite(
        "numEntries", &CXTUResourceUsage::numEntries,
        R"_pb11_weaver(/* The number of entries in the 'entries' array. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTUResourceUsage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTUResourceUsage

using Entity_CXTUResourceUsage = Bind_CXTUResourceUsage<>;

#else

struct Entity_CXTUResourceUsage : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTUResourceUsage(EntityScope parent_h) {}
  static const char *Key() { return "CXTUResourceUsage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTUResourceUsage

template <class Pybind11T = pybind11::class_<CXTUResourceUsageEntry>>
struct Bind_CXTUResourceUsageEntry : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTUResourceUsageEntry(EntityScope parent_h)
      : handle{parent_h, "CXTUResourceUsageEntry", pybind11::dynamic_attr()} {}

  template <class... HandleArgsT>
  explicit Bind_CXTUResourceUsageEntry(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXTUResourceUsageEntry>(handle);
    handle.def_readwrite(
        "kind", &CXTUResourceUsageEntry::kind,
        R"_pb11_weaver(/* The memory usage category. */)_pb11_weaver");
    handle.def_readwrite("amount", &CXTUResourceUsageEntry::amount,
                         R"_pb11_weaver(/* Amount of resources used.
      The units will depend on the resource kind. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTUResourceUsageEntry"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTUResourceUsageEntry

using Entity_CXTUResourceUsageEntry = Bind_CXTUResourceUsageEntry<>;

#else

struct Entity_CXTUResourceUsageEntry : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTUResourceUsageEntry(EntityScope parent_h) {}
  static const char *Key() { return "CXTUResourceUsageEntry"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTUResourceUsageEntry

template <class Pybind11T = pybind11::enum_<CXTUResourceUsageKind>>
struct Bind_CXTUResourceUsageKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTUResourceUsageKind(EntityScope parent_h)
      : handle{parent_h, "CXTUResourceUsageKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Categorizes how memory is being used by a translation unit.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTUResourceUsageKind(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXTUResourceUsage_AST",
                 CXTUResourceUsageKind::CXTUResourceUsage_AST);
    handle.value("CXTUResourceUsage_Identifiers",
                 CXTUResourceUsageKind::CXTUResourceUsage_Identifiers);
    handle.value("CXTUResourceUsage_Selectors",
                 CXTUResourceUsageKind::CXTUResourceUsage_Selectors);
    handle.value(
        "CXTUResourceUsage_GlobalCompletionResults",
        CXTUResourceUsageKind::CXTUResourceUsage_GlobalCompletionResults);
    handle.value(
        "CXTUResourceUsage_SourceManagerContentCache",
        CXTUResourceUsageKind::CXTUResourceUsage_SourceManagerContentCache);
    handle.value("CXTUResourceUsage_AST_SideTables",
                 CXTUResourceUsageKind::CXTUResourceUsage_AST_SideTables);
    handle.value("CXTUResourceUsage_SourceManager_Membuffer_Malloc",
                 CXTUResourceUsageKind::
                     CXTUResourceUsage_SourceManager_Membuffer_Malloc);
    handle.value(
        "CXTUResourceUsage_SourceManager_Membuffer_MMap",
        CXTUResourceUsageKind::CXTUResourceUsage_SourceManager_Membuffer_MMap);
    handle.value("CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc",
                 CXTUResourceUsageKind::
                     CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc);
    handle.value("CXTUResourceUsage_ExternalASTSource_Membuffer_MMap",
                 CXTUResourceUsageKind::
                     CXTUResourceUsage_ExternalASTSource_Membuffer_MMap);
    handle.value("CXTUResourceUsage_Preprocessor",
                 CXTUResourceUsageKind::CXTUResourceUsage_Preprocessor);
    handle.value("CXTUResourceUsage_PreprocessingRecord",
                 CXTUResourceUsageKind::CXTUResourceUsage_PreprocessingRecord);
    handle.value(
        "CXTUResourceUsage_SourceManager_DataStructures",
        CXTUResourceUsageKind::CXTUResourceUsage_SourceManager_DataStructures);
    handle.value(
        "CXTUResourceUsage_Preprocessor_HeaderSearch",
        CXTUResourceUsageKind::CXTUResourceUsage_Preprocessor_HeaderSearch);
    handle.value(
        "CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN",
        CXTUResourceUsageKind::CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN);
    handle.value("CXTUResourceUsage_MEMORY_IN_BYTES_END",
                 CXTUResourceUsageKind::CXTUResourceUsage_MEMORY_IN_BYTES_END);
    handle.value("CXTUResourceUsage_First",
                 CXTUResourceUsageKind::CXTUResourceUsage_First);
    handle.value("CXTUResourceUsage_Last",
                 CXTUResourceUsageKind::CXTUResourceUsage_Last);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTUResourceUsageKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTUResourceUsageKind

using Entity_CXTUResourceUsageKind = Bind_CXTUResourceUsageKind<>;

#else

struct Entity_CXTUResourceUsageKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTUResourceUsageKind(EntityScope parent_h) {}
  static const char *Key() { return "CXTUResourceUsageKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTUResourceUsageKind

template <class Pybind11T = pybind11::enum_<CXTemplateArgumentKind>>
struct Bind_CXTemplateArgumentKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTemplateArgumentKind(EntityScope parent_h)
      : handle{parent_h, "CXTemplateArgumentKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the kind of a template argument.
 *
 * See the definition of llvm::clang::TemplateArgument::ArgKind for full
 * element descriptions.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTemplateArgumentKind(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXTemplateArgumentKind_Null",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_Null);
    handle.value("CXTemplateArgumentKind_Type",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_Type);
    handle.value("CXTemplateArgumentKind_Declaration",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_Declaration);
    handle.value("CXTemplateArgumentKind_NullPtr",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_NullPtr);
    handle.value("CXTemplateArgumentKind_Integral",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_Integral);
    handle.value("CXTemplateArgumentKind_Template",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_Template);
    handle.value(
        "CXTemplateArgumentKind_TemplateExpansion",
        CXTemplateArgumentKind::CXTemplateArgumentKind_TemplateExpansion);
    handle.value("CXTemplateArgumentKind_Expression",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_Expression);
    handle.value("CXTemplateArgumentKind_Pack",
                 CXTemplateArgumentKind::CXTemplateArgumentKind_Pack);
    handle.value(
        "CXTemplateArgumentKind_Invalid",
        CXTemplateArgumentKind::CXTemplateArgumentKind_Invalid,
        R"_pb11_weaver(/* Indicates an error case, preventing the kind from being deduced. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTemplateArgumentKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTemplateArgumentKind

using Entity_CXTemplateArgumentKind = Bind_CXTemplateArgumentKind<>;

#else

struct Entity_CXTemplateArgumentKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTemplateArgumentKind(EntityScope parent_h) {}
  static const char *Key() { return "CXTemplateArgumentKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTemplateArgumentKind

template <class Pybind11T = pybind11::class_<CXToken>>
struct Bind_CXToken : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXToken(EntityScope parent_h)
      : handle{parent_h, "CXToken", pybind11::dynamic_attr(), R"_pb11_weaver(/**
 * Describes a single preprocessing token.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXToken(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXToken>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXToken"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXToken

using Entity_CXToken = Bind_CXToken<>;

#else

struct Entity_CXToken : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXToken(EntityScope parent_h) {}
  static const char *Key() { return "CXToken"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXToken

template <class Pybind11T = pybind11::enum_<CXTokenKind>>
struct Bind_CXTokenKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTokenKind(EntityScope parent_h)
      : handle{parent_h, "CXTokenKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes a kind of token.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTokenKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXToken_Punctuation", CXTokenKind::CXToken_Punctuation,
                 R"_pb11_weaver(/**
   * A token that contains some kind of punctuation.
   */)_pb11_weaver");
    handle.value("CXToken_Keyword", CXTokenKind::CXToken_Keyword,
                 R"_pb11_weaver(/**
   * A language keyword.
   */)_pb11_weaver");
    handle.value("CXToken_Identifier", CXTokenKind::CXToken_Identifier,
                 R"_pb11_weaver(/**
   * An identifier (that is not a keyword).
   */)_pb11_weaver");
    handle.value("CXToken_Literal", CXTokenKind::CXToken_Literal,
                 R"_pb11_weaver(/**
   * A numeric, string, or character literal.
   */)_pb11_weaver");
    handle.value("CXToken_Comment", CXTokenKind::CXToken_Comment,
                 R"_pb11_weaver(/**
   * A comment.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTokenKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTokenKind

using Entity_CXTokenKind = Bind_CXTokenKind<>;

#else

struct Entity_CXTokenKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTokenKind(EntityScope parent_h) {}
  static const char *Key() { return "CXTokenKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTokenKind

template <class Pybind11T = pybind11::enum_<CXTranslationUnit_Flags>>
struct Bind_CXTranslationUnit_Flags : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTranslationUnit_Flags(EntityScope parent_h)
      : handle{parent_h, "CXTranslationUnit_Flags", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Flags that control the creation of translation units.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * constructing the translation unit.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTranslationUnit_Flags(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXTranslationUnit_None",
                 CXTranslationUnit_Flags::CXTranslationUnit_None,
                 R"_pb11_weaver(/**
   * Used to indicate that no special translation-unit options are
   * needed.
   */)_pb11_weaver");
    handle.value(
        "CXTranslationUnit_DetailedPreprocessingRecord",
        CXTranslationUnit_Flags::CXTranslationUnit_DetailedPreprocessingRecord,
        R"_pb11_weaver(/**
   * Used to indicate that the parser should construct a "detailed"
   * preprocessing record, including all macro definitions and instantiations.
   *
   * Constructing a detailed preprocessing record requires more memory
   * and time to parse, since the information contained in the record
   * is usually not retained. However, it can be useful for
   * applications that require more detailed information about the
   * behavior of the preprocessor.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_Incomplete",
                 CXTranslationUnit_Flags::CXTranslationUnit_Incomplete,
                 R"_pb11_weaver(/**
   * Used to indicate that the translation unit is incomplete.
   *
   * When a translation unit is considered "incomplete", semantic
   * analysis that is typically performed at the end of the
   * translation unit will be suppressed. For example, this suppresses
   * the completion of tentative declarations in C and of
   * instantiation of implicitly-instantiation function templates in
   * C++. This option is typically used when parsing a header with the
   * intent of producing a precompiled header.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_PrecompiledPreamble",
                 CXTranslationUnit_Flags::CXTranslationUnit_PrecompiledPreamble,
                 R"_pb11_weaver(/**
   * Used to indicate that the translation unit should be built with an
   * implicit precompiled header for the preamble.
   *
   * An implicit precompiled header is used as an optimization when a
   * particular translation unit is likely to be reparsed many times
   * when the sources aren't changing that often. In this case, an
   * implicit precompiled header will be built containing all of the
   * initial includes at the top of the main file (what we refer to as
   * the "preamble" of the file). In subsequent parses, if the
   * preamble or the files in it have not changed, \c
   * clang_reparseTranslationUnit() will re-use the implicit
   * precompiled header to improve parsing performance.
   */)_pb11_weaver");
    handle.value(
        "CXTranslationUnit_CacheCompletionResults",
        CXTranslationUnit_Flags::CXTranslationUnit_CacheCompletionResults,
        R"_pb11_weaver(/**
   * Used to indicate that the translation unit should cache some
   * code-completion results with each reparse of the source file.
   *
   * Caching of code-completion results is a performance optimization that
   * introduces some overhead to reparsing but improves the performance of
   * code-completion operations.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_ForSerialization",
                 CXTranslationUnit_Flags::CXTranslationUnit_ForSerialization,
                 R"_pb11_weaver(/**
   * Used to indicate that the translation unit will be serialized with
   * \c clang_saveTranslationUnit.
   *
   * This option is typically used when parsing a header with the intent of
   * producing a precompiled header.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_CXXChainedPCH",
                 CXTranslationUnit_Flags::CXTranslationUnit_CXXChainedPCH,
                 R"_pb11_weaver(/**
   * DEPRECATED: Enabled chained precompiled preambles in C++.
   *
   * Note: this is a *temporary* option that is available only while
   * we are testing C++ precompiled preamble support. It is deprecated.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_SkipFunctionBodies",
                 CXTranslationUnit_Flags::CXTranslationUnit_SkipFunctionBodies,
                 R"_pb11_weaver(/**
   * Used to indicate that function/method bodies should be skipped while
   * parsing.
   *
   * This option can be used to search for declarations/definitions while
   * ignoring the usages.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_IncludeBriefCommentsInCodeCompletion",
                 CXTranslationUnit_Flags::
                     CXTranslationUnit_IncludeBriefCommentsInCodeCompletion,
                 R"_pb11_weaver(/**
   * Used to indicate that brief documentation comments should be
   * included into the set of code completions returned from this translation
   * unit.
   */)_pb11_weaver");
    handle.value(
        "CXTranslationUnit_CreatePreambleOnFirstParse",
        CXTranslationUnit_Flags::CXTranslationUnit_CreatePreambleOnFirstParse,
        R"_pb11_weaver(/**
   * Used to indicate that the precompiled preamble should be created on
   * the first parse. Otherwise it will be created on the first reparse. This
   * trades runtime on the first parse (serializing the preamble takes time) for
   * reduced runtime on the second parse (can now reuse the preamble).
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_KeepGoing",
                 CXTranslationUnit_Flags::CXTranslationUnit_KeepGoing,
                 R"_pb11_weaver(/**
   * Do not stop processing when fatal errors are encountered.
   *
   * When fatal errors are encountered while parsing a translation unit,
   * semantic analysis is typically stopped early when compiling code. A common
   * source for fatal errors are unresolvable include files. For the
   * purposes of an IDE, this is undesirable behavior and as much information
   * as possible should be reported. Use this flag to enable this behavior.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_SingleFileParse",
                 CXTranslationUnit_Flags::CXTranslationUnit_SingleFileParse,
                 R"_pb11_weaver(/**
   * Sets the preprocessor in a mode for parsing a single file only.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_LimitSkipFunctionBodiesToPreamble",
                 CXTranslationUnit_Flags::
                     CXTranslationUnit_LimitSkipFunctionBodiesToPreamble,
                 R"_pb11_weaver(/**
   * Used in combination with CXTranslationUnit_SkipFunctionBodies to
   * constrain the skipping of function bodies to the preamble.
   *
   * The function bodies of the main file are not skipped.
   */)_pb11_weaver");
    handle.value(
        "CXTranslationUnit_IncludeAttributedTypes",
        CXTranslationUnit_Flags::CXTranslationUnit_IncludeAttributedTypes,
        R"_pb11_weaver(/**
   * Used to indicate that attributed types should be included in CXType.
   */)_pb11_weaver");
    handle.value(
        "CXTranslationUnit_VisitImplicitAttributes",
        CXTranslationUnit_Flags::CXTranslationUnit_VisitImplicitAttributes,
        R"_pb11_weaver(/**
   * Used to indicate that implicit attributes should be visited.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles",
                 CXTranslationUnit_Flags::
                     CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles,
                 R"_pb11_weaver(/**
   * Used to indicate that non-errors from included files should be ignored.
   *
   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from
   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for
   * the case where these warnings are not of interest, as for an IDE for
   * example, which typically shows only the diagnostics in the main file.
   */)_pb11_weaver");
    handle.value("CXTranslationUnit_RetainExcludedConditionalBlocks",
                 CXTranslationUnit_Flags::
                     CXTranslationUnit_RetainExcludedConditionalBlocks,
                 R"_pb11_weaver(/**
   * Tells the preprocessor not to skip excluded conditional blocks.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTranslationUnit_Flags"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTranslationUnit_Flags

using Entity_CXTranslationUnit_Flags = Bind_CXTranslationUnit_Flags<>;

#else

struct Entity_CXTranslationUnit_Flags : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTranslationUnit_Flags(EntityScope parent_h) {}
  static const char *Key() { return "CXTranslationUnit_Flags"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTranslationUnit_Flags

template <class Pybind11T = pybind11::class_<CXType>>
struct Bind_CXType : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXType(EntityScope parent_h)
      : handle{parent_h, "CXType", pybind11::dynamic_attr(), R"_pb11_weaver(/**
 * The type of an element in the abstract syntax tree.
 *
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXType(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXType>(handle);
    handle.def_readwrite("kind", &CXType::kind);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXType

using Entity_CXType = Bind_CXType<>;

#else

struct Entity_CXType : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXType(EntityScope parent_h) {}
  static const char *Key() { return "CXType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXType

template <class Pybind11T = pybind11::enum_<CXTypeKind>>
struct Bind_CXTypeKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTypeKind(EntityScope parent_h)
      : handle{parent_h, "CXTypeKind", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Describes the kind of type
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTypeKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXType_Invalid", CXTypeKind::CXType_Invalid,
                 R"_pb11_weaver(/**
   * Represents an invalid type (e.g., where no type is available).
   */)_pb11_weaver");
    handle.value("CXType_Unexposed", CXTypeKind::CXType_Unexposed,
                 R"_pb11_weaver(/**
   * A type whose specific kind is not exposed via this
   * interface.
   */)_pb11_weaver");
    handle.value("CXType_Void", CXTypeKind::CXType_Void,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Bool", CXTypeKind::CXType_Bool,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Char_U", CXTypeKind::CXType_Char_U,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_UChar", CXTypeKind::CXType_UChar,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Char16", CXTypeKind::CXType_Char16,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Char32", CXTypeKind::CXType_Char32,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_UShort", CXTypeKind::CXType_UShort,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_UInt", CXTypeKind::CXType_UInt,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ULong", CXTypeKind::CXType_ULong,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ULongLong", CXTypeKind::CXType_ULongLong,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_UInt128", CXTypeKind::CXType_UInt128,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Char_S", CXTypeKind::CXType_Char_S,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_SChar", CXTypeKind::CXType_SChar,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_WChar", CXTypeKind::CXType_WChar,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Short", CXTypeKind::CXType_Short,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Int", CXTypeKind::CXType_Int,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Long", CXTypeKind::CXType_Long,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_LongLong", CXTypeKind::CXType_LongLong,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Int128", CXTypeKind::CXType_Int128,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Float", CXTypeKind::CXType_Float,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Double", CXTypeKind::CXType_Double,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_LongDouble", CXTypeKind::CXType_LongDouble,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_NullPtr", CXTypeKind::CXType_NullPtr,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Overload", CXTypeKind::CXType_Overload,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Dependent", CXTypeKind::CXType_Dependent,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ObjCId", CXTypeKind::CXType_ObjCId,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ObjCClass", CXTypeKind::CXType_ObjCClass,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ObjCSel", CXTypeKind::CXType_ObjCSel,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Float128", CXTypeKind::CXType_Float128,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Half", CXTypeKind::CXType_Half,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Float16", CXTypeKind::CXType_Float16,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ShortAccum", CXTypeKind::CXType_ShortAccum,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Accum", CXTypeKind::CXType_Accum,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_LongAccum", CXTypeKind::CXType_LongAccum,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_UShortAccum", CXTypeKind::CXType_UShortAccum,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_UAccum", CXTypeKind::CXType_UAccum,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ULongAccum", CXTypeKind::CXType_ULongAccum,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_BFloat16", CXTypeKind::CXType_BFloat16,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Ibm128", CXTypeKind::CXType_Ibm128,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_FirstBuiltin", CXTypeKind::CXType_FirstBuiltin,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_LastBuiltin", CXTypeKind::CXType_LastBuiltin,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Complex", CXTypeKind::CXType_Complex,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Pointer", CXTypeKind::CXType_Pointer,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_BlockPointer", CXTypeKind::CXType_BlockPointer,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_LValueReference", CXTypeKind::CXType_LValueReference,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_RValueReference", CXTypeKind::CXType_RValueReference,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Record", CXTypeKind::CXType_Record,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Enum", CXTypeKind::CXType_Enum,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Typedef", CXTypeKind::CXType_Typedef,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ObjCInterface", CXTypeKind::CXType_ObjCInterface,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ObjCObjectPointer",
                 CXTypeKind::CXType_ObjCObjectPointer,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_FunctionNoProto", CXTypeKind::CXType_FunctionNoProto,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_FunctionProto", CXTypeKind::CXType_FunctionProto,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_ConstantArray", CXTypeKind::CXType_ConstantArray,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Vector", CXTypeKind::CXType_Vector,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_IncompleteArray", CXTypeKind::CXType_IncompleteArray,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_VariableArray", CXTypeKind::CXType_VariableArray,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_DependentSizedArray",
                 CXTypeKind::CXType_DependentSizedArray,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_MemberPointer", CXTypeKind::CXType_MemberPointer,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Auto", CXTypeKind::CXType_Auto,
                 R"_pb11_weaver(/* Builtin types */)_pb11_weaver");
    handle.value("CXType_Elaborated", CXTypeKind::CXType_Elaborated,
                 R"_pb11_weaver(/**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */)_pb11_weaver");
    handle.value("CXType_Pipe", CXTypeKind::CXType_Pipe,
                 R"_pb11_weaver(/* OpenCL PipeType. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dRO", CXTypeKind::CXType_OCLImage1dRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dArrayRO",
                 CXTypeKind::CXType_OCLImage1dArrayRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dBufferRO",
                 CXTypeKind::CXType_OCLImage1dBufferRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dRO", CXTypeKind::CXType_OCLImage2dRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayRO",
                 CXTypeKind::CXType_OCLImage2dArrayRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dDepthRO",
                 CXTypeKind::CXType_OCLImage2dDepthRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayDepthRO",
                 CXTypeKind::CXType_OCLImage2dArrayDepthRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dMSAARO", CXTypeKind::CXType_OCLImage2dMSAARO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayMSAARO",
                 CXTypeKind::CXType_OCLImage2dArrayMSAARO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dMSAADepthRO",
                 CXTypeKind::CXType_OCLImage2dMSAADepthRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayMSAADepthRO",
                 CXTypeKind::CXType_OCLImage2dArrayMSAADepthRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage3dRO", CXTypeKind::CXType_OCLImage3dRO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dWO", CXTypeKind::CXType_OCLImage1dWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dArrayWO",
                 CXTypeKind::CXType_OCLImage1dArrayWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dBufferWO",
                 CXTypeKind::CXType_OCLImage1dBufferWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dWO", CXTypeKind::CXType_OCLImage2dWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayWO",
                 CXTypeKind::CXType_OCLImage2dArrayWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dDepthWO",
                 CXTypeKind::CXType_OCLImage2dDepthWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayDepthWO",
                 CXTypeKind::CXType_OCLImage2dArrayDepthWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dMSAAWO", CXTypeKind::CXType_OCLImage2dMSAAWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayMSAAWO",
                 CXTypeKind::CXType_OCLImage2dArrayMSAAWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dMSAADepthWO",
                 CXTypeKind::CXType_OCLImage2dMSAADepthWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayMSAADepthWO",
                 CXTypeKind::CXType_OCLImage2dArrayMSAADepthWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage3dWO", CXTypeKind::CXType_OCLImage3dWO,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dRW", CXTypeKind::CXType_OCLImage1dRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dArrayRW",
                 CXTypeKind::CXType_OCLImage1dArrayRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage1dBufferRW",
                 CXTypeKind::CXType_OCLImage1dBufferRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dRW", CXTypeKind::CXType_OCLImage2dRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayRW",
                 CXTypeKind::CXType_OCLImage2dArrayRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dDepthRW",
                 CXTypeKind::CXType_OCLImage2dDepthRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayDepthRW",
                 CXTypeKind::CXType_OCLImage2dArrayDepthRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dMSAARW", CXTypeKind::CXType_OCLImage2dMSAARW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayMSAARW",
                 CXTypeKind::CXType_OCLImage2dArrayMSAARW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dMSAADepthRW",
                 CXTypeKind::CXType_OCLImage2dMSAADepthRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage2dArrayMSAADepthRW",
                 CXTypeKind::CXType_OCLImage2dArrayMSAADepthRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLImage3dRW", CXTypeKind::CXType_OCLImage3dRW,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLSampler", CXTypeKind::CXType_OCLSampler,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLEvent", CXTypeKind::CXType_OCLEvent,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLQueue", CXTypeKind::CXType_OCLQueue,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLReserveID", CXTypeKind::CXType_OCLReserveID,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_ObjCObject", CXTypeKind::CXType_ObjCObject,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_ObjCTypeParam", CXTypeKind::CXType_ObjCTypeParam,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_Attributed", CXTypeKind::CXType_Attributed,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCMcePayload",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCMcePayload,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCImePayload",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCImePayload,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCRefPayload",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCRefPayload,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCSicPayload",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCSicPayload,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCMceResult",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCMceResult,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCImeResult",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCImeResult,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCRefResult",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCRefResult,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCSicResult",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCSicResult,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value(
        "CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout",
        CXTypeKind::CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout,
        R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value(
        "CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout",
        CXTypeKind::CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout,
        R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCImeSingleRefStreamin",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCImeSingleRefStreamin,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_OCLIntelSubgroupAVCImeDualRefStreamin",
                 CXTypeKind::CXType_OCLIntelSubgroupAVCImeDualRefStreamin,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_ExtVector", CXTypeKind::CXType_ExtVector,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_Atomic", CXTypeKind::CXType_Atomic,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
    handle.value("CXType_BTFTagAttributed", CXTypeKind::CXType_BTFTagAttributed,
                 R"_pb11_weaver(/* OpenCL builtin types. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTypeKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTypeKind

using Entity_CXTypeKind = Bind_CXTypeKind<>;

#else

struct Entity_CXTypeKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTypeKind(EntityScope parent_h) {}
  static const char *Key() { return "CXTypeKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTypeKind

template <class Pybind11T = pybind11::enum_<CXTypeLayoutError>>
struct Bind_CXTypeLayoutError : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTypeLayoutError(EntityScope parent_h)
      : handle{parent_h, "CXTypeLayoutError", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * List the possible error codes for \c clang_Type_getSizeOf,
 *   \c clang_Type_getAlignOf, \c clang_Type_getOffsetOf and
 *   \c clang_Cursor_getOffsetOf.
 *
 * A value of this enumeration type can be returned if the target type is not
 * a valid argument to sizeof, alignof or offsetof.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXTypeLayoutError(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXTypeLayoutError_Invalid",
                 CXTypeLayoutError::CXTypeLayoutError_Invalid,
                 R"_pb11_weaver(/**
   * Type is of kind CXType_Invalid.
   */)_pb11_weaver");
    handle.value("CXTypeLayoutError_Incomplete",
                 CXTypeLayoutError::CXTypeLayoutError_Incomplete,
                 R"_pb11_weaver(/**
   * The type is an incomplete Type.
   */)_pb11_weaver");
    handle.value("CXTypeLayoutError_Dependent",
                 CXTypeLayoutError::CXTypeLayoutError_Dependent,
                 R"_pb11_weaver(/**
   * The type is a dependent Type.
   */)_pb11_weaver");
    handle.value("CXTypeLayoutError_NotConstantSize",
                 CXTypeLayoutError::CXTypeLayoutError_NotConstantSize,
                 R"_pb11_weaver(/**
   * The type is not a constant size type.
   */)_pb11_weaver");
    handle.value("CXTypeLayoutError_InvalidFieldName",
                 CXTypeLayoutError::CXTypeLayoutError_InvalidFieldName,
                 R"_pb11_weaver(/**
   * The Field name is not valid for this record.
   */)_pb11_weaver");
    handle.value("CXTypeLayoutError_Undeduced",
                 CXTypeLayoutError::CXTypeLayoutError_Undeduced,
                 R"_pb11_weaver(/**
   * The type is undeduced.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTypeLayoutError"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTypeLayoutError

using Entity_CXTypeLayoutError = Bind_CXTypeLayoutError<>;

#else

struct Entity_CXTypeLayoutError : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTypeLayoutError(EntityScope parent_h) {}
  static const char *Key() { return "CXTypeLayoutError"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTypeLayoutError

template <class Pybind11T = pybind11::enum_<CXTypeNullabilityKind>>
struct Bind_CXTypeNullabilityKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXTypeNullabilityKind(EntityScope parent_h)
      : handle{parent_h, "CXTypeNullabilityKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXTypeNullabilityKind(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXTypeNullability_NonNull",
                 CXTypeNullabilityKind::CXTypeNullability_NonNull,
                 R"_pb11_weaver(/**
   * Values of this type can never be null.
   */)_pb11_weaver");
    handle.value("CXTypeNullability_Nullable",
                 CXTypeNullabilityKind::CXTypeNullability_Nullable,
                 R"_pb11_weaver(/**
   * Values of this type can be null.
   */)_pb11_weaver");
    handle.value("CXTypeNullability_Unspecified",
                 CXTypeNullabilityKind::CXTypeNullability_Unspecified,
                 R"_pb11_weaver(/**
   * Whether values of this type can be null is (explicitly)
   * unspecified. This captures a (fairly rare) case where we
   * can't conclude anything about the nullability of the type even
   * though it has been considered.
   */)_pb11_weaver");
    handle.value("CXTypeNullability_Invalid",
                 CXTypeNullabilityKind::CXTypeNullability_Invalid,
                 R"_pb11_weaver(/**
   * Nullability is not applicable to this type.
   */)_pb11_weaver");
    handle.value("CXTypeNullability_NullableResult",
                 CXTypeNullabilityKind::CXTypeNullability_NullableResult,
                 R"_pb11_weaver(/**
   * Generally behaves like Nullable, except when used in a block parameter that
   * was imported into a swift async method. There, swift will assume that the
   * parameter can get null even if no error occurred. _Nullable parameters are
   * assumed to only get null on error.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXTypeNullabilityKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXTypeNullabilityKind

using Entity_CXTypeNullabilityKind = Bind_CXTypeNullabilityKind<>;

#else

struct Entity_CXTypeNullabilityKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXTypeNullabilityKind(EntityScope parent_h) {}
  static const char *Key() { return "CXTypeNullabilityKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXTypeNullabilityKind

template <class Pybind11T = pybind11::class_<CXUnsavedFile>>
struct Bind_CXUnsavedFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXUnsavedFile(EntityScope parent_h)
      : handle{parent_h, "CXUnsavedFile", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Provides the contents of a file that has not yet been saved to disk.
 *
 * Each CXUnsavedFile instance provides the name of a file on the
 * system along with the current contents of that file that have not
 * yet been saved to disk.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXUnsavedFile(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXUnsavedFile>(handle);
    handle.def_readwrite("Filename", &CXUnsavedFile::Filename,
                         R"_pb11_weaver(/**
   * The file whose contents have not yet been saved.
   *
   * This file must already exist in the file system.
   */)_pb11_weaver");
    handle.def_readwrite("Contents", &CXUnsavedFile::Contents,
                         R"_pb11_weaver(/**
   * A buffer containing the unsaved contents of this file.
   */)_pb11_weaver");
    handle.def_readwrite("Length", &CXUnsavedFile::Length, R"_pb11_weaver(/**
   * The length of the unsaved contents of this buffer.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXUnsavedFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXUnsavedFile

using Entity_CXUnsavedFile = Bind_CXUnsavedFile<>;

#else

struct Entity_CXUnsavedFile : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXUnsavedFile(EntityScope parent_h) {}
  static const char *Key() { return "CXUnsavedFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXUnsavedFile

template <class Pybind11T = pybind11::class_<CXVersion>>
struct Bind_CXVersion : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXVersion(EntityScope parent_h)
      : handle{parent_h, "CXVersion", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * Describes a version number of the form major.minor.subminor.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXVersion(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<CXVersion>(handle);
    handle.def_readwrite("Major", &CXVersion::Major, R"_pb11_weaver(/**
   * The major version number, e.g., the '10' in '10.7.3'. A negative
   * value indicates that there is no version number at all.
   */)_pb11_weaver");
    handle.def_readwrite("Minor", &CXVersion::Minor, R"_pb11_weaver(/**
   * The minor version number, e.g., the '7' in '10.7.3'. This value
   * will be negative if no minor version number was provided, e.g., for
   * version '10'.
   */)_pb11_weaver");
    handle.def_readwrite("Subminor", &CXVersion::Subminor, R"_pb11_weaver(/**
   * The subminor version number, e.g., the '3' in '10.7.3'. This value
   * will be negative if no minor or subminor version number was provided,
   * e.g., in version '10' or '10.7'.
   */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXVersion"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXVersion

using Entity_CXVersion = Bind_CXVersion<>;

#else

struct Entity_CXVersion : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXVersion(EntityScope parent_h) {}
  static const char *Key() { return "CXVersion"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXVersion

template <class Pybind11T = pybind11::enum_<CXVisibilityKind>>
struct Bind_CXVisibilityKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXVisibilityKind(EntityScope parent_h)
      : handle{parent_h, "CXVisibilityKind", pybind11::arithmetic()} {}

  template <class... HandleArgsT>
  explicit Bind_CXVisibilityKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value(
        "CXVisibility_Invalid", CXVisibilityKind::CXVisibility_Invalid,
        R"_pb11_weaver(/** This value indicates that no visibility information is available
   * for a provided CXCursor. */)_pb11_weaver");
    handle.value(
        "CXVisibility_Hidden", CXVisibilityKind::CXVisibility_Hidden,
        R"_pb11_weaver(/** Symbol not seen by the linker. */)_pb11_weaver");
    handle.value(
        "CXVisibility_Protected", CXVisibilityKind::CXVisibility_Protected,
        R"_pb11_weaver(/** Symbol seen by the linker but resolves to a symbol inside this object. */)_pb11_weaver");
    handle.value(
        "CXVisibility_Default", CXVisibilityKind::CXVisibility_Default,
        R"_pb11_weaver(/** Symbol seen by the linker and acts like a normal symbol. */)_pb11_weaver");
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXVisibilityKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXVisibilityKind

using Entity_CXVisibilityKind = Bind_CXVisibilityKind<>;

#else

struct Entity_CXVisibilityKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXVisibilityKind(EntityScope parent_h) {}
  static const char *Key() { return "CXVisibilityKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXVisibilityKind

template <class Pybind11T = pybind11::enum_<CXVisitorResult>>
struct Bind_CXVisitorResult : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CXVisitorResult(EntityScope parent_h)
      : handle{
            parent_h, "CXVisitorResult", pybind11::arithmetic(),
            R"_pb11_weaver(/** \defgroup CINDEX_HIGH Higher level API functions
 *
 * @{
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CXVisitorResult(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CXVisit_Break", CXVisitorResult::CXVisit_Break);
    handle.value("CXVisit_Continue", CXVisitorResult::CXVisit_Continue);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CXVisitorResult"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CXVisitorResult

using Entity_CXVisitorResult = Bind_CXVisitorResult<>;

#else

struct Entity_CXVisitorResult : public pybind11_weaver::DisabledEntity {
  explicit Entity_CXVisitorResult(EntityScope parent_h) {}
  static const char *Key() { return "CXVisitorResult"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CXVisitorResult

template <class Pybind11T = pybind11::enum_<CX_CXXAccessSpecifier>>
struct Bind_CX_CXXAccessSpecifier : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CX_CXXAccessSpecifier(EntityScope parent_h)
      : handle{parent_h, "CX_CXXAccessSpecifier", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Represents the C++ access control level to a base class for a
 * cursor with kind CX_CXXBaseSpecifier.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CX_CXXAccessSpecifier(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CX_CXXInvalidAccessSpecifier",
                 CX_CXXAccessSpecifier::CX_CXXInvalidAccessSpecifier);
    handle.value("CX_CXXPublic", CX_CXXAccessSpecifier::CX_CXXPublic);
    handle.value("CX_CXXProtected", CX_CXXAccessSpecifier::CX_CXXProtected);
    handle.value("CX_CXXPrivate", CX_CXXAccessSpecifier::CX_CXXPrivate);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CX_CXXAccessSpecifier"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CX_CXXAccessSpecifier

using Entity_CX_CXXAccessSpecifier = Bind_CX_CXXAccessSpecifier<>;

#else

struct Entity_CX_CXXAccessSpecifier : public pybind11_weaver::DisabledEntity {
  explicit Entity_CX_CXXAccessSpecifier(EntityScope parent_h) {}
  static const char *Key() { return "CX_CXXAccessSpecifier"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CX_CXXAccessSpecifier

template <class Pybind11T = pybind11::enum_<CX_StorageClass>>
struct Bind_CX_StorageClass : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_CX_StorageClass(EntityScope parent_h)
      : handle{parent_h, "CX_StorageClass", pybind11::arithmetic(),
               R"_pb11_weaver(/**
 * Represents the storage classes as declared in the source. CX_SC_Invalid
 * was added for the case that the passed cursor in not a declaration.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_CX_StorageClass(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    handle.value("CX_SC_Invalid", CX_StorageClass::CX_SC_Invalid);
    handle.value("CX_SC_None", CX_StorageClass::CX_SC_None);
    handle.value("CX_SC_Extern", CX_StorageClass::CX_SC_Extern);
    handle.value("CX_SC_Static", CX_StorageClass::CX_SC_Static);
    handle.value("CX_SC_PrivateExtern", CX_StorageClass::CX_SC_PrivateExtern);
    handle.value("CX_SC_OpenCLWorkGroupLocal",
                 CX_StorageClass::CX_SC_OpenCLWorkGroupLocal);
    handle.value("CX_SC_Auto", CX_StorageClass::CX_SC_Auto);
    handle.value("CX_SC_Register", CX_StorageClass::CX_SC_Register);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "CX_StorageClass"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_CX_StorageClass

using Entity_CX_StorageClass = Bind_CX_StorageClass<>;

#else

struct Entity_CX_StorageClass : public pybind11_weaver::DisabledEntity {
  explicit Entity_CX_StorageClass(EntityScope parent_h) {}
  static const char *Key() { return "CX_StorageClass"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_CX_StorageClass

template <class Pybind11T = pybind11::class_<IndexerCallbacks>>
struct Bind_IndexerCallbacks : public EntityBase {
  using Pybind11Type = Pybind11T;

  explicit Bind_IndexerCallbacks(EntityScope parent_h)
      : handle{parent_h, "IndexerCallbacks", pybind11::dynamic_attr(),
               R"_pb11_weaver(/**
 * A group of callbacks used by #clang_indexSourceFile and
 * #clang_indexTranslationUnit.
 */)_pb11_weaver"} {}

  template <class... HandleArgsT>
  explicit Bind_IndexerCallbacks(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override {
    pybind11_weaver::TryAddDefaultCtor<IndexerCallbacks>(handle);
  }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "IndexerCallbacks"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_IndexerCallbacks

using Entity_IndexerCallbacks = Bind_IndexerCallbacks<>;

#else

struct Entity_IndexerCallbacks : public pybind11_weaver::DisabledEntity {
  explicit Entity_IndexerCallbacks(EntityScope parent_h) {}
  static const char *Key() { return "IndexerCallbacks"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_IndexerCallbacks

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_BlockCommandComment_getArgText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \param ArgIdx argument index (zero-based).
 *
 * \returns text of the specified word-like argument.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_BlockCommandComment_getArgText_AddFunction
    handle.def("clang_BlockCommandComment_getArgText",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(CXComment, unsigned int)>::type>(
                   &clang_BlockCommandComment_getArgText),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_BlockCommandComment_getArgText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_BlockCommandComment_getArgText(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_BlockCommandComment_getArgText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getArgText

using Entity_clang_BlockCommandComment_getArgText =
    Bind_clang_BlockCommandComment_getArgText<>;

#else

struct Entity_clang_BlockCommandComment_getArgText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_BlockCommandComment_getArgText(EntityScope parent_h) {}
  static const char *Key() { return "clang_BlockCommandComment_getArgText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getArgText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_BlockCommandComment_getCommandName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \returns name of the block command.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_BlockCommandComment_getCommandName_AddFunction
    handle.def(
        "clang_BlockCommandComment_getCommandName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_BlockCommandComment_getCommandName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_BlockCommandComment_getCommandName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_BlockCommandComment_getCommandName(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_BlockCommandComment_getCommandName";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getCommandName

using Entity_clang_BlockCommandComment_getCommandName =
    Bind_clang_BlockCommandComment_getCommandName<>;

#else

struct Entity_clang_BlockCommandComment_getCommandName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_BlockCommandComment_getCommandName(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_BlockCommandComment_getCommandName";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getCommandName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_BlockCommandComment_getNumArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \returns number of word-like arguments.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_BlockCommandComment_getNumArgs_AddFunction
    handle.def(
        "clang_BlockCommandComment_getNumArgs",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_BlockCommandComment_getNumArgs),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_BlockCommandComment_getNumArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_BlockCommandComment_getNumArgs(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_BlockCommandComment_getNumArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getNumArgs

using Entity_clang_BlockCommandComment_getNumArgs =
    Bind_clang_BlockCommandComment_getNumArgs<>;

#else

struct Entity_clang_BlockCommandComment_getNumArgs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_BlockCommandComment_getNumArgs(EntityScope parent_h) {}
  static const char *Key() { return "clang_BlockCommandComment_getNumArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getNumArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_BlockCommandComment_getParagraph : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_BlockCommand or
 * \c CXComment_VerbatimBlockCommand AST node.
 *
 * \returns paragraph argument of the block command.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_BlockCommandComment_getParagraph_AddFunction
    handle.def(
        "clang_BlockCommandComment_getParagraph",
        static_cast<pybind11_weaver::FnPtrT<void, CXComment(CXComment)>::type>(
            &clang_BlockCommandComment_getParagraph),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_BlockCommandComment_getParagraph(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_BlockCommandComment_getParagraph(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_BlockCommandComment_getParagraph"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getParagraph

using Entity_clang_BlockCommandComment_getParagraph =
    Bind_clang_BlockCommandComment_getParagraph<>;

#else

struct Entity_clang_BlockCommandComment_getParagraph
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_BlockCommandComment_getParagraph(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_BlockCommandComment_getParagraph"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_BlockCommandComment_getParagraph

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXCursorSet_contains : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Queries a CXCursorSet to see if it contains a specific CXCursor.
 *
 * \returns non-zero if the set contains the specified cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXCursorSet_contains_AddFunction
    handle.def(
        "clang_CXCursorSet_contains",
        [](pybind11_weaver::WrappedPtrT<CXCursorSetImpl *> cset,
           CXCursor cursor) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXCursorSetImpl *, CXCursor)>::type>(
                  &clang_CXCursorSet_contains),
              (cset)->Cptr(), cursor);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXCursorSet_contains(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXCursorSet_contains(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXCursorSet_contains"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXCursorSet_contains

using Entity_clang_CXCursorSet_contains = Bind_clang_CXCursorSet_contains<>;

#else

struct Entity_clang_CXCursorSet_contains
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXCursorSet_contains(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXCursorSet_contains"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXCursorSet_contains

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXCursorSet_insert : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Inserts a CXCursor into a CXCursorSet.
 *
 * \returns zero if the CXCursor was already in the set, and non-zero otherwise.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXCursorSet_insert_AddFunction
    handle.def(
        "clang_CXCursorSet_insert",
        [](pybind11_weaver::WrappedPtrT<CXCursorSetImpl *> cset,
           CXCursor cursor) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXCursorSetImpl *, CXCursor)>::type>(
                  &clang_CXCursorSet_insert),
              (cset)->Cptr(), cursor);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXCursorSet_insert(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXCursorSet_insert(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXCursorSet_insert"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXCursorSet_insert

using Entity_clang_CXCursorSet_insert = Bind_clang_CXCursorSet_insert<>;

#else

struct Entity_clang_CXCursorSet_insert
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXCursorSet_insert(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXCursorSet_insert"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXCursorSet_insert

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXIndex_getGlobalOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Gets the general options associated with a CXIndex.
 *
 * \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that
 * are associated with the given CXIndex object.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXIndex_getGlobalOptions_AddFunction
    handle.def(
        "clang_CXIndex_getGlobalOptions",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_CXIndex_getGlobalOptions),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXIndex_getGlobalOptions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXIndex_getGlobalOptions(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXIndex_getGlobalOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXIndex_getGlobalOptions

using Entity_clang_CXIndex_getGlobalOptions =
    Bind_clang_CXIndex_getGlobalOptions<>;

#else

struct Entity_clang_CXIndex_getGlobalOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXIndex_getGlobalOptions(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXIndex_getGlobalOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXIndex_getGlobalOptions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXIndex_setGlobalOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Sets general options associated with a CXIndex.
 *
 * For example:
 * \code
 * CXIndex idx = ...;
 * clang_CXIndex_setGlobalOptions(idx,
 *     clang_CXIndex_getGlobalOptions(idx) |
 *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
 * \endcode
 *
 * \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXIndex_setGlobalOptions_AddFunction
    handle.def(
        "clang_CXIndex_setGlobalOptions",
        [](pybind11_weaver::WrappedPtrT<void *> arg0, unsigned int options) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, void(void *, unsigned int)>::type>(
                                 &clang_CXIndex_setGlobalOptions),
                             (arg0)->Cptr(), options);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXIndex_setGlobalOptions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXIndex_setGlobalOptions(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXIndex_setGlobalOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXIndex_setGlobalOptions

using Entity_clang_CXIndex_setGlobalOptions =
    Bind_clang_CXIndex_setGlobalOptions<>;

#else

struct Entity_clang_CXIndex_setGlobalOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXIndex_setGlobalOptions(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXIndex_setGlobalOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXIndex_setGlobalOptions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXIndex_setInvocationEmissionPathOption : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Sets the invocation emission path option in a CXIndex.
 *
 * The invocation emission path specifies a path which will contain log
 * files for certain libclang invocations. A null value (default) implies that
 * libclang invocations are not logged..
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXIndex_setInvocationEmissionPathOption_AddFunction
    handle.def(
        "clang_CXIndex_setInvocationEmissionPathOption",
        [](pybind11_weaver::WrappedPtrT<void *> arg0, const char *Path) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(void *, const char *)>::type>(
                  &clang_CXIndex_setInvocationEmissionPathOption),
              (arg0)->Cptr(), Path);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXIndex_setInvocationEmissionPathOption(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXIndex_setInvocationEmissionPathOption(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CXIndex_setInvocationEmissionPathOption";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXIndex_setInvocationEmissionPathOption

using Entity_clang_CXIndex_setInvocationEmissionPathOption =
    Bind_clang_CXIndex_setInvocationEmissionPathOption<>;

#else

struct Entity_clang_CXIndex_setInvocationEmissionPathOption
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXIndex_setInvocationEmissionPathOption(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CXIndex_setInvocationEmissionPathOption";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXIndex_setInvocationEmissionPathOption

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXRewriter_create : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Create CXRewriter.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXRewriter_create_AddFunction
    handle.def(
        "clang_CXRewriter_create",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(CXTranslationUnitImpl *)>::type>(
                              &clang_CXRewriter_create),
                          (TU)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXRewriter_create(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXRewriter_create(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXRewriter_create"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_create

using Entity_clang_CXRewriter_create = Bind_clang_CXRewriter_create<>;

#else

struct Entity_clang_CXRewriter_create : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXRewriter_create(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXRewriter_create"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_create

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXRewriter_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the given CXRewriter.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXRewriter_dispose_AddFunction
    handle.def(
        "clang_CXRewriter_dispose",
        [](pybind11_weaver::WrappedPtrT<void *> Rew) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_CXRewriter_dispose),
              (Rew)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXRewriter_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXRewriter_dispose(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXRewriter_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_dispose

using Entity_clang_CXRewriter_dispose = Bind_clang_CXRewriter_dispose<>;

#else

struct Entity_clang_CXRewriter_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXRewriter_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXRewriter_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXRewriter_insertTextBefore : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Insert the specified string at the specified location in the original buffer.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXRewriter_insertTextBefore_AddFunction
    handle.def(
        "clang_CXRewriter_insertTextBefore",
        [](pybind11_weaver::WrappedPtrT<void *> Rew, CXSourceLocation Loc,
           const char *Insert) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(void *, CXSourceLocation, const char *)>::type>(
                  &clang_CXRewriter_insertTextBefore),
              (Rew)->Cptr(), Loc, Insert);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXRewriter_insertTextBefore(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXRewriter_insertTextBefore(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXRewriter_insertTextBefore"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_insertTextBefore

using Entity_clang_CXRewriter_insertTextBefore =
    Bind_clang_CXRewriter_insertTextBefore<>;

#else

struct Entity_clang_CXRewriter_insertTextBefore
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXRewriter_insertTextBefore(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXRewriter_insertTextBefore"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_insertTextBefore

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXRewriter_overwriteChangedFiles : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Save all changed files to disk.
 * Returns 1 if any files were not saved successfully, returns 0 otherwise.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXRewriter_overwriteChangedFiles_AddFunction
    handle.def(
        "clang_CXRewriter_overwriteChangedFiles",
        [](pybind11_weaver::WrappedPtrT<void *> Rew) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, int(void *)>::type>(
                  &clang_CXRewriter_overwriteChangedFiles),
              (Rew)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXRewriter_overwriteChangedFiles(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXRewriter_overwriteChangedFiles(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXRewriter_overwriteChangedFiles"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_overwriteChangedFiles

using Entity_clang_CXRewriter_overwriteChangedFiles =
    Bind_clang_CXRewriter_overwriteChangedFiles<>;

#else

struct Entity_clang_CXRewriter_overwriteChangedFiles
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXRewriter_overwriteChangedFiles(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_CXRewriter_overwriteChangedFiles"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_overwriteChangedFiles

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXRewriter_removeText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Remove the specified range.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXRewriter_removeText_AddFunction
    handle.def(
        "clang_CXRewriter_removeText",
        [](pybind11_weaver::WrappedPtrT<void *> Rew,
           CXSourceRange ToBeRemoved) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, void(void *, CXSourceRange)>::type>(
                                 &clang_CXRewriter_removeText),
                             (Rew)->Cptr(), ToBeRemoved);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXRewriter_removeText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXRewriter_removeText(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXRewriter_removeText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_removeText

using Entity_clang_CXRewriter_removeText = Bind_clang_CXRewriter_removeText<>;

#else

struct Entity_clang_CXRewriter_removeText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXRewriter_removeText(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXRewriter_removeText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_removeText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXRewriter_replaceText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Replace the specified range of characters in the input with the specified
 * replacement.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXRewriter_replaceText_AddFunction
    handle.def(
        "clang_CXRewriter_replaceText",
        [](pybind11_weaver::WrappedPtrT<void *> Rew, CXSourceRange ToBeReplaced,
           const char *Replacement) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(void *, CXSourceRange, const char *)>::type>(
                  &clang_CXRewriter_replaceText),
              (Rew)->Cptr(), ToBeReplaced, Replacement);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXRewriter_replaceText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXRewriter_replaceText(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXRewriter_replaceText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_replaceText

using Entity_clang_CXRewriter_replaceText = Bind_clang_CXRewriter_replaceText<>;

#else

struct Entity_clang_CXRewriter_replaceText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXRewriter_replaceText(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXRewriter_replaceText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_replaceText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXRewriter_writeMainFileToStdOut : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Write out rewritten version of the main file to stdout.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXRewriter_writeMainFileToStdOut_AddFunction
    handle.def(
        "clang_CXRewriter_writeMainFileToStdOut",
        [](pybind11_weaver::WrappedPtrT<void *> Rew) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_CXRewriter_writeMainFileToStdOut),
              (Rew)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXRewriter_writeMainFileToStdOut(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXRewriter_writeMainFileToStdOut(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXRewriter_writeMainFileToStdOut"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_writeMainFileToStdOut

using Entity_clang_CXRewriter_writeMainFileToStdOut =
    Bind_clang_CXRewriter_writeMainFileToStdOut<>;

#else

struct Entity_clang_CXRewriter_writeMainFileToStdOut
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXRewriter_writeMainFileToStdOut(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_CXRewriter_writeMainFileToStdOut"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXRewriter_writeMainFileToStdOut

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXConstructor_isConvertingConstructor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ constructor is a converting constructor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXConstructor_isConvertingConstructor_AddFunction
    handle.def("clang_CXXConstructor_isConvertingConstructor",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXConstructor_isConvertingConstructor),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXConstructor_isConvertingConstructor(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXConstructor_isConvertingConstructor(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CXXConstructor_isConvertingConstructor";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isConvertingConstructor

using Entity_clang_CXXConstructor_isConvertingConstructor =
    Bind_clang_CXXConstructor_isConvertingConstructor<>;

#else

struct Entity_clang_CXXConstructor_isConvertingConstructor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXConstructor_isConvertingConstructor(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CXXConstructor_isConvertingConstructor";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isConvertingConstructor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXConstructor_isCopyConstructor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ constructor is a copy constructor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXConstructor_isCopyConstructor_AddFunction
    handle.def("clang_CXXConstructor_isCopyConstructor",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXConstructor_isCopyConstructor),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXConstructor_isCopyConstructor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXConstructor_isCopyConstructor(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXConstructor_isCopyConstructor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isCopyConstructor

using Entity_clang_CXXConstructor_isCopyConstructor =
    Bind_clang_CXXConstructor_isCopyConstructor<>;

#else

struct Entity_clang_CXXConstructor_isCopyConstructor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXConstructor_isCopyConstructor(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_CXXConstructor_isCopyConstructor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isCopyConstructor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXConstructor_isDefaultConstructor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ constructor is the default constructor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXConstructor_isDefaultConstructor_AddFunction
    handle.def("clang_CXXConstructor_isDefaultConstructor",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXConstructor_isDefaultConstructor),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXConstructor_isDefaultConstructor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXConstructor_isDefaultConstructor(EntityScope parent_h,
                                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CXXConstructor_isDefaultConstructor";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isDefaultConstructor

using Entity_clang_CXXConstructor_isDefaultConstructor =
    Bind_clang_CXXConstructor_isDefaultConstructor<>;

#else

struct Entity_clang_CXXConstructor_isDefaultConstructor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXConstructor_isDefaultConstructor(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CXXConstructor_isDefaultConstructor";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isDefaultConstructor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXConstructor_isMoveConstructor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ constructor is a move constructor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXConstructor_isMoveConstructor_AddFunction
    handle.def("clang_CXXConstructor_isMoveConstructor",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXConstructor_isMoveConstructor),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXConstructor_isMoveConstructor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXConstructor_isMoveConstructor(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXConstructor_isMoveConstructor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isMoveConstructor

using Entity_clang_CXXConstructor_isMoveConstructor =
    Bind_clang_CXXConstructor_isMoveConstructor<>;

#else

struct Entity_clang_CXXConstructor_isMoveConstructor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXConstructor_isMoveConstructor(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_CXXConstructor_isMoveConstructor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXConstructor_isMoveConstructor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXField_isMutable : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ field is declared 'mutable'.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXField_isMutable_AddFunction
    handle.def("clang_CXXField_isMutable",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXField_isMutable),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXField_isMutable(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXField_isMutable(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXField_isMutable"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXField_isMutable

using Entity_clang_CXXField_isMutable = Bind_clang_CXXField_isMutable<>;

#else

struct Entity_clang_CXXField_isMutable
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXField_isMutable(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXField_isMutable"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXField_isMutable

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isConst : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ member function or member function template is
 * declared 'const'.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isConst_AddFunction
    handle.def("clang_CXXMethod_isConst",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isConst),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isConst(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isConst(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXMethod_isConst"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isConst

using Entity_clang_CXXMethod_isConst = Bind_clang_CXXMethod_isConst<>;

#else

struct Entity_clang_CXXMethod_isConst : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isConst(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXMethod_isConst"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isConst

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isCopyAssignmentOperator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ member function is a copy-assignment operator,
 * returning 1 if such is the case and 0 otherwise.
 *
 * > A copy-assignment operator `X::operator=` is a non-static,
 * > non-template member function of _class_ `X` with exactly one
 * > parameter of type `X`, `X&`, `const X&`, `volatile X&` or `const
 * > volatile X&`.
 *
 * That is, for example, the `operator=` in:
 *
 *    class Foo {
 *        bool operator=(const volatile Foo&);
 *    };
 *
 * Is a copy-assignment operator, while the `operator=` in:
 *
 *    class Bar {
 *        bool operator=(const int&);
 *    };
 *
 * Is not.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isCopyAssignmentOperator_AddFunction
    handle.def("clang_CXXMethod_isCopyAssignmentOperator",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isCopyAssignmentOperator),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isCopyAssignmentOperator(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isCopyAssignmentOperator(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CXXMethod_isCopyAssignmentOperator";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isCopyAssignmentOperator

using Entity_clang_CXXMethod_isCopyAssignmentOperator =
    Bind_clang_CXXMethod_isCopyAssignmentOperator<>;

#else

struct Entity_clang_CXXMethod_isCopyAssignmentOperator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isCopyAssignmentOperator(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CXXMethod_isCopyAssignmentOperator";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isCopyAssignmentOperator

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isDefaulted : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ method is declared '= default'.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isDefaulted_AddFunction
    handle.def("clang_CXXMethod_isDefaulted",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isDefaulted),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isDefaulted(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isDefaulted(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXMethod_isDefaulted"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isDefaulted

using Entity_clang_CXXMethod_isDefaulted = Bind_clang_CXXMethod_isDefaulted<>;

#else

struct Entity_clang_CXXMethod_isDefaulted
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isDefaulted(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXMethod_isDefaulted"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isDefaulted

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isDeleted : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ method is declared '= delete'.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isDeleted_AddFunction
    handle.def("clang_CXXMethod_isDeleted",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isDeleted),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isDeleted(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isDeleted(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXMethod_isDeleted"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isDeleted

using Entity_clang_CXXMethod_isDeleted = Bind_clang_CXXMethod_isDeleted<>;

#else

struct Entity_clang_CXXMethod_isDeleted
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isDeleted(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXMethod_isDeleted"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isDeleted

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isMoveAssignmentOperator : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ member function is a move-assignment operator,
 * returning 1 if such is the case and 0 otherwise.
 *
 * > A move-assignment operator `X::operator=` is a non-static,
 * > non-template member function of _class_ `X` with exactly one
 * > parameter of type `X&&`, `const X&&`, `volatile X&&` or `const
 * > volatile X&&`.
 *
 * That is, for example, the `operator=` in:
 *
 *    class Foo {
 *        bool operator=(const volatile Foo&&);
 *    };
 *
 * Is a move-assignment operator, while the `operator=` in:
 *
 *    class Bar {
 *        bool operator=(const int&&);
 *    };
 *
 * Is not.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isMoveAssignmentOperator_AddFunction
    handle.def("clang_CXXMethod_isMoveAssignmentOperator",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isMoveAssignmentOperator),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isMoveAssignmentOperator(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isMoveAssignmentOperator(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CXXMethod_isMoveAssignmentOperator";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isMoveAssignmentOperator

using Entity_clang_CXXMethod_isMoveAssignmentOperator =
    Bind_clang_CXXMethod_isMoveAssignmentOperator<>;

#else

struct Entity_clang_CXXMethod_isMoveAssignmentOperator
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isMoveAssignmentOperator(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CXXMethod_isMoveAssignmentOperator";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isMoveAssignmentOperator

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isPureVirtual : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ member function or member function template is
 * pure virtual.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isPureVirtual_AddFunction
    handle.def("clang_CXXMethod_isPureVirtual",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isPureVirtual),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isPureVirtual(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isPureVirtual(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXMethod_isPureVirtual"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isPureVirtual

using Entity_clang_CXXMethod_isPureVirtual =
    Bind_clang_CXXMethod_isPureVirtual<>;

#else

struct Entity_clang_CXXMethod_isPureVirtual
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isPureVirtual(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXMethod_isPureVirtual"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isPureVirtual

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isStatic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ member function or member function template is
 * declared 'static'.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isStatic_AddFunction
    handle.def("clang_CXXMethod_isStatic",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isStatic),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isStatic(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isStatic(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXMethod_isStatic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isStatic

using Entity_clang_CXXMethod_isStatic = Bind_clang_CXXMethod_isStatic<>;

#else

struct Entity_clang_CXXMethod_isStatic
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isStatic(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXMethod_isStatic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isStatic

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXMethod_isVirtual : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ member function or member function template is
 * explicitly declared 'virtual' or if it overrides a virtual method from
 * one of the base classes.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXMethod_isVirtual_AddFunction
    handle.def("clang_CXXMethod_isVirtual",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXMethod_isVirtual),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXMethod_isVirtual(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXMethod_isVirtual(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXMethod_isVirtual"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isVirtual

using Entity_clang_CXXMethod_isVirtual = Bind_clang_CXXMethod_isVirtual<>;

#else

struct Entity_clang_CXXMethod_isVirtual
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXMethod_isVirtual(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXMethod_isVirtual"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXMethod_isVirtual

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CXXRecord_isAbstract : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a C++ record is abstract, i.e. whether a class or struct
 * has a pure virtual member function.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CXXRecord_isAbstract_AddFunction
    handle.def("clang_CXXRecord_isAbstract",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_CXXRecord_isAbstract),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CXXRecord_isAbstract(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CXXRecord_isAbstract(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CXXRecord_isAbstract"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CXXRecord_isAbstract

using Entity_clang_CXXRecord_isAbstract = Bind_clang_CXXRecord_isAbstract<>;

#else

struct Entity_clang_CXXRecord_isAbstract
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CXXRecord_isAbstract(EntityScope parent_h) {}
  static const char *Key() { return "clang_CXXRecord_isAbstract"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CXXRecord_isAbstract

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Comment_getChild : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment AST node of any kind.
 *
 * \param ChildIdx child index (zero-based).
 *
 * \returns the specified child of the AST node.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Comment_getChild_AddFunction
    handle.def("clang_Comment_getChild",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXComment(CXComment, unsigned int)>::type>(
                   &clang_Comment_getChild),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Comment_getChild(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Comment_getChild(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Comment_getChild"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Comment_getChild

using Entity_clang_Comment_getChild = Bind_clang_Comment_getChild<>;

#else

struct Entity_clang_Comment_getChild : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Comment_getChild(EntityScope parent_h) {}
  static const char *Key() { return "clang_Comment_getChild"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Comment_getChild

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Comment_getKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment AST node of any kind.
 *
 * \returns the type of the AST node.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Comment_getKind_AddFunction
    handle.def(
        "clang_Comment_getKind",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXCommentKind(CXComment)>::type>(
            &clang_Comment_getKind),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Comment_getKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Comment_getKind(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Comment_getKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Comment_getKind

using Entity_clang_Comment_getKind = Bind_clang_Comment_getKind<>;

#else

struct Entity_clang_Comment_getKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Comment_getKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_Comment_getKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Comment_getKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Comment_getNumChildren : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment AST node of any kind.
 *
 * \returns number of children of the AST node.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Comment_getNumChildren_AddFunction
    handle.def(
        "clang_Comment_getNumChildren",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_Comment_getNumChildren),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Comment_getNumChildren(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Comment_getNumChildren(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Comment_getNumChildren"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Comment_getNumChildren

using Entity_clang_Comment_getNumChildren = Bind_clang_Comment_getNumChildren<>;

#else

struct Entity_clang_Comment_getNumChildren
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Comment_getNumChildren(EntityScope parent_h) {}
  static const char *Key() { return "clang_Comment_getNumChildren"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Comment_getNumChildren

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Comment_isWhitespace : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * A \c CXComment_Paragraph node is considered whitespace if it contains
 * only \c CXComment_Text nodes that are empty or whitespace.
 *
 * Other AST nodes (except \c CXComment_Paragraph and \c CXComment_Text) are
 * never considered whitespace.
 *
 * \returns non-zero if \c Comment is whitespace.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Comment_isWhitespace_AddFunction
    handle.def(
        "clang_Comment_isWhitespace",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_Comment_isWhitespace),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Comment_isWhitespace(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Comment_isWhitespace(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Comment_isWhitespace"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Comment_isWhitespace

using Entity_clang_Comment_isWhitespace = Bind_clang_Comment_isWhitespace<>;

#else

struct Entity_clang_Comment_isWhitespace
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Comment_isWhitespace(EntityScope parent_h) {}
  static const char *Key() { return "clang_Comment_isWhitespace"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Comment_isWhitespace

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompilationDatabase_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the given compilation database
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompilationDatabase_dispose_AddFunction
    handle.def(
        "clang_CompilationDatabase_dispose",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_CompilationDatabase_dispose),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompilationDatabase_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompilationDatabase_dispose(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompilationDatabase_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_dispose

using Entity_clang_CompilationDatabase_dispose =
    Bind_clang_CompilationDatabase_dispose<>;

#else

struct Entity_clang_CompilationDatabase_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompilationDatabase_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompilationDatabase_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompilationDatabase_fromDirectory : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Creates a compilation database from the database found in directory
 * buildDir. For example, CMake can output a compile_commands.json which can
 * be used to build the database.
 *
 * It must be freed by \c clang_CompilationDatabase_dispose.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompilationDatabase_fromDirectory_AddFunction
    handle.def(
        "clang_CompilationDatabase_fromDirectory",
        [](const char *BuildDir, CXCompilationDatabase_Error *ErrorCode) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  void *(const char *, CXCompilationDatabase_Error *)>::type>(
                  &clang_CompilationDatabase_fromDirectory),
              BuildDir, ErrorCode);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompilationDatabase_fromDirectory(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompilationDatabase_fromDirectory(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompilationDatabase_fromDirectory"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_fromDirectory

using Entity_clang_CompilationDatabase_fromDirectory =
    Bind_clang_CompilationDatabase_fromDirectory<>;

#else

struct Entity_clang_CompilationDatabase_fromDirectory
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompilationDatabase_fromDirectory(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_CompilationDatabase_fromDirectory"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_fromDirectory

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompilationDatabase_getAllCompileCommands
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get all the compile commands in the given compilation database.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompilationDatabase_getAllCompileCommands_AddFunction
    handle.def(
        "clang_CompilationDatabase_getAllCompileCommands",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void *(void *)>::type>(
                  &clang_CompilationDatabase_getAllCompileCommands),
              (arg0)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompilationDatabase_getAllCompileCommands(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompilationDatabase_getAllCompileCommands(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CompilationDatabase_getAllCompileCommands";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_getAllCompileCommands

using Entity_clang_CompilationDatabase_getAllCompileCommands =
    Bind_clang_CompilationDatabase_getAllCompileCommands<>;

#else

struct Entity_clang_CompilationDatabase_getAllCompileCommands
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompilationDatabase_getAllCompileCommands(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CompilationDatabase_getAllCompileCommands";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_getAllCompileCommands

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompilationDatabase_getCompileCommands : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Find the compile commands used for a file. The compile commands
 * must be freed by \c clang_CompileCommands_dispose.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompilationDatabase_getCompileCommands_AddFunction
    handle.def(
        "clang_CompilationDatabase_getCompileCommands",
        [](pybind11_weaver::WrappedPtrT<void *> arg0,
           const char *CompleteFileName) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(void *, const char *)>::type>(
                              &clang_CompilationDatabase_getCompileCommands),
                          (arg0)->Cptr(), CompleteFileName);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompilationDatabase_getCompileCommands(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompilationDatabase_getCompileCommands(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CompilationDatabase_getCompileCommands";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_getCompileCommands

using Entity_clang_CompilationDatabase_getCompileCommands =
    Bind_clang_CompilationDatabase_getCompileCommands<>;

#else

struct Entity_clang_CompilationDatabase_getCompileCommands
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompilationDatabase_getCompileCommands(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CompilationDatabase_getCompileCommands";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompilationDatabase_getCompileCommands

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommand_getArg : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the I'th argument value in the compiler invocations
 *
 * Invariant :
 *  - argument 0 is the compiler executable
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommand_getArg_AddFunction
    handle.def(
        "clang_CompileCommand_getArg",
        [](pybind11_weaver::WrappedPtrT<void *> arg0, unsigned int I) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, unsigned int)>::type>(
                                 &clang_CompileCommand_getArg),
                             (arg0)->Cptr(), I);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommand_getArg(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommand_getArg(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompileCommand_getArg"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getArg

using Entity_clang_CompileCommand_getArg = Bind_clang_CompileCommand_getArg<>;

#else

struct Entity_clang_CompileCommand_getArg
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommand_getArg(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompileCommand_getArg"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getArg

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommand_getDirectory : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the working directory where the CompileCommand was executed from
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommand_getDirectory_AddFunction
    handle.def(
        "clang_CompileCommand_getDirectory",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_CompileCommand_getDirectory),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommand_getDirectory(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommand_getDirectory(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompileCommand_getDirectory"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getDirectory

using Entity_clang_CompileCommand_getDirectory =
    Bind_clang_CompileCommand_getDirectory<>;

#else

struct Entity_clang_CompileCommand_getDirectory
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommand_getDirectory(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompileCommand_getDirectory"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getDirectory

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommand_getFilename : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the filename associated with the CompileCommand.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommand_getFilename_AddFunction
    handle.def(
        "clang_CompileCommand_getFilename",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_CompileCommand_getFilename),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommand_getFilename(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommand_getFilename(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompileCommand_getFilename"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getFilename

using Entity_clang_CompileCommand_getFilename =
    Bind_clang_CompileCommand_getFilename<>;

#else

struct Entity_clang_CompileCommand_getFilename
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommand_getFilename(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompileCommand_getFilename"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getFilename

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommand_getMappedSourceContent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the I'th mapped source content for the compiler invocation.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommand_getMappedSourceContent_AddFunction
    handle.def(
        "clang_CompileCommand_getMappedSourceContent",
        [](pybind11_weaver::WrappedPtrT<void *> arg0, unsigned int I) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, unsigned int)>::type>(
                                 &clang_CompileCommand_getMappedSourceContent),
                             (arg0)->Cptr(), I);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommand_getMappedSourceContent(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommand_getMappedSourceContent(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CompileCommand_getMappedSourceContent";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getMappedSourceContent

using Entity_clang_CompileCommand_getMappedSourceContent =
    Bind_clang_CompileCommand_getMappedSourceContent<>;

#else

struct Entity_clang_CompileCommand_getMappedSourceContent
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommand_getMappedSourceContent(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CompileCommand_getMappedSourceContent";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getMappedSourceContent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommand_getMappedSourcePath : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the I'th mapped source path for the compiler invocation.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommand_getMappedSourcePath_AddFunction
    handle.def(
        "clang_CompileCommand_getMappedSourcePath",
        [](pybind11_weaver::WrappedPtrT<void *> arg0, unsigned int I) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, unsigned int)>::type>(
                                 &clang_CompileCommand_getMappedSourcePath),
                             (arg0)->Cptr(), I);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommand_getMappedSourcePath(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommand_getMappedSourcePath(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CompileCommand_getMappedSourcePath";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getMappedSourcePath

using Entity_clang_CompileCommand_getMappedSourcePath =
    Bind_clang_CompileCommand_getMappedSourcePath<>;

#else

struct Entity_clang_CompileCommand_getMappedSourcePath
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommand_getMappedSourcePath(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CompileCommand_getMappedSourcePath";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getMappedSourcePath

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommand_getNumArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the number of arguments in the compiler invocation.
 *
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommand_getNumArgs_AddFunction
    handle.def(
        "clang_CompileCommand_getNumArgs",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_CompileCommand_getNumArgs),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommand_getNumArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommand_getNumArgs(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompileCommand_getNumArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getNumArgs

using Entity_clang_CompileCommand_getNumArgs =
    Bind_clang_CompileCommand_getNumArgs<>;

#else

struct Entity_clang_CompileCommand_getNumArgs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommand_getNumArgs(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompileCommand_getNumArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getNumArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommand_getNumMappedSources : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the number of source mappings for the compiler invocation.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommand_getNumMappedSources_AddFunction
    handle.def(
        "clang_CompileCommand_getNumMappedSources",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_CompileCommand_getNumMappedSources),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommand_getNumMappedSources(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommand_getNumMappedSources(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_CompileCommand_getNumMappedSources";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getNumMappedSources

using Entity_clang_CompileCommand_getNumMappedSources =
    Bind_clang_CompileCommand_getNumMappedSources<>;

#else

struct Entity_clang_CompileCommand_getNumMappedSources
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommand_getNumMappedSources(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_CompileCommand_getNumMappedSources";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommand_getNumMappedSources

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommands_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the given CompileCommands
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommands_dispose_AddFunction
    handle.def(
        "clang_CompileCommands_dispose",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_CompileCommands_dispose),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommands_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommands_dispose(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompileCommands_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommands_dispose

using Entity_clang_CompileCommands_dispose =
    Bind_clang_CompileCommands_dispose<>;

#else

struct Entity_clang_CompileCommands_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommands_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompileCommands_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommands_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommands_getCommand : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the I'th CompileCommand for a file
 *
 * Note : 0 <= i < clang_CompileCommands_getSize(CXCompileCommands)
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommands_getCommand_AddFunction
    handle.def(
        "clang_CompileCommands_getCommand",
        [](pybind11_weaver::WrappedPtrT<void *> arg0, unsigned int I) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(void *, unsigned int)>::type>(
                              &clang_CompileCommands_getCommand),
                          (arg0)->Cptr(), I);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommands_getCommand(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommands_getCommand(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompileCommands_getCommand"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommands_getCommand

using Entity_clang_CompileCommands_getCommand =
    Bind_clang_CompileCommands_getCommand<>;

#else

struct Entity_clang_CompileCommands_getCommand
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommands_getCommand(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompileCommands_getCommand"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommands_getCommand

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_CompileCommands_getSize : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the number of CompileCommand we have for a file
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_CompileCommands_getSize_AddFunction
    handle.def(
        "clang_CompileCommands_getSize",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_CompileCommands_getSize),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_CompileCommands_getSize(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_CompileCommands_getSize(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_CompileCommands_getSize"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_CompileCommands_getSize

using Entity_clang_CompileCommands_getSize =
    Bind_clang_CompileCommands_getSize<>;

#else

struct Entity_clang_CompileCommands_getSize
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_CompileCommands_getSize(EntityScope parent_h) {}
  static const char *Key() { return "clang_CompileCommands_getSize"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_CompileCommands_getSize

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_Evaluate : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * If cursor is a statement declaration tries to evaluate the
 * statement and if its variable, tries to evaluate its initializer,
 * into its corresponding type.
 * If it's an expression, tries to evaluate the expression.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_Evaluate_AddFunction
    handle.def(
        "clang_Cursor_Evaluate",
        [](CXCursor C) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void *(CXCursor)>::type>(
                  &clang_Cursor_Evaluate),
              C);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_Evaluate(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_Evaluate(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_Evaluate"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_Evaluate

using Entity_clang_Cursor_Evaluate = Bind_clang_Cursor_Evaluate<>;

#else

struct Entity_clang_Cursor_Evaluate : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_Evaluate(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_Evaluate"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_Evaluate

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getArgument : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the argument cursor of a function or method.
 *
 * The argument cursor can be determined for calls as well as for declarations
 * of functions or methods. For other cursors and for invalid indices, an
 * invalid cursor is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getArgument_AddFunction
    handle.def("clang_Cursor_getArgument",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXCursor(CXCursor, unsigned int)>::type>(
                   &clang_Cursor_getArgument),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getArgument(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getArgument(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getArgument"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getArgument

using Entity_clang_Cursor_getArgument = Bind_clang_Cursor_getArgument<>;

#else

struct Entity_clang_Cursor_getArgument
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getArgument(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getArgument"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getArgument

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getBriefCommentText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a documentable entity (e.g.,
 * declaration), return the associated \paragraph; otherwise return the
 * first paragraph.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getBriefCommentText_AddFunction
    handle.def(
        "clang_Cursor_getBriefCommentText",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_Cursor_getBriefCommentText),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getBriefCommentText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getBriefCommentText(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getBriefCommentText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getBriefCommentText

using Entity_clang_Cursor_getBriefCommentText =
    Bind_clang_Cursor_getBriefCommentText<>;

#else

struct Entity_clang_Cursor_getBriefCommentText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getBriefCommentText(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getBriefCommentText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getBriefCommentText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getCXXManglings : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the CXStrings representing the mangled symbols of the C++
 * constructor or destructor at the cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getCXXManglings_AddFunction
    handle.def(
        "clang_Cursor_getCXXManglings",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXStringSet *(CXCursor)>::type>(
            &clang_Cursor_getCXXManglings),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getCXXManglings(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getCXXManglings(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getCXXManglings"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getCXXManglings

using Entity_clang_Cursor_getCXXManglings = Bind_clang_Cursor_getCXXManglings<>;

#else

struct Entity_clang_Cursor_getCXXManglings
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getCXXManglings(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getCXXManglings"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getCXXManglings

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getCommentRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a declaration, return the associated
 * comment's source range.  The range may include multiple consecutive comments
 * with whitespace in between.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getCommentRange_AddFunction
    handle.def(
        "clang_Cursor_getCommentRange",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXSourceRange(CXCursor)>::type>(
            &clang_Cursor_getCommentRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getCommentRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getCommentRange(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getCommentRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getCommentRange

using Entity_clang_Cursor_getCommentRange = Bind_clang_Cursor_getCommentRange<>;

#else

struct Entity_clang_Cursor_getCommentRange
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getCommentRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getCommentRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getCommentRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getMangling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the CXString representing the mangled name of the cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getMangling_AddFunction
    handle.def(
        "clang_Cursor_getMangling",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_Cursor_getMangling),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getMangling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getMangling(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getMangling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getMangling

using Entity_clang_Cursor_getMangling = Bind_clang_Cursor_getMangling<>;

#else

struct Entity_clang_Cursor_getMangling
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getMangling(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getMangling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getMangling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getModule : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a CXCursor_ModuleImportDecl cursor, return the associated module.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getModule_AddFunction
    handle.def(
        "clang_Cursor_getModule",
        [](CXCursor C) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void *(CXCursor)>::type>(
                  &clang_Cursor_getModule),
              C);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getModule(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getModule(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getModule"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getModule

using Entity_clang_Cursor_getModule = Bind_clang_Cursor_getModule<>;

#else

struct Entity_clang_Cursor_getModule : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getModule(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getModule"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getModule

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getNumArguments : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the number of non-variadic arguments associated with a given
 * cursor.
 *
 * The number of arguments can be determined for calls as well as for
 * declarations of functions or methods. For other cursors -1 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getNumArguments_AddFunction
    handle.def("clang_Cursor_getNumArguments",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_Cursor_getNumArguments),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getNumArguments(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getNumArguments(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getNumArguments"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getNumArguments

using Entity_clang_Cursor_getNumArguments = Bind_clang_Cursor_getNumArguments<>;

#else

struct Entity_clang_Cursor_getNumArguments
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getNumArguments(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getNumArguments"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getNumArguments

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getNumTemplateArguments : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the number of template args of a function, struct, or class decl
 * representing a template specialization.
 *
 * If the argument cursor cannot be converted into a template function
 * declaration, -1 is returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * The value 3 would be returned from this call.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getNumTemplateArguments_AddFunction
    handle.def("clang_Cursor_getNumTemplateArguments",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_Cursor_getNumTemplateArguments),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getNumTemplateArguments(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getNumTemplateArguments(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getNumTemplateArguments"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getNumTemplateArguments

using Entity_clang_Cursor_getNumTemplateArguments =
    Bind_clang_Cursor_getNumTemplateArguments<>;

#else

struct Entity_clang_Cursor_getNumTemplateArguments
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getNumTemplateArguments(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getNumTemplateArguments"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getNumTemplateArguments

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getObjCDeclQualifiers : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents an Objective-C method or parameter
 * declaration, return the associated Objective-C qualifiers for the return
 * type or the parameter respectively. The bits are formed from
 * CXObjCDeclQualifierKind.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getObjCDeclQualifiers_AddFunction
    handle.def("clang_Cursor_getObjCDeclQualifiers",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_getObjCDeclQualifiers),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getObjCDeclQualifiers(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getObjCDeclQualifiers(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getObjCDeclQualifiers"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCDeclQualifiers

using Entity_clang_Cursor_getObjCDeclQualifiers =
    Bind_clang_Cursor_getObjCDeclQualifiers<>;

#else

struct Entity_clang_Cursor_getObjCDeclQualifiers
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getObjCDeclQualifiers(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getObjCDeclQualifiers"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCDeclQualifiers

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getObjCManglings : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the CXStrings representing the mangled symbols of the ObjC
 * class interface or implementation at the cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getObjCManglings_AddFunction
    handle.def(
        "clang_Cursor_getObjCManglings",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXStringSet *(CXCursor)>::type>(
            &clang_Cursor_getObjCManglings),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getObjCManglings(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getObjCManglings(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getObjCManglings"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCManglings

using Entity_clang_Cursor_getObjCManglings =
    Bind_clang_Cursor_getObjCManglings<>;

#else

struct Entity_clang_Cursor_getObjCManglings
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getObjCManglings(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getObjCManglings"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCManglings

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getObjCPropertyAttributes : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a property declaration, return the
 * associated property attributes. The bits are formed from
 * \c CXObjCPropertyAttrKind.
 *
 * \param reserved Reserved for future use, pass 0.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getObjCPropertyAttributes_AddFunction
    handle.def("clang_Cursor_getObjCPropertyAttributes",
               static_cast<pybind11_weaver::FnPtrT<
                   void, unsigned int(CXCursor, unsigned int)>::type>(
                   &clang_Cursor_getObjCPropertyAttributes),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getObjCPropertyAttributes(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getObjCPropertyAttributes(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getObjCPropertyAttributes"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCPropertyAttributes

using Entity_clang_Cursor_getObjCPropertyAttributes =
    Bind_clang_Cursor_getObjCPropertyAttributes<>;

#else

struct Entity_clang_Cursor_getObjCPropertyAttributes
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getObjCPropertyAttributes(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_Cursor_getObjCPropertyAttributes"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCPropertyAttributes

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getObjCPropertyGetterName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a property declaration, return the
 * name of the method that implements the getter.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getObjCPropertyGetterName_AddFunction
    handle.def(
        "clang_Cursor_getObjCPropertyGetterName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_Cursor_getObjCPropertyGetterName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getObjCPropertyGetterName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getObjCPropertyGetterName(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getObjCPropertyGetterName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCPropertyGetterName

using Entity_clang_Cursor_getObjCPropertyGetterName =
    Bind_clang_Cursor_getObjCPropertyGetterName<>;

#else

struct Entity_clang_Cursor_getObjCPropertyGetterName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getObjCPropertyGetterName(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_Cursor_getObjCPropertyGetterName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCPropertyGetterName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getObjCPropertySetterName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a property declaration, return the
 * name of the method that implements the setter, if any.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getObjCPropertySetterName_AddFunction
    handle.def(
        "clang_Cursor_getObjCPropertySetterName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_Cursor_getObjCPropertySetterName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getObjCPropertySetterName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getObjCPropertySetterName(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getObjCPropertySetterName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCPropertySetterName

using Entity_clang_Cursor_getObjCPropertySetterName =
    Bind_clang_Cursor_getObjCPropertySetterName<>;

#else

struct Entity_clang_Cursor_getObjCPropertySetterName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getObjCPropertySetterName(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_Cursor_getObjCPropertySetterName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCPropertySetterName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getObjCSelectorIndex : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * If the cursor points to a selector identifier in an Objective-C
 * method or message expression, this returns the selector index.
 *
 * After getting a cursor with #clang_getCursor, this can be called to
 * determine if the location points to a selector identifier.
 *
 * \returns The selector index if the cursor is an Objective-C method or message
 * expression and the cursor is pointing to a selector identifier, or -1
 * otherwise.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getObjCSelectorIndex_AddFunction
    handle.def("clang_Cursor_getObjCSelectorIndex",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_Cursor_getObjCSelectorIndex),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getObjCSelectorIndex(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getObjCSelectorIndex(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getObjCSelectorIndex"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCSelectorIndex

using Entity_clang_Cursor_getObjCSelectorIndex =
    Bind_clang_Cursor_getObjCSelectorIndex<>;

#else

struct Entity_clang_Cursor_getObjCSelectorIndex
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getObjCSelectorIndex(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getObjCSelectorIndex"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getObjCSelectorIndex

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getOffsetOfField : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the offset of the field represented by the Cursor.
 *
 * If the cursor is not a field declaration, -1 is returned.
 * If the cursor semantic parent is not a record field declaration,
 *   CXTypeLayoutError_Invalid is returned.
 * If the field's type declaration is an incomplete type,
 *   CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 *   CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 *   CXTypeLayoutError_InvalidFieldName is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getOffsetOfField_AddFunction
    handle.def(
        "clang_Cursor_getOffsetOfField",
        static_cast<pybind11_weaver::FnPtrT<void, long long(CXCursor)>::type>(
            &clang_Cursor_getOffsetOfField),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getOffsetOfField(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getOffsetOfField(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getOffsetOfField"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getOffsetOfField

using Entity_clang_Cursor_getOffsetOfField =
    Bind_clang_Cursor_getOffsetOfField<>;

#else

struct Entity_clang_Cursor_getOffsetOfField
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getOffsetOfField(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getOffsetOfField"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getOffsetOfField

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getParsedComment : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a documentable entity (e.g.,
 * declaration), return the associated parsed comment as a
 * \c CXComment_FullComment AST node.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getParsedComment_AddFunction
    handle.def(
        "clang_Cursor_getParsedComment",
        static_cast<pybind11_weaver::FnPtrT<void, CXComment(CXCursor)>::type>(
            &clang_Cursor_getParsedComment),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getParsedComment(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getParsedComment(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getParsedComment"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getParsedComment

using Entity_clang_Cursor_getParsedComment =
    Bind_clang_Cursor_getParsedComment<>;

#else

struct Entity_clang_Cursor_getParsedComment
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getParsedComment(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getParsedComment"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getParsedComment

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getRawCommentText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a declaration, return the associated
 * comment text, including comment markers.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getRawCommentText_AddFunction
    handle.def(
        "clang_Cursor_getRawCommentText",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_Cursor_getRawCommentText),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getRawCommentText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getRawCommentText(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getRawCommentText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getRawCommentText

using Entity_clang_Cursor_getRawCommentText =
    Bind_clang_Cursor_getRawCommentText<>;

#else

struct Entity_clang_Cursor_getRawCommentText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getRawCommentText(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getRawCommentText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getRawCommentText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getReceiverType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor pointing to an Objective-C message or property
 * reference, or C++ method call, returns the CXType of the receiver.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getReceiverType_AddFunction
    handle.def(
        "clang_Cursor_getReceiverType",
        static_cast<pybind11_weaver::FnPtrT<void, CXType(CXCursor)>::type>(
            &clang_Cursor_getReceiverType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getReceiverType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getReceiverType(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getReceiverType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getReceiverType

using Entity_clang_Cursor_getReceiverType = Bind_clang_Cursor_getReceiverType<>;

#else

struct Entity_clang_Cursor_getReceiverType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getReceiverType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getReceiverType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getReceiverType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getSpellingNameRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a range for a piece that forms the cursors spelling name.
 * Most of the times there is only one range for the complete spelling but for
 * Objective-C methods and Objective-C message expressions, there are multiple
 * pieces for each selector identifier.
 *
 * \param pieceIndex the index of the spelling name piece. If this is greater
 * than the actual number of pieces, it will return a NULL (invalid) range.
 *
 * \param options Reserved.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getSpellingNameRange_AddFunction
    handle.def(
        "clang_Cursor_getSpellingNameRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, CXSourceRange(CXCursor, unsigned int, unsigned int)>::type>(
            &clang_Cursor_getSpellingNameRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getSpellingNameRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getSpellingNameRange(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getSpellingNameRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getSpellingNameRange

using Entity_clang_Cursor_getSpellingNameRange =
    Bind_clang_Cursor_getSpellingNameRange<>;

#else

struct Entity_clang_Cursor_getSpellingNameRange
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getSpellingNameRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getSpellingNameRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getSpellingNameRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getStorageClass : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the storage class for a function or variable declaration.
 *
 * If the passed in Cursor is not a function or variable declaration,
 * CX_SC_Invalid is returned else the storage class.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getStorageClass_AddFunction
    handle.def(
        "clang_Cursor_getStorageClass",
        static_cast<
            pybind11_weaver::FnPtrT<void, CX_StorageClass(CXCursor)>::type>(
            &clang_Cursor_getStorageClass),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getStorageClass(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getStorageClass(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getStorageClass"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getStorageClass

using Entity_clang_Cursor_getStorageClass = Bind_clang_Cursor_getStorageClass<>;

#else

struct Entity_clang_Cursor_getStorageClass
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getStorageClass(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getStorageClass"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getStorageClass

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getTemplateArgumentKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the kind of the I'th template argument of the CXCursor C.
 *
 * If the argument CXCursor does not represent a FunctionDecl, StructDecl, or
 * ClassTemplatePartialSpecialization, an invalid template argument kind is
 * returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,
 * respectively.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getTemplateArgumentKind_AddFunction
    handle.def("clang_Cursor_getTemplateArgumentKind",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXTemplateArgumentKind(CXCursor, unsigned int)>::type>(
                   &clang_Cursor_getTemplateArgumentKind),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getTemplateArgumentKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getTemplateArgumentKind(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getTemplateArgumentKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentKind

using Entity_clang_Cursor_getTemplateArgumentKind =
    Bind_clang_Cursor_getTemplateArgumentKind<>;

#else

struct Entity_clang_Cursor_getTemplateArgumentKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getTemplateArgumentKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getTemplateArgumentKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getTemplateArgumentType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a CXType representing the type of a TemplateArgument of a
 *  function decl representing a template specialization.
 *
 * If the argument CXCursor does not represent a FunctionDecl, StructDecl,
 * ClassDecl or ClassTemplatePartialSpecialization whose I'th template argument
 * has a kind of CXTemplateArgKind_Integral, an invalid type is returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * If called with I = 0, "float", will be returned.
 * Invalid types will be returned for I == 1 or 2.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getTemplateArgumentType_AddFunction
    handle.def(
        "clang_Cursor_getTemplateArgumentType",
        static_cast<pybind11_weaver::FnPtrT<void, CXType(CXCursor,
                                                         unsigned int)>::type>(
            &clang_Cursor_getTemplateArgumentType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getTemplateArgumentType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getTemplateArgumentType(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getTemplateArgumentType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentType

using Entity_clang_Cursor_getTemplateArgumentType =
    Bind_clang_Cursor_getTemplateArgumentType<>;

#else

struct Entity_clang_Cursor_getTemplateArgumentType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getTemplateArgumentType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getTemplateArgumentType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getTemplateArgumentUnsignedValue : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the value of an Integral TemplateArgument (of a function
 *  decl representing a template specialization) as an unsigned long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization or
 * whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, 2147483649, true>();
 *
 * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getTemplateArgumentUnsignedValue_AddFunction
    handle.def("clang_Cursor_getTemplateArgumentUnsignedValue",
               static_cast<pybind11_weaver::FnPtrT<
                   void, unsigned long long(CXCursor, unsigned int)>::type>(
                   &clang_Cursor_getTemplateArgumentUnsignedValue),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getTemplateArgumentUnsignedValue(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getTemplateArgumentUnsignedValue(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_Cursor_getTemplateArgumentUnsignedValue";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentUnsignedValue

using Entity_clang_Cursor_getTemplateArgumentUnsignedValue =
    Bind_clang_Cursor_getTemplateArgumentUnsignedValue<>;

#else

struct Entity_clang_Cursor_getTemplateArgumentUnsignedValue
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getTemplateArgumentUnsignedValue(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_Cursor_getTemplateArgumentUnsignedValue";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentUnsignedValue

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getTemplateArgumentValue : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the value of an Integral TemplateArgument (of a function
 *  decl representing a template specialization) as a signed long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization
 * whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * If called with I = 1 or 2, -7 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getTemplateArgumentValue_AddFunction
    handle.def("clang_Cursor_getTemplateArgumentValue",
               static_cast<pybind11_weaver::FnPtrT<
                   void, long long(CXCursor, unsigned int)>::type>(
                   &clang_Cursor_getTemplateArgumentValue),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getTemplateArgumentValue(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getTemplateArgumentValue(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getTemplateArgumentValue"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentValue

using Entity_clang_Cursor_getTemplateArgumentValue =
    Bind_clang_Cursor_getTemplateArgumentValue<>;

#else

struct Entity_clang_Cursor_getTemplateArgumentValue
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getTemplateArgumentValue(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getTemplateArgumentValue"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTemplateArgumentValue

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the translation unit that a cursor originated from.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getTranslationUnit_AddFunction
    handle.def(
        "clang_Cursor_getTranslationUnit",
        [](CXCursor arg0) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, CXTranslationUnitImpl *(
                                                            CXCursor)>::type>(
                  &clang_Cursor_getTranslationUnit),
              arg0);
          return pybind11_weaver::WrapP<CXTranslationUnitImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getTranslationUnit(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTranslationUnit

using Entity_clang_Cursor_getTranslationUnit =
    Bind_clang_Cursor_getTranslationUnit<>;

#else

struct Entity_clang_Cursor_getTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_getVarDeclInitializer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * If cursor refers to a variable declaration and it has initializer returns
 * cursor referring to the initializer otherwise return null cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_getVarDeclInitializer_AddFunction
    handle.def(
        "clang_Cursor_getVarDeclInitializer",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXCursor)>::type>(
            &clang_Cursor_getVarDeclInitializer),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_getVarDeclInitializer(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_getVarDeclInitializer(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_getVarDeclInitializer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_getVarDeclInitializer

using Entity_clang_Cursor_getVarDeclInitializer =
    Bind_clang_Cursor_getVarDeclInitializer<>;

#else

struct Entity_clang_Cursor_getVarDeclInitializer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_getVarDeclInitializer(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_getVarDeclInitializer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_getVarDeclInitializer

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_hasAttrs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor has any attributes.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_hasAttrs_AddFunction
    handle.def("clang_Cursor_hasAttrs",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_hasAttrs),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_hasAttrs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_hasAttrs(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_hasAttrs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_hasAttrs

using Entity_clang_Cursor_hasAttrs = Bind_clang_Cursor_hasAttrs<>;

#else

struct Entity_clang_Cursor_hasAttrs : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_hasAttrs(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_hasAttrs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_hasAttrs

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_hasVarDeclExternalStorage : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * If cursor refers to a variable declaration that has external storage
 * returns 1. If cursor refers to a variable declaration that doesn't have
 * external storage returns 0. Otherwise returns -1.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_hasVarDeclExternalStorage_AddFunction
    handle.def("clang_Cursor_hasVarDeclExternalStorage",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_Cursor_hasVarDeclExternalStorage),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_hasVarDeclExternalStorage(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_hasVarDeclExternalStorage(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_hasVarDeclExternalStorage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_hasVarDeclExternalStorage

using Entity_clang_Cursor_hasVarDeclExternalStorage =
    Bind_clang_Cursor_hasVarDeclExternalStorage<>;

#else

struct Entity_clang_Cursor_hasVarDeclExternalStorage
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_hasVarDeclExternalStorage(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_Cursor_hasVarDeclExternalStorage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_hasVarDeclExternalStorage

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_hasVarDeclGlobalStorage : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * If cursor refers to a variable declaration that has global storage returns 1.
 * If cursor refers to a variable declaration that doesn't have global storage
 * returns 0. Otherwise returns -1.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_hasVarDeclGlobalStorage_AddFunction
    handle.def("clang_Cursor_hasVarDeclGlobalStorage",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_Cursor_hasVarDeclGlobalStorage),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_hasVarDeclGlobalStorage(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_hasVarDeclGlobalStorage(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_hasVarDeclGlobalStorage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_hasVarDeclGlobalStorage

using Entity_clang_Cursor_hasVarDeclGlobalStorage =
    Bind_clang_Cursor_hasVarDeclGlobalStorage<>;

#else

struct Entity_clang_Cursor_hasVarDeclGlobalStorage
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_hasVarDeclGlobalStorage(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_hasVarDeclGlobalStorage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_hasVarDeclGlobalStorage

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isAnonymous : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor represents an anonymous
 * tag or namespace
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isAnonymous_AddFunction
    handle.def("clang_Cursor_isAnonymous",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isAnonymous),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isAnonymous(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isAnonymous(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isAnonymous"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isAnonymous

using Entity_clang_Cursor_isAnonymous = Bind_clang_Cursor_isAnonymous<>;

#else

struct Entity_clang_Cursor_isAnonymous
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isAnonymous(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isAnonymous"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isAnonymous

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isAnonymousRecordDecl : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor represents an anonymous record
 * declaration.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isAnonymousRecordDecl_AddFunction
    handle.def("clang_Cursor_isAnonymousRecordDecl",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isAnonymousRecordDecl),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isAnonymousRecordDecl(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isAnonymousRecordDecl(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isAnonymousRecordDecl"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isAnonymousRecordDecl

using Entity_clang_Cursor_isAnonymousRecordDecl =
    Bind_clang_Cursor_isAnonymousRecordDecl<>;

#else

struct Entity_clang_Cursor_isAnonymousRecordDecl
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isAnonymousRecordDecl(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isAnonymousRecordDecl"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isAnonymousRecordDecl

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isBitField : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if the cursor specifies a Record member that is a
 *   bitfield.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isBitField_AddFunction
    handle.def("clang_Cursor_isBitField",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isBitField),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isBitField(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isBitField(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isBitField"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isBitField

using Entity_clang_Cursor_isBitField = Bind_clang_Cursor_isBitField<>;

#else

struct Entity_clang_Cursor_isBitField : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isBitField(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isBitField"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isBitField

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isDynamicCall : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor pointing to a C++ method call or an Objective-C
 * message, returns non-zero if the method/message is "dynamic", meaning:
 *
 * For a C++ method: the call is virtual.
 * For an Objective-C message: the receiver is an object instance, not 'super'
 * or a specific class.
 *
 * If the method/message is "static" or the cursor does not point to a
 * method/message, it will return zero.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isDynamicCall_AddFunction
    handle.def("clang_Cursor_isDynamicCall",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_Cursor_isDynamicCall),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isDynamicCall(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isDynamicCall(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isDynamicCall"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isDynamicCall

using Entity_clang_Cursor_isDynamicCall = Bind_clang_Cursor_isDynamicCall<>;

#else

struct Entity_clang_Cursor_isDynamicCall
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isDynamicCall(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isDynamicCall"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isDynamicCall

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isExternalSymbol : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if the given cursor points to a symbol marked with
 * external_source_symbol attribute.
 *
 * \param language If non-NULL, and the attribute is present, will be set to
 * the 'language' string from the attribute.
 *
 * \param definedIn If non-NULL, and the attribute is present, will be set to
 * the 'definedIn' string from the attribute.
 *
 * \param isGenerated If non-NULL, and the attribute is present, will be set to
 * non-zero if the 'generated_declaration' is set in the attribute.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isExternalSymbol_AddFunction
    handle.def("clang_Cursor_isExternalSymbol",
               static_cast<pybind11_weaver::FnPtrT<
                   void, unsigned int(CXCursor, CXString *, CXString *,
                                      unsigned int *)>::type>(
                   &clang_Cursor_isExternalSymbol),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isExternalSymbol(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isExternalSymbol(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isExternalSymbol"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isExternalSymbol

using Entity_clang_Cursor_isExternalSymbol =
    Bind_clang_Cursor_isExternalSymbol<>;

#else

struct Entity_clang_Cursor_isExternalSymbol
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isExternalSymbol(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isExternalSymbol"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isExternalSymbol

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isFunctionInlined : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether a  CXCursor that is a function declaration, is an
 * inline declaration.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isFunctionInlined_AddFunction
    handle.def("clang_Cursor_isFunctionInlined",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isFunctionInlined),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isFunctionInlined(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isFunctionInlined(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isFunctionInlined"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isFunctionInlined

using Entity_clang_Cursor_isFunctionInlined =
    Bind_clang_Cursor_isFunctionInlined<>;

#else

struct Entity_clang_Cursor_isFunctionInlined
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isFunctionInlined(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isFunctionInlined"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isFunctionInlined

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isInlineNamespace : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor represents an inline namespace
 * declaration.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isInlineNamespace_AddFunction
    handle.def("clang_Cursor_isInlineNamespace",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isInlineNamespace),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isInlineNamespace(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isInlineNamespace(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isInlineNamespace"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isInlineNamespace

using Entity_clang_Cursor_isInlineNamespace =
    Bind_clang_Cursor_isInlineNamespace<>;

#else

struct Entity_clang_Cursor_isInlineNamespace
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isInlineNamespace(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isInlineNamespace"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isInlineNamespace

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isMacroBuiltin : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether a  CXCursor that is a macro, is a
 * builtin one.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isMacroBuiltin_AddFunction
    handle.def("clang_Cursor_isMacroBuiltin",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isMacroBuiltin),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isMacroBuiltin(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isMacroBuiltin(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isMacroBuiltin"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isMacroBuiltin

using Entity_clang_Cursor_isMacroBuiltin = Bind_clang_Cursor_isMacroBuiltin<>;

#else

struct Entity_clang_Cursor_isMacroBuiltin
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isMacroBuiltin(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isMacroBuiltin"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isMacroBuiltin

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isMacroFunctionLike : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether a  CXCursor that is a macro, is
 * function like.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isMacroFunctionLike_AddFunction
    handle.def("clang_Cursor_isMacroFunctionLike",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isMacroFunctionLike),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isMacroFunctionLike(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isMacroFunctionLike(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isMacroFunctionLike"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isMacroFunctionLike

using Entity_clang_Cursor_isMacroFunctionLike =
    Bind_clang_Cursor_isMacroFunctionLike<>;

#else

struct Entity_clang_Cursor_isMacroFunctionLike
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isMacroFunctionLike(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isMacroFunctionLike"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isMacroFunctionLike

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isNull : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if \p cursor is null.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isNull_AddFunction
    handle.def("clang_Cursor_isNull",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_Cursor_isNull),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isNull(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isNull(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isNull"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isNull

using Entity_clang_Cursor_isNull = Bind_clang_Cursor_isNull<>;

#else

struct Entity_clang_Cursor_isNull : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isNull(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isNull"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isNull

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isObjCOptional : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents an Objective-C method or property
 * declaration, return non-zero if the declaration was affected by "\@optional".
 * Returns zero if the cursor is not such a declaration or it is "\@required".
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isObjCOptional_AddFunction
    handle.def("clang_Cursor_isObjCOptional",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isObjCOptional),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isObjCOptional(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isObjCOptional(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isObjCOptional"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isObjCOptional

using Entity_clang_Cursor_isObjCOptional = Bind_clang_Cursor_isObjCOptional<>;

#else

struct Entity_clang_Cursor_isObjCOptional
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isObjCOptional(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isObjCOptional"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isObjCOptional

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Cursor_isVariadic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if the given cursor is a variadic function or method.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Cursor_isVariadic_AddFunction
    handle.def("clang_Cursor_isVariadic",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_Cursor_isVariadic),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Cursor_isVariadic(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Cursor_isVariadic(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Cursor_isVariadic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Cursor_isVariadic

using Entity_clang_Cursor_isVariadic = Bind_clang_Cursor_isVariadic<>;

#else

struct Entity_clang_Cursor_isVariadic : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Cursor_isVariadic(EntityScope parent_h) {}
  static const char *Key() { return "clang_Cursor_isVariadic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Cursor_isVariadic

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EnumDecl_isScoped : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if an enum declaration refers to a scoped enum.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EnumDecl_isScoped_AddFunction
    handle.def("clang_EnumDecl_isScoped",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_EnumDecl_isScoped),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EnumDecl_isScoped(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EnumDecl_isScoped(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EnumDecl_isScoped"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EnumDecl_isScoped

using Entity_clang_EnumDecl_isScoped = Bind_clang_EnumDecl_isScoped<>;

#else

struct Entity_clang_EnumDecl_isScoped : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EnumDecl_isScoped(EntityScope parent_h) {}
  static const char *Key() { return "clang_EnumDecl_isScoped"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EnumDecl_isScoped

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Disposes the created Eval memory.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_dispose_AddFunction
    handle.def(
        "clang_EvalResult_dispose",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_EvalResult_dispose),
              (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_dispose(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_dispose

using Entity_clang_EvalResult_dispose = Bind_clang_EvalResult_dispose<>;

#else

struct Entity_clang_EvalResult_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_getAsDouble : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the evaluation result as double if the
 * kind is double.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_getAsDouble_AddFunction
    handle.def(
        "clang_EvalResult_getAsDouble",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, double(void *)>::type>(
                  &clang_EvalResult_getAsDouble),
              (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_getAsDouble(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_getAsDouble(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_getAsDouble"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsDouble

using Entity_clang_EvalResult_getAsDouble = Bind_clang_EvalResult_getAsDouble<>;

#else

struct Entity_clang_EvalResult_getAsDouble
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_getAsDouble(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_getAsDouble"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsDouble

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_getAsInt : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the evaluation result as integer if the
 * kind is Int.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_getAsInt_AddFunction
    handle.def(
        "clang_EvalResult_getAsInt",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, int(void *)>::type>(
                  &clang_EvalResult_getAsInt),
              (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_getAsInt(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_getAsInt(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_getAsInt"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsInt

using Entity_clang_EvalResult_getAsInt = Bind_clang_EvalResult_getAsInt<>;

#else

struct Entity_clang_EvalResult_getAsInt
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_getAsInt(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_getAsInt"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsInt

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_getAsLongLong : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the evaluation result as a long long integer if the
 * kind is Int. This prevents overflows that may happen if the result is
 * returned with clang_EvalResult_getAsInt.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_getAsLongLong_AddFunction
    handle.def(
        "clang_EvalResult_getAsLongLong",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, long long(void *)>::type>(
                  &clang_EvalResult_getAsLongLong),
              (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_getAsLongLong(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_getAsLongLong(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_getAsLongLong"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsLongLong

using Entity_clang_EvalResult_getAsLongLong =
    Bind_clang_EvalResult_getAsLongLong<>;

#else

struct Entity_clang_EvalResult_getAsLongLong
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_getAsLongLong(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_getAsLongLong"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsLongLong

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_getAsStr : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the evaluation result as a constant string if the
 * kind is other than Int or float. User must not free this pointer,
 * instead call clang_EvalResult_dispose on the CXEvalResult returned
 * by clang_Cursor_Evaluate.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_getAsStr_AddFunction
    handle.def(
        "clang_EvalResult_getAsStr",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, const char *(void *)>::type>(
                  &clang_EvalResult_getAsStr),
              (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_getAsStr(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_getAsStr(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_getAsStr"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsStr

using Entity_clang_EvalResult_getAsStr = Bind_clang_EvalResult_getAsStr<>;

#else

struct Entity_clang_EvalResult_getAsStr
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_getAsStr(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_getAsStr"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsStr

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_getAsUnsigned : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the evaluation result as an unsigned integer if
 * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_getAsUnsigned_AddFunction
    handle.def(
        "clang_EvalResult_getAsUnsigned",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, unsigned long long(void *)>::type>(
                                 &clang_EvalResult_getAsUnsigned),
                             (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_getAsUnsigned(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_getAsUnsigned(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_getAsUnsigned"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsUnsigned

using Entity_clang_EvalResult_getAsUnsigned =
    Bind_clang_EvalResult_getAsUnsigned<>;

#else

struct Entity_clang_EvalResult_getAsUnsigned
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_getAsUnsigned(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_getAsUnsigned"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getAsUnsigned

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_getKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the kind of the evaluated result.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_getKind_AddFunction
    handle.def(
        "clang_EvalResult_getKind",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXEvalResultKind(void *)>::type>(
                                 &clang_EvalResult_getKind),
                             (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_getKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_getKind(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_getKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getKind

using Entity_clang_EvalResult_getKind = Bind_clang_EvalResult_getKind<>;

#else

struct Entity_clang_EvalResult_getKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_getKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_getKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_getKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_EvalResult_isUnsignedInt : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns a non-zero value if the kind is Int and the evaluation
 * result resulted in an unsigned integer.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_EvalResult_isUnsignedInt_AddFunction
    handle.def(
        "clang_EvalResult_isUnsignedInt",
        [](pybind11_weaver::WrappedPtrT<void *> E) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_EvalResult_isUnsignedInt),
              (E)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_EvalResult_isUnsignedInt(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_EvalResult_isUnsignedInt(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_EvalResult_isUnsignedInt"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_EvalResult_isUnsignedInt

using Entity_clang_EvalResult_isUnsignedInt =
    Bind_clang_EvalResult_isUnsignedInt<>;

#else

struct Entity_clang_EvalResult_isUnsignedInt
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_EvalResult_isUnsignedInt(EntityScope parent_h) {}
  static const char *Key() { return "clang_EvalResult_isUnsignedInt"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_EvalResult_isUnsignedInt

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_File_isEqual : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if the \c file1 and \c file2 point to the same file,
 * or they are both NULL.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_File_isEqual_AddFunction
    handle.def(
        "clang_File_isEqual",
        [](pybind11_weaver::WrappedPtrT<void *> file1,
           pybind11_weaver::WrappedPtrT<void *> file2) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, int(void *, void *)>::type>(
                  &clang_File_isEqual),
              (file1)->Cptr(), (file2)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_File_isEqual(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_File_isEqual(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_File_isEqual"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_File_isEqual

using Entity_clang_File_isEqual = Bind_clang_File_isEqual<>;

#else

struct Entity_clang_File_isEqual : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_File_isEqual(EntityScope parent_h) {}
  static const char *Key() { return "clang_File_isEqual"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_File_isEqual

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_File_tryGetRealPathName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the real path name of \c file.
 *
 * An empty string may be returned. Use \c clang_getFileName() in that case.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_File_tryGetRealPathName_AddFunction
    handle.def(
        "clang_File_tryGetRealPathName",
        [](pybind11_weaver::WrappedPtrT<void *> file) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_File_tryGetRealPathName),
              (file)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_File_tryGetRealPathName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_File_tryGetRealPathName(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_File_tryGetRealPathName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_File_tryGetRealPathName

using Entity_clang_File_tryGetRealPathName =
    Bind_clang_File_tryGetRealPathName<>;

#else

struct Entity_clang_File_tryGetRealPathName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_File_tryGetRealPathName(EntityScope parent_h) {}
  static const char *Key() { return "clang_File_tryGetRealPathName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_File_tryGetRealPathName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_FullComment_getAsHTML : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Convert a given full parsed comment to an HTML fragment.
 *
 * Specific details of HTML layout are subject to change.  Don't try to parse
 * this HTML back into an AST, use other APIs instead.
 *
 * Currently the following CSS classes are used:
 * \li "para-brief" for \paragraph and equivalent commands;
 * \li "para-returns" for \\returns paragraph and equivalent commands;
 * \li "word-returns" for the "Returns" word in \\returns paragraph.
 *
 * Function argument documentation is rendered as a \<dl\> list with arguments
 * sorted in function prototype order.  CSS classes used:
 * \li "param-name-index-NUMBER" for parameter name (\<dt\>);
 * \li "param-descr-index-NUMBER" for parameter description (\<dd\>);
 * \li "param-name-index-invalid" and "param-descr-index-invalid" are used if
 * parameter index is invalid.
 *
 * Template parameter documentation is rendered as a \<dl\> list with
 * parameters sorted in template parameter list order.  CSS classes used:
 * \li "tparam-name-index-NUMBER" for parameter name (\<dt\>);
 * \li "tparam-descr-index-NUMBER" for parameter description (\<dd\>);
 * \li "tparam-name-index-other" and "tparam-descr-index-other" are used for
 * names inside template template parameters;
 * \li "tparam-name-index-invalid" and "tparam-descr-index-invalid" are used if
 * parameter position is invalid.
 *
 * \param Comment a \c CXComment_FullComment AST node.
 *
 * \returns string containing an HTML fragment.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_FullComment_getAsHTML_AddFunction
    handle.def(
        "clang_FullComment_getAsHTML",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_FullComment_getAsHTML),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_FullComment_getAsHTML(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_FullComment_getAsHTML(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_FullComment_getAsHTML"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_FullComment_getAsHTML

using Entity_clang_FullComment_getAsHTML = Bind_clang_FullComment_getAsHTML<>;

#else

struct Entity_clang_FullComment_getAsHTML
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_FullComment_getAsHTML(EntityScope parent_h) {}
  static const char *Key() { return "clang_FullComment_getAsHTML"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_FullComment_getAsHTML

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_FullComment_getAsXML : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Convert a given full parsed comment to an XML document.
 *
 * A Relax NG schema for the XML can be found in comment-xml-schema.rng file
 * inside clang source tree.
 *
 * \param Comment a \c CXComment_FullComment AST node.
 *
 * \returns string containing an XML document.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_FullComment_getAsXML_AddFunction
    handle.def(
        "clang_FullComment_getAsXML",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_FullComment_getAsXML),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_FullComment_getAsXML(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_FullComment_getAsXML(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_FullComment_getAsXML"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_FullComment_getAsXML

using Entity_clang_FullComment_getAsXML = Bind_clang_FullComment_getAsXML<>;

#else

struct Entity_clang_FullComment_getAsXML
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_FullComment_getAsXML(EntityScope parent_h) {}
  static const char *Key() { return "clang_FullComment_getAsXML"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_FullComment_getAsXML

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_HTMLStartTagComment_isSelfClosing : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \returns non-zero if tag is self-closing (for example, &lt;br /&gt;).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_HTMLStartTagComment_isSelfClosing_AddFunction
    handle.def(
        "clang_HTMLStartTagComment_isSelfClosing",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_HTMLStartTagComment_isSelfClosing),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_HTMLStartTagComment_isSelfClosing(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_HTMLStartTagComment_isSelfClosing(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_HTMLStartTagComment_isSelfClosing"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTagComment_isSelfClosing

using Entity_clang_HTMLStartTagComment_isSelfClosing =
    Bind_clang_HTMLStartTagComment_isSelfClosing<>;

#else

struct Entity_clang_HTMLStartTagComment_isSelfClosing
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_HTMLStartTagComment_isSelfClosing(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_HTMLStartTagComment_isSelfClosing"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTagComment_isSelfClosing

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_HTMLStartTag_getAttrName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \param AttrIdx attribute index (zero-based).
 *
 * \returns name of the specified attribute.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_HTMLStartTag_getAttrName_AddFunction
    handle.def("clang_HTMLStartTag_getAttrName",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(CXComment, unsigned int)>::type>(
                   &clang_HTMLStartTag_getAttrName),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_HTMLStartTag_getAttrName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_HTMLStartTag_getAttrName(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_HTMLStartTag_getAttrName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTag_getAttrName

using Entity_clang_HTMLStartTag_getAttrName =
    Bind_clang_HTMLStartTag_getAttrName<>;

#else

struct Entity_clang_HTMLStartTag_getAttrName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_HTMLStartTag_getAttrName(EntityScope parent_h) {}
  static const char *Key() { return "clang_HTMLStartTag_getAttrName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTag_getAttrName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_HTMLStartTag_getAttrValue : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \param AttrIdx attribute index (zero-based).
 *
 * \returns value of the specified attribute.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_HTMLStartTag_getAttrValue_AddFunction
    handle.def("clang_HTMLStartTag_getAttrValue",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(CXComment, unsigned int)>::type>(
                   &clang_HTMLStartTag_getAttrValue),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_HTMLStartTag_getAttrValue(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_HTMLStartTag_getAttrValue(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_HTMLStartTag_getAttrValue"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTag_getAttrValue

using Entity_clang_HTMLStartTag_getAttrValue =
    Bind_clang_HTMLStartTag_getAttrValue<>;

#else

struct Entity_clang_HTMLStartTag_getAttrValue
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_HTMLStartTag_getAttrValue(EntityScope parent_h) {}
  static const char *Key() { return "clang_HTMLStartTag_getAttrValue"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTag_getAttrValue

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_HTMLStartTag_getNumAttrs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \returns number of attributes (name-value pairs) attached to the start tag.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_HTMLStartTag_getNumAttrs_AddFunction
    handle.def(
        "clang_HTMLStartTag_getNumAttrs",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_HTMLStartTag_getNumAttrs),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_HTMLStartTag_getNumAttrs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_HTMLStartTag_getNumAttrs(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_HTMLStartTag_getNumAttrs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTag_getNumAttrs

using Entity_clang_HTMLStartTag_getNumAttrs =
    Bind_clang_HTMLStartTag_getNumAttrs<>;

#else

struct Entity_clang_HTMLStartTag_getNumAttrs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_HTMLStartTag_getNumAttrs(EntityScope parent_h) {}
  static const char *Key() { return "clang_HTMLStartTag_getNumAttrs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_HTMLStartTag_getNumAttrs

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_HTMLTagComment_getAsString : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Convert an HTML tag AST node to string.
 *
 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST
 * node.
 *
 * \returns string containing an HTML tag.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_HTMLTagComment_getAsString_AddFunction
    handle.def(
        "clang_HTMLTagComment_getAsString",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_HTMLTagComment_getAsString),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_HTMLTagComment_getAsString(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_HTMLTagComment_getAsString(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_HTMLTagComment_getAsString"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_HTMLTagComment_getAsString

using Entity_clang_HTMLTagComment_getAsString =
    Bind_clang_HTMLTagComment_getAsString<>;

#else

struct Entity_clang_HTMLTagComment_getAsString
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_HTMLTagComment_getAsString(EntityScope parent_h) {}
  static const char *Key() { return "clang_HTMLTagComment_getAsString"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_HTMLTagComment_getAsString

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_HTMLTagComment_getTagName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST
 * node.
 *
 * \returns HTML tag name.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_HTMLTagComment_getTagName_AddFunction
    handle.def(
        "clang_HTMLTagComment_getTagName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_HTMLTagComment_getTagName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_HTMLTagComment_getTagName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_HTMLTagComment_getTagName(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_HTMLTagComment_getTagName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_HTMLTagComment_getTagName

using Entity_clang_HTMLTagComment_getTagName =
    Bind_clang_HTMLTagComment_getTagName<>;

#else

struct Entity_clang_HTMLTagComment_getTagName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_HTMLTagComment_getTagName(EntityScope parent_h) {}
  static const char *Key() { return "clang_HTMLTagComment_getTagName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_HTMLTagComment_getTagName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_IndexAction_create : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * An indexing action/session, to be applied to one or multiple
 * translation units.
 *
 * \param CIdx The index object with which the index action will be associated.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_IndexAction_create_AddFunction
    handle.def(
        "clang_IndexAction_create",
        [](pybind11_weaver::WrappedPtrT<void *> CIdx) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void *(void *)>::type>(
                  &clang_IndexAction_create),
              (CIdx)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_IndexAction_create(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_IndexAction_create(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_IndexAction_create"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_IndexAction_create

using Entity_clang_IndexAction_create = Bind_clang_IndexAction_create<>;

#else

struct Entity_clang_IndexAction_create
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_IndexAction_create(EntityScope parent_h) {}
  static const char *Key() { return "clang_IndexAction_create"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_IndexAction_create

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_IndexAction_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Destroy the given index action.
 *
 * The index action must not be destroyed until all of the translation units
 * created within that index action have been destroyed.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_IndexAction_dispose_AddFunction
    handle.def(
        "clang_IndexAction_dispose",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_IndexAction_dispose),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_IndexAction_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_IndexAction_dispose(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_IndexAction_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_IndexAction_dispose

using Entity_clang_IndexAction_dispose = Bind_clang_IndexAction_dispose<>;

#else

struct Entity_clang_IndexAction_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_IndexAction_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_IndexAction_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_IndexAction_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_InlineCommandComment_getArgText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \param ArgIdx argument index (zero-based).
 *
 * \returns text of the specified argument.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_InlineCommandComment_getArgText_AddFunction
    handle.def("clang_InlineCommandComment_getArgText",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(CXComment, unsigned int)>::type>(
                   &clang_InlineCommandComment_getArgText),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_InlineCommandComment_getArgText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_InlineCommandComment_getArgText(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_InlineCommandComment_getArgText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getArgText

using Entity_clang_InlineCommandComment_getArgText =
    Bind_clang_InlineCommandComment_getArgText<>;

#else

struct Entity_clang_InlineCommandComment_getArgText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_InlineCommandComment_getArgText(EntityScope parent_h) {}
  static const char *Key() { return "clang_InlineCommandComment_getArgText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getArgText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_InlineCommandComment_getCommandName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns name of the inline command.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_InlineCommandComment_getCommandName_AddFunction
    handle.def(
        "clang_InlineCommandComment_getCommandName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_InlineCommandComment_getCommandName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_InlineCommandComment_getCommandName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_InlineCommandComment_getCommandName(EntityScope parent_h,
                                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_InlineCommandComment_getCommandName";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getCommandName

using Entity_clang_InlineCommandComment_getCommandName =
    Bind_clang_InlineCommandComment_getCommandName<>;

#else

struct Entity_clang_InlineCommandComment_getCommandName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_InlineCommandComment_getCommandName(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_InlineCommandComment_getCommandName";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getCommandName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_InlineCommandComment_getNumArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns number of command arguments.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_InlineCommandComment_getNumArgs_AddFunction
    handle.def(
        "clang_InlineCommandComment_getNumArgs",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_InlineCommandComment_getNumArgs),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_InlineCommandComment_getNumArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_InlineCommandComment_getNumArgs(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_InlineCommandComment_getNumArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getNumArgs

using Entity_clang_InlineCommandComment_getNumArgs =
    Bind_clang_InlineCommandComment_getNumArgs<>;

#else

struct Entity_clang_InlineCommandComment_getNumArgs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_InlineCommandComment_getNumArgs(EntityScope parent_h) {}
  static const char *Key() { return "clang_InlineCommandComment_getNumArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getNumArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_InlineCommandComment_getRenderKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns the most appropriate rendering mode, chosen on command
 * semantics in Doxygen.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_InlineCommandComment_getRenderKind_AddFunction
    handle.def("clang_InlineCommandComment_getRenderKind",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXCommentInlineCommandRenderKind(CXComment)>::type>(
                   &clang_InlineCommandComment_getRenderKind),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_InlineCommandComment_getRenderKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_InlineCommandComment_getRenderKind(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_InlineCommandComment_getRenderKind";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getRenderKind

using Entity_clang_InlineCommandComment_getRenderKind =
    Bind_clang_InlineCommandComment_getRenderKind<>;

#else

struct Entity_clang_InlineCommandComment_getRenderKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_InlineCommandComment_getRenderKind(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_InlineCommandComment_getRenderKind";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_InlineCommandComment_getRenderKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_InlineContentComment_hasTrailingNewline : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \returns non-zero if \c Comment is inline content and has a newline
 * immediately following it in the comment text.  Newlines between paragraphs
 * do not count.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_InlineContentComment_hasTrailingNewline_AddFunction
    handle.def(
        "clang_InlineContentComment_hasTrailingNewline",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_InlineContentComment_hasTrailingNewline),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_InlineContentComment_hasTrailingNewline(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_InlineContentComment_hasTrailingNewline(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_InlineContentComment_hasTrailingNewline";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_InlineContentComment_hasTrailingNewline

using Entity_clang_InlineContentComment_hasTrailingNewline =
    Bind_clang_InlineContentComment_hasTrailingNewline<>;

#else

struct Entity_clang_InlineContentComment_hasTrailingNewline
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_InlineContentComment_hasTrailingNewline(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_InlineContentComment_hasTrailingNewline";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_InlineContentComment_hasTrailingNewline

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Location_isFromMainFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if the given source location is in the main file of
 * the corresponding translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Location_isFromMainFile_AddFunction
    handle.def(
        "clang_Location_isFromMainFile",
        static_cast<pybind11_weaver::FnPtrT<void, int(CXSourceLocation)>::type>(
            &clang_Location_isFromMainFile),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Location_isFromMainFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Location_isFromMainFile(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Location_isFromMainFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Location_isFromMainFile

using Entity_clang_Location_isFromMainFile =
    Bind_clang_Location_isFromMainFile<>;

#else

struct Entity_clang_Location_isFromMainFile
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Location_isFromMainFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_Location_isFromMainFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Location_isFromMainFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Location_isInSystemHeader : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if the given source location is in a system header.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Location_isInSystemHeader_AddFunction
    handle.def(
        "clang_Location_isInSystemHeader",
        static_cast<pybind11_weaver::FnPtrT<void, int(CXSourceLocation)>::type>(
            &clang_Location_isInSystemHeader),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Location_isInSystemHeader(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Location_isInSystemHeader(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Location_isInSystemHeader"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Location_isInSystemHeader

using Entity_clang_Location_isInSystemHeader =
    Bind_clang_Location_isInSystemHeader<>;

#else

struct Entity_clang_Location_isInSystemHeader
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Location_isInSystemHeader(EntityScope parent_h) {}
  static const char *Key() { return "clang_Location_isInSystemHeader"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Location_isInSystemHeader

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ModuleMapDescriptor_create : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Create a \c CXModuleMapDescriptor object.
 * Must be disposed with \c clang_ModuleMapDescriptor_dispose().
 *
 * \param options is reserved, always pass 0.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ModuleMapDescriptor_create_AddFunction
    handle.def(
        "clang_ModuleMapDescriptor_create",
        [](unsigned int options) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXModuleMapDescriptorImpl *(unsigned int)>::type>(
                  &clang_ModuleMapDescriptor_create),
              options);
          return pybind11_weaver::WrapP<CXModuleMapDescriptorImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ModuleMapDescriptor_create(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ModuleMapDescriptor_create(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_ModuleMapDescriptor_create"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_create

using Entity_clang_ModuleMapDescriptor_create =
    Bind_clang_ModuleMapDescriptor_create<>;

#else

struct Entity_clang_ModuleMapDescriptor_create
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ModuleMapDescriptor_create(EntityScope parent_h) {}
  static const char *Key() { return "clang_ModuleMapDescriptor_create"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_create

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ModuleMapDescriptor_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Dispose a \c CXModuleMapDescriptor object.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ModuleMapDescriptor_dispose_AddFunction
    handle.def(
        "clang_ModuleMapDescriptor_dispose",
        [](pybind11_weaver::WrappedPtrT<CXModuleMapDescriptorImpl *> arg0) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXModuleMapDescriptorImpl *)>::type>(
                  &clang_ModuleMapDescriptor_dispose),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ModuleMapDescriptor_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ModuleMapDescriptor_dispose(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_ModuleMapDescriptor_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_dispose

using Entity_clang_ModuleMapDescriptor_dispose =
    Bind_clang_ModuleMapDescriptor_dispose<>;

#else

struct Entity_clang_ModuleMapDescriptor_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ModuleMapDescriptor_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_ModuleMapDescriptor_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ModuleMapDescriptor_setFrameworkModuleName
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Sets the framework module name that the module.map describes.
 * \returns 0 for success, non-zero to indicate an error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ModuleMapDescriptor_setFrameworkModuleName_AddFunction
    handle.def(
        "clang_ModuleMapDescriptor_setFrameworkModuleName",
        [](pybind11_weaver::WrappedPtrT<CXModuleMapDescriptorImpl *> arg0,
           const char *name) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXErrorCode(CXModuleMapDescriptorImpl *,
                                    const char *)>::type>(
                  &clang_ModuleMapDescriptor_setFrameworkModuleName),
              (arg0)->Cptr(), name);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ModuleMapDescriptor_setFrameworkModuleName(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ModuleMapDescriptor_setFrameworkModuleName(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_ModuleMapDescriptor_setFrameworkModuleName";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_setFrameworkModuleName

using Entity_clang_ModuleMapDescriptor_setFrameworkModuleName =
    Bind_clang_ModuleMapDescriptor_setFrameworkModuleName<>;

#else

struct Entity_clang_ModuleMapDescriptor_setFrameworkModuleName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ModuleMapDescriptor_setFrameworkModuleName(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_ModuleMapDescriptor_setFrameworkModuleName";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_setFrameworkModuleName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ModuleMapDescriptor_setUmbrellaHeader : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Sets the umbrella header name that the module.map describes.
 * \returns 0 for success, non-zero to indicate an error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ModuleMapDescriptor_setUmbrellaHeader_AddFunction
    handle.def(
        "clang_ModuleMapDescriptor_setUmbrellaHeader",
        [](pybind11_weaver::WrappedPtrT<CXModuleMapDescriptorImpl *> arg0,
           const char *name) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXErrorCode(CXModuleMapDescriptorImpl *,
                                                   const char *)>::type>(
                                 &clang_ModuleMapDescriptor_setUmbrellaHeader),
                             (arg0)->Cptr(), name);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ModuleMapDescriptor_setUmbrellaHeader(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ModuleMapDescriptor_setUmbrellaHeader(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_ModuleMapDescriptor_setUmbrellaHeader";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_setUmbrellaHeader

using Entity_clang_ModuleMapDescriptor_setUmbrellaHeader =
    Bind_clang_ModuleMapDescriptor_setUmbrellaHeader<>;

#else

struct Entity_clang_ModuleMapDescriptor_setUmbrellaHeader
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ModuleMapDescriptor_setUmbrellaHeader(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_ModuleMapDescriptor_setUmbrellaHeader";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_setUmbrellaHeader

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ModuleMapDescriptor_writeToBuffer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Write out the \c CXModuleMapDescriptor object to a char buffer.
 *
 * \param options is reserved, always pass 0.
 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be
 * disposed using \c clang_free().
 * \param out_buffer_size pointer to receive the buffer size.
 * \returns 0 for success, non-zero to indicate an error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ModuleMapDescriptor_writeToBuffer_AddFunction
    handle.def(
        "clang_ModuleMapDescriptor_writeToBuffer",
        [](pybind11_weaver::WrappedPtrT<CXModuleMapDescriptorImpl *> arg0,
           unsigned int options,
           pybind11_weaver::WrappedPtrT<char **> out_buffer_ptr,
           unsigned int *out_buffer_size) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXErrorCode(CXModuleMapDescriptorImpl *, unsigned int,
                                    char **, unsigned int *)>::type>(
                  &clang_ModuleMapDescriptor_writeToBuffer),
              (arg0)->Cptr(), options, (out_buffer_ptr)->Cptr(),
              out_buffer_size);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ModuleMapDescriptor_writeToBuffer(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ModuleMapDescriptor_writeToBuffer(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_ModuleMapDescriptor_writeToBuffer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_writeToBuffer

using Entity_clang_ModuleMapDescriptor_writeToBuffer =
    Bind_clang_ModuleMapDescriptor_writeToBuffer<>;

#else

struct Entity_clang_ModuleMapDescriptor_writeToBuffer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ModuleMapDescriptor_writeToBuffer(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_ModuleMapDescriptor_writeToBuffer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ModuleMapDescriptor_writeToBuffer

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Module_getASTFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Module a module object.
 *
 * \returns the module file where the provided module object came from.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Module_getASTFile_AddFunction
    handle.def(
        "clang_Module_getASTFile",
        [](pybind11_weaver::WrappedPtrT<void *> Module) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void *(void *)>::type>(
                  &clang_Module_getASTFile),
              (Module)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Module_getASTFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Module_getASTFile(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Module_getASTFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Module_getASTFile

using Entity_clang_Module_getASTFile = Bind_clang_Module_getASTFile<>;

#else

struct Entity_clang_Module_getASTFile : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Module_getASTFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_Module_getASTFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Module_getASTFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Module_getFullName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Module a module object.
 *
 * \returns the full name of the module, e.g. "std.vector".
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Module_getFullName_AddFunction
    handle.def(
        "clang_Module_getFullName",
        [](pybind11_weaver::WrappedPtrT<void *> Module) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_Module_getFullName),
              (Module)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Module_getFullName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Module_getFullName(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Module_getFullName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Module_getFullName

using Entity_clang_Module_getFullName = Bind_clang_Module_getFullName<>;

#else

struct Entity_clang_Module_getFullName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Module_getFullName(EntityScope parent_h) {}
  static const char *Key() { return "clang_Module_getFullName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Module_getFullName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Module_getName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Module a module object.
 *
 * \returns the name of the module, e.g. for the 'std.vector' sub-module it
 * will return "vector".
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Module_getName_AddFunction
    handle.def(
        "clang_Module_getName",
        [](pybind11_weaver::WrappedPtrT<void *> Module) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_Module_getName),
              (Module)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Module_getName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Module_getName(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Module_getName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Module_getName

using Entity_clang_Module_getName = Bind_clang_Module_getName<>;

#else

struct Entity_clang_Module_getName : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Module_getName(EntityScope parent_h) {}
  static const char *Key() { return "clang_Module_getName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Module_getName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Module_getNumTopLevelHeaders : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Module a module object.
 *
 * \returns the number of top level headers associated with this module.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Module_getNumTopLevelHeaders_AddFunction
    handle.def(
        "clang_Module_getNumTopLevelHeaders",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0,
           pybind11_weaver::WrappedPtrT<void *> Module) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXTranslationUnitImpl *, void *)>::type>(
                  &clang_Module_getNumTopLevelHeaders),
              (arg0)->Cptr(), (Module)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Module_getNumTopLevelHeaders(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Module_getNumTopLevelHeaders(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Module_getNumTopLevelHeaders"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Module_getNumTopLevelHeaders

using Entity_clang_Module_getNumTopLevelHeaders =
    Bind_clang_Module_getNumTopLevelHeaders<>;

#else

struct Entity_clang_Module_getNumTopLevelHeaders
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Module_getNumTopLevelHeaders(EntityScope parent_h) {}
  static const char *Key() { return "clang_Module_getNumTopLevelHeaders"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Module_getNumTopLevelHeaders

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Module_getParent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Module a module object.
 *
 * \returns the parent of a sub-module or NULL if the given module is top-level,
 * e.g. for 'std.vector' it will return the 'std' module.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Module_getParent_AddFunction
    handle.def(
        "clang_Module_getParent",
        [](pybind11_weaver::WrappedPtrT<void *> Module) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void *(void *)>::type>(
                  &clang_Module_getParent),
              (Module)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Module_getParent(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Module_getParent(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Module_getParent"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Module_getParent

using Entity_clang_Module_getParent = Bind_clang_Module_getParent<>;

#else

struct Entity_clang_Module_getParent : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Module_getParent(EntityScope parent_h) {}
  static const char *Key() { return "clang_Module_getParent"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Module_getParent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Module_getTopLevelHeader : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Module a module object.
 *
 * \param Index top level header index (zero-based).
 *
 * \returns the specified top level header associated with the module.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Module_getTopLevelHeader_AddFunction
    handle.def(
        "clang_Module_getTopLevelHeader",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0,
           pybind11_weaver::WrappedPtrT<void *> Module, unsigned int Index) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(CXTranslationUnitImpl *, void *,
                                           unsigned int)>::type>(
                              &clang_Module_getTopLevelHeader),
                          (arg0)->Cptr(), (Module)->Cptr(), Index);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Module_getTopLevelHeader(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Module_getTopLevelHeader(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Module_getTopLevelHeader"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Module_getTopLevelHeader

using Entity_clang_Module_getTopLevelHeader =
    Bind_clang_Module_getTopLevelHeader<>;

#else

struct Entity_clang_Module_getTopLevelHeader
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Module_getTopLevelHeader(EntityScope parent_h) {}
  static const char *Key() { return "clang_Module_getTopLevelHeader"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Module_getTopLevelHeader

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Module_isSystem : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Module a module object.
 *
 * \returns non-zero if the module is a system one.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Module_isSystem_AddFunction
    handle.def(
        "clang_Module_isSystem",
        [](pybind11_weaver::WrappedPtrT<void *> Module) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, int(void *)>::type>(
                  &clang_Module_isSystem),
              (Module)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Module_isSystem(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Module_isSystem(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Module_isSystem"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Module_isSystem

using Entity_clang_Module_isSystem = Bind_clang_Module_isSystem<>;

#else

struct Entity_clang_Module_isSystem : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Module_isSystem(EntityScope parent_h) {}
  static const char *Key() { return "clang_Module_isSystem"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Module_isSystem

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ParamCommandComment_getDirection : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns parameter passing direction.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ParamCommandComment_getDirection_AddFunction
    handle.def("clang_ParamCommandComment_getDirection",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXCommentParamPassDirection(CXComment)>::type>(
                   &clang_ParamCommandComment_getDirection),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ParamCommandComment_getDirection(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ParamCommandComment_getDirection(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_ParamCommandComment_getDirection"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_getDirection

using Entity_clang_ParamCommandComment_getDirection =
    Bind_clang_ParamCommandComment_getDirection<>;

#else

struct Entity_clang_ParamCommandComment_getDirection
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ParamCommandComment_getDirection(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_ParamCommandComment_getDirection"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_getDirection

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ParamCommandComment_getParamIndex : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns zero-based parameter index in function prototype.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ParamCommandComment_getParamIndex_AddFunction
    handle.def(
        "clang_ParamCommandComment_getParamIndex",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_ParamCommandComment_getParamIndex),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ParamCommandComment_getParamIndex(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ParamCommandComment_getParamIndex(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_ParamCommandComment_getParamIndex"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_getParamIndex

using Entity_clang_ParamCommandComment_getParamIndex =
    Bind_clang_ParamCommandComment_getParamIndex<>;

#else

struct Entity_clang_ParamCommandComment_getParamIndex
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ParamCommandComment_getParamIndex(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_ParamCommandComment_getParamIndex"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_getParamIndex

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ParamCommandComment_getParamName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns parameter name.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ParamCommandComment_getParamName_AddFunction
    handle.def(
        "clang_ParamCommandComment_getParamName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_ParamCommandComment_getParamName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ParamCommandComment_getParamName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ParamCommandComment_getParamName(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_ParamCommandComment_getParamName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_getParamName

using Entity_clang_ParamCommandComment_getParamName =
    Bind_clang_ParamCommandComment_getParamName<>;

#else

struct Entity_clang_ParamCommandComment_getParamName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ParamCommandComment_getParamName(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_ParamCommandComment_getParamName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_getParamName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ParamCommandComment_isDirectionExplicit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns non-zero if parameter passing direction was specified explicitly in
 * the comment.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ParamCommandComment_isDirectionExplicit_AddFunction
    handle.def(
        "clang_ParamCommandComment_isDirectionExplicit",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_ParamCommandComment_isDirectionExplicit),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ParamCommandComment_isDirectionExplicit(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ParamCommandComment_isDirectionExplicit(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_ParamCommandComment_isDirectionExplicit";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_isDirectionExplicit

using Entity_clang_ParamCommandComment_isDirectionExplicit =
    Bind_clang_ParamCommandComment_isDirectionExplicit<>;

#else

struct Entity_clang_ParamCommandComment_isDirectionExplicit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ParamCommandComment_isDirectionExplicit(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_ParamCommandComment_isDirectionExplicit";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_isDirectionExplicit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_ParamCommandComment_isParamIndexValid : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns non-zero if the parameter that this AST node represents was found
 * in the function prototype and \c clang_ParamCommandComment_getParamIndex
 * function will return a meaningful value.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_ParamCommandComment_isParamIndexValid_AddFunction
    handle.def(
        "clang_ParamCommandComment_isParamIndexValid",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_ParamCommandComment_isParamIndexValid),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_ParamCommandComment_isParamIndexValid(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_ParamCommandComment_isParamIndexValid(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_ParamCommandComment_isParamIndexValid";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_isParamIndexValid

using Entity_clang_ParamCommandComment_isParamIndexValid =
    Bind_clang_ParamCommandComment_isParamIndexValid<>;

#else

struct Entity_clang_ParamCommandComment_isParamIndexValid
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_ParamCommandComment_isParamIndexValid(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_ParamCommandComment_isParamIndexValid";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_ParamCommandComment_isParamIndexValid

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_PrintingPolicy_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Release a printing policy.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_PrintingPolicy_dispose_AddFunction
    handle.def(
        "clang_PrintingPolicy_dispose",
        [](pybind11_weaver::WrappedPtrT<void *> Policy) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_PrintingPolicy_dispose),
              (Policy)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_PrintingPolicy_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_PrintingPolicy_dispose(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_PrintingPolicy_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_PrintingPolicy_dispose

using Entity_clang_PrintingPolicy_dispose = Bind_clang_PrintingPolicy_dispose<>;

#else

struct Entity_clang_PrintingPolicy_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_PrintingPolicy_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_PrintingPolicy_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_PrintingPolicy_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_PrintingPolicy_getProperty : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get a property value for the given printing policy.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_PrintingPolicy_getProperty_AddFunction
    handle.def(
        "clang_PrintingPolicy_getProperty",
        [](pybind11_weaver::WrappedPtrT<void *> Policy,
           CXPrintingPolicyProperty Property) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(void *, CXPrintingPolicyProperty)>::type>(
                  &clang_PrintingPolicy_getProperty),
              (Policy)->Cptr(), Property);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_PrintingPolicy_getProperty(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_PrintingPolicy_getProperty(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_PrintingPolicy_getProperty"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_PrintingPolicy_getProperty

using Entity_clang_PrintingPolicy_getProperty =
    Bind_clang_PrintingPolicy_getProperty<>;

#else

struct Entity_clang_PrintingPolicy_getProperty
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_PrintingPolicy_getProperty(EntityScope parent_h) {}
  static const char *Key() { return "clang_PrintingPolicy_getProperty"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_PrintingPolicy_getProperty

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_PrintingPolicy_setProperty : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Set a property value for the given printing policy.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_PrintingPolicy_setProperty_AddFunction
    handle.def(
        "clang_PrintingPolicy_setProperty",
        [](pybind11_weaver::WrappedPtrT<void *> Policy,
           CXPrintingPolicyProperty Property, unsigned int Value) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, void(void *, CXPrintingPolicyProperty,
                                            unsigned int)>::type>(
                                 &clang_PrintingPolicy_setProperty),
                             (Policy)->Cptr(), Property, Value);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_PrintingPolicy_setProperty(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_PrintingPolicy_setProperty(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_PrintingPolicy_setProperty"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_PrintingPolicy_setProperty

using Entity_clang_PrintingPolicy_setProperty =
    Bind_clang_PrintingPolicy_setProperty<>;

#else

struct Entity_clang_PrintingPolicy_setProperty
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_PrintingPolicy_setProperty(EntityScope parent_h) {}
  static const char *Key() { return "clang_PrintingPolicy_setProperty"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_PrintingPolicy_setProperty

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Range_isNull : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns non-zero if \p range is null.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Range_isNull_AddFunction
    handle.def(
        "clang_Range_isNull",
        static_cast<pybind11_weaver::FnPtrT<void, int(CXSourceRange)>::type>(
            &clang_Range_isNull),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Range_isNull(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Range_isNull(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Range_isNull"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Range_isNull

using Entity_clang_Range_isNull = Bind_clang_Range_isNull<>;

#else

struct Entity_clang_Range_isNull : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Range_isNull(EntityScope parent_h) {}
  static const char *Key() { return "clang_Range_isNull"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Range_isNull

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TParamCommandComment_getDepth : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns zero-based nesting depth of this parameter in the template parameter list.
 *
 * For example,
 * \verbatim
 *     template<typename C, template<typename T> class TT>
 *     void test(TT<int> aaa);
 * \endverbatim
 * for C and TT nesting depth is 0,
 * for T nesting depth is 1.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TParamCommandComment_getDepth_AddFunction
    handle.def(
        "clang_TParamCommandComment_getDepth",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_TParamCommandComment_getDepth),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TParamCommandComment_getDepth(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TParamCommandComment_getDepth(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_TParamCommandComment_getDepth"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_getDepth

using Entity_clang_TParamCommandComment_getDepth =
    Bind_clang_TParamCommandComment_getDepth<>;

#else

struct Entity_clang_TParamCommandComment_getDepth
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TParamCommandComment_getDepth(EntityScope parent_h) {}
  static const char *Key() { return "clang_TParamCommandComment_getDepth"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_getDepth

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TParamCommandComment_getIndex : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns zero-based parameter index in the template parameter list at a
 * given nesting depth.
 *
 * For example,
 * \verbatim
 *     template<typename C, template<typename T> class TT>
 *     void test(TT<int> aaa);
 * \endverbatim
 * for C and TT nesting depth is 0, so we can ask for index at depth 0:
 * at depth 0 C's index is 0, TT's index is 1.
 *
 * For T nesting depth is 1, so we can ask for index at depth 0 and 1:
 * at depth 0 T's index is 1 (same as TT's),
 * at depth 1 T's index is 0.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TParamCommandComment_getIndex_AddFunction
    handle.def("clang_TParamCommandComment_getIndex",
               static_cast<pybind11_weaver::FnPtrT<
                   void, unsigned int(CXComment, unsigned int)>::type>(
                   &clang_TParamCommandComment_getIndex),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TParamCommandComment_getIndex(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TParamCommandComment_getIndex(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_TParamCommandComment_getIndex"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_getIndex

using Entity_clang_TParamCommandComment_getIndex =
    Bind_clang_TParamCommandComment_getIndex<>;

#else

struct Entity_clang_TParamCommandComment_getIndex
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TParamCommandComment_getIndex(EntityScope parent_h) {}
  static const char *Key() { return "clang_TParamCommandComment_getIndex"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_getIndex

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TParamCommandComment_getParamName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns template parameter name.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TParamCommandComment_getParamName_AddFunction
    handle.def(
        "clang_TParamCommandComment_getParamName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_TParamCommandComment_getParamName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TParamCommandComment_getParamName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TParamCommandComment_getParamName(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_TParamCommandComment_getParamName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_getParamName

using Entity_clang_TParamCommandComment_getParamName =
    Bind_clang_TParamCommandComment_getParamName<>;

#else

struct Entity_clang_TParamCommandComment_getParamName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TParamCommandComment_getParamName(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_TParamCommandComment_getParamName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_getParamName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TParamCommandComment_isParamPositionValid
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns non-zero if the parameter that this AST node represents was found
 * in the template parameter list and
 * \c clang_TParamCommandComment_getDepth and
 * \c clang_TParamCommandComment_getIndex functions will return a meaningful
 * value.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TParamCommandComment_isParamPositionValid_AddFunction
    handle.def(
        "clang_TParamCommandComment_isParamPositionValid",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXComment)>::type>(
            &clang_TParamCommandComment_isParamPositionValid),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TParamCommandComment_isParamPositionValid(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TParamCommandComment_isParamPositionValid(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_TParamCommandComment_isParamPositionValid";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_isParamPositionValid

using Entity_clang_TParamCommandComment_isParamPositionValid =
    Bind_clang_TParamCommandComment_isParamPositionValid<>;

#else

struct Entity_clang_TParamCommandComment_isParamPositionValid
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TParamCommandComment_isParamPositionValid(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_TParamCommandComment_isParamPositionValid";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TParamCommandComment_isParamPositionValid

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TargetInfo_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Destroy the CXTargetInfo object.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TargetInfo_dispose_AddFunction
    handle.def(
        "clang_TargetInfo_dispose",
        [](pybind11_weaver::WrappedPtrT<CXTargetInfoImpl *> Info) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, void(CXTargetInfoImpl *)>::type>(
                                 &clang_TargetInfo_dispose),
                             (Info)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TargetInfo_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TargetInfo_dispose(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_TargetInfo_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TargetInfo_dispose

using Entity_clang_TargetInfo_dispose = Bind_clang_TargetInfo_dispose<>;

#else

struct Entity_clang_TargetInfo_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TargetInfo_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_TargetInfo_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TargetInfo_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TargetInfo_getPointerWidth : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the pointer width of the target in bits.
 *
 * Returns -1 in case of error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TargetInfo_getPointerWidth_AddFunction
    handle.def(
        "clang_TargetInfo_getPointerWidth",
        [](pybind11_weaver::WrappedPtrT<CXTargetInfoImpl *> Info) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, int(CXTargetInfoImpl *)>::type>(
                  &clang_TargetInfo_getPointerWidth),
              (Info)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TargetInfo_getPointerWidth(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TargetInfo_getPointerWidth(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_TargetInfo_getPointerWidth"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TargetInfo_getPointerWidth

using Entity_clang_TargetInfo_getPointerWidth =
    Bind_clang_TargetInfo_getPointerWidth<>;

#else

struct Entity_clang_TargetInfo_getPointerWidth
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TargetInfo_getPointerWidth(EntityScope parent_h) {}
  static const char *Key() { return "clang_TargetInfo_getPointerWidth"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TargetInfo_getPointerWidth

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TargetInfo_getTriple : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the normalized target triple as a string.
 *
 * Returns the empty string in case of any error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TargetInfo_getTriple_AddFunction
    handle.def(
        "clang_TargetInfo_getTriple",
        [](pybind11_weaver::WrappedPtrT<CXTargetInfoImpl *> Info) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(CXTargetInfoImpl *)>::type>(
                                 &clang_TargetInfo_getTriple),
                             (Info)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TargetInfo_getTriple(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TargetInfo_getTriple(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_TargetInfo_getTriple"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TargetInfo_getTriple

using Entity_clang_TargetInfo_getTriple = Bind_clang_TargetInfo_getTriple<>;

#else

struct Entity_clang_TargetInfo_getTriple
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TargetInfo_getTriple(EntityScope parent_h) {}
  static const char *Key() { return "clang_TargetInfo_getTriple"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TargetInfo_getTriple

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_TextComment_getText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_Text AST node.
 *
 * \returns text contained in the AST node.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_TextComment_getText_AddFunction
    handle.def(
        "clang_TextComment_getText",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_TextComment_getText),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_TextComment_getText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_TextComment_getText(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_TextComment_getText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_TextComment_getText

using Entity_clang_TextComment_getText = Bind_clang_TextComment_getText<>;

#else

struct Entity_clang_TextComment_getText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_TextComment_getText(EntityScope parent_h) {}
  static const char *Key() { return "clang_TextComment_getText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_TextComment_getText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getAlignOf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the alignment of a type in bytes as per C++[expr.alignof]
 *   standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 *   is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 *   returned.
 * If the type declaration is not a constant size type,
 *   CXTypeLayoutError_NotConstantSize is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getAlignOf_AddFunction
    handle.def(
        "clang_Type_getAlignOf",
        static_cast<pybind11_weaver::FnPtrT<void, long long(CXType)>::type>(
            &clang_Type_getAlignOf),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getAlignOf(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getAlignOf(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getAlignOf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getAlignOf

using Entity_clang_Type_getAlignOf = Bind_clang_Type_getAlignOf<>;

#else

struct Entity_clang_Type_getAlignOf : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getAlignOf(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getAlignOf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getAlignOf

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getCXXRefQualifier : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the ref-qualifier kind of a function or method.
 *
 * The ref-qualifier is returned for C++ functions or methods. For other types
 * or non-C++ declarations, CXRefQualifier_None is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getCXXRefQualifier_AddFunction
    handle.def(
        "clang_Type_getCXXRefQualifier",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXRefQualifierKind(CXType)>::type>(
            &clang_Type_getCXXRefQualifier),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getCXXRefQualifier(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getCXXRefQualifier(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getCXXRefQualifier"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getCXXRefQualifier

using Entity_clang_Type_getCXXRefQualifier =
    Bind_clang_Type_getCXXRefQualifier<>;

#else

struct Entity_clang_Type_getCXXRefQualifier
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getCXXRefQualifier(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getCXXRefQualifier"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getCXXRefQualifier

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getClassType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the class type of an member pointer type.
 *
 * If a non-member-pointer type is passed in, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getClassType_AddFunction
    handle.def("clang_Type_getClassType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_Type_getClassType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getClassType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getClassType(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getClassType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getClassType

using Entity_clang_Type_getClassType = Bind_clang_Type_getClassType<>;

#else

struct Entity_clang_Type_getClassType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getClassType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getClassType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getClassType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getModifiedType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the type that was modified by this attributed type.
 *
 * If the type is not an attributed type, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getModifiedType_AddFunction
    handle.def("clang_Type_getModifiedType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_Type_getModifiedType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getModifiedType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getModifiedType(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getModifiedType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getModifiedType

using Entity_clang_Type_getModifiedType = Bind_clang_Type_getModifiedType<>;

#else

struct Entity_clang_Type_getModifiedType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getModifiedType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getModifiedType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getModifiedType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getNamedType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the type named by the qualified-id.
 *
 * If a non-elaborated type is passed in, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getNamedType_AddFunction
    handle.def("clang_Type_getNamedType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_Type_getNamedType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getNamedType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getNamedType(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getNamedType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getNamedType

using Entity_clang_Type_getNamedType = Bind_clang_Type_getNamedType<>;

#else

struct Entity_clang_Type_getNamedType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getNamedType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getNamedType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getNamedType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getNullability : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the nullability kind of a pointer type.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getNullability_AddFunction
    handle.def(
        "clang_Type_getNullability",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXTypeNullabilityKind(CXType)>::type>(
            &clang_Type_getNullability),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getNullability(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getNullability(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getNullability"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getNullability

using Entity_clang_Type_getNullability = Bind_clang_Type_getNullability<>;

#else

struct Entity_clang_Type_getNullability
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getNullability(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getNullability"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getNullability

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getNumObjCProtocolRefs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the number of protocol references associated with an ObjC object/id.
 *
 * If the type is not an ObjC object, 0 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getNumObjCProtocolRefs_AddFunction
    handle.def(
        "clang_Type_getNumObjCProtocolRefs",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_Type_getNumObjCProtocolRefs),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getNumObjCProtocolRefs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getNumObjCProtocolRefs(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getNumObjCProtocolRefs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getNumObjCProtocolRefs

using Entity_clang_Type_getNumObjCProtocolRefs =
    Bind_clang_Type_getNumObjCProtocolRefs<>;

#else

struct Entity_clang_Type_getNumObjCProtocolRefs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getNumObjCProtocolRefs(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getNumObjCProtocolRefs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getNumObjCProtocolRefs

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getNumObjCTypeArgs : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the number of type arguments associated with an ObjC object.
 *
 * If the type is not an ObjC object, 0 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getNumObjCTypeArgs_AddFunction
    handle.def(
        "clang_Type_getNumObjCTypeArgs",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_Type_getNumObjCTypeArgs),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getNumObjCTypeArgs(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getNumObjCTypeArgs(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getNumObjCTypeArgs"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getNumObjCTypeArgs

using Entity_clang_Type_getNumObjCTypeArgs =
    Bind_clang_Type_getNumObjCTypeArgs<>;

#else

struct Entity_clang_Type_getNumObjCTypeArgs
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getNumObjCTypeArgs(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getNumObjCTypeArgs"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getNumObjCTypeArgs

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getNumTemplateArguments : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the number of template arguments for given template
 * specialization, or -1 if type \c T is not a template specialization.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getNumTemplateArguments_AddFunction
    handle.def("clang_Type_getNumTemplateArguments",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXType)>::type>(
                   &clang_Type_getNumTemplateArguments),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getNumTemplateArguments(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getNumTemplateArguments(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getNumTemplateArguments"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getNumTemplateArguments

using Entity_clang_Type_getNumTemplateArguments =
    Bind_clang_Type_getNumTemplateArguments<>;

#else

struct Entity_clang_Type_getNumTemplateArguments
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getNumTemplateArguments(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getNumTemplateArguments"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getNumTemplateArguments

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getObjCEncoding : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the Objective-C type encoding for the specified CXType.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getObjCEncoding_AddFunction
    handle.def(
        "clang_Type_getObjCEncoding",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXType)>::type>(
            &clang_Type_getObjCEncoding),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getObjCEncoding(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getObjCEncoding(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getObjCEncoding"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCEncoding

using Entity_clang_Type_getObjCEncoding = Bind_clang_Type_getObjCEncoding<>;

#else

struct Entity_clang_Type_getObjCEncoding
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getObjCEncoding(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getObjCEncoding"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCEncoding

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getObjCObjectBaseType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieves the base type of the ObjCObjectType.
 *
 * If the type is not an ObjC object, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getObjCObjectBaseType_AddFunction
    handle.def("clang_Type_getObjCObjectBaseType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_Type_getObjCObjectBaseType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getObjCObjectBaseType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getObjCObjectBaseType(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getObjCObjectBaseType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCObjectBaseType

using Entity_clang_Type_getObjCObjectBaseType =
    Bind_clang_Type_getObjCObjectBaseType<>;

#else

struct Entity_clang_Type_getObjCObjectBaseType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getObjCObjectBaseType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getObjCObjectBaseType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCObjectBaseType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getObjCProtocolDecl : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the decl for a protocol reference for an ObjC object/id.
 *
 * If the type is not an ObjC object or there are not enough protocol
 * references, an invalid cursor is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getObjCProtocolDecl_AddFunction
    handle.def("clang_Type_getObjCProtocolDecl",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXCursor(CXType, unsigned int)>::type>(
                   &clang_Type_getObjCProtocolDecl),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getObjCProtocolDecl(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getObjCProtocolDecl(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getObjCProtocolDecl"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCProtocolDecl

using Entity_clang_Type_getObjCProtocolDecl =
    Bind_clang_Type_getObjCProtocolDecl<>;

#else

struct Entity_clang_Type_getObjCProtocolDecl
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getObjCProtocolDecl(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getObjCProtocolDecl"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCProtocolDecl

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getObjCTypeArg : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a type argument associated with an ObjC object.
 *
 * If the type is not an ObjC or the index is not valid,
 * an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getObjCTypeArg_AddFunction
    handle.def(
        "clang_Type_getObjCTypeArg",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXType(CXType, unsigned int)>::type>(
            &clang_Type_getObjCTypeArg),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getObjCTypeArg(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getObjCTypeArg(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getObjCTypeArg"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCTypeArg

using Entity_clang_Type_getObjCTypeArg = Bind_clang_Type_getObjCTypeArg<>;

#else

struct Entity_clang_Type_getObjCTypeArg
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getObjCTypeArg(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getObjCTypeArg"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getObjCTypeArg

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getOffsetOf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the offset of a field named S in a record of type T in bits
 *   as it would be returned by __offsetof__ as per C++11[18.2p4]
 *
 * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid
 *   is returned.
 * If the field's type declaration is an incomplete type,
 *   CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 *   CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 *   CXTypeLayoutError_InvalidFieldName is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getOffsetOf_AddFunction
    handle.def("clang_Type_getOffsetOf",
               static_cast<pybind11_weaver::FnPtrT<
                   void, long long(CXType, const char *)>::type>(
                   &clang_Type_getOffsetOf),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getOffsetOf(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getOffsetOf(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getOffsetOf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getOffsetOf

using Entity_clang_Type_getOffsetOf = Bind_clang_Type_getOffsetOf<>;

#else

struct Entity_clang_Type_getOffsetOf : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getOffsetOf(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getOffsetOf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getOffsetOf

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getSizeOf : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the size of a type in bytes as per C++[expr.sizeof] standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 *   is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 *   returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getSizeOf_AddFunction
    handle.def(
        "clang_Type_getSizeOf",
        static_cast<pybind11_weaver::FnPtrT<void, long long(CXType)>::type>(
            &clang_Type_getSizeOf),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getSizeOf(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getSizeOf(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getSizeOf"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getSizeOf

using Entity_clang_Type_getSizeOf = Bind_clang_Type_getSizeOf<>;

#else

struct Entity_clang_Type_getSizeOf : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getSizeOf(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getSizeOf"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getSizeOf

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getTemplateArgumentAsType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the type template argument of a template class specialization
 * at given index.
 *
 * This function only returns template type arguments and does not handle
 * template template arguments or variadic packs.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getTemplateArgumentAsType_AddFunction
    handle.def(
        "clang_Type_getTemplateArgumentAsType",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXType(CXType, unsigned int)>::type>(
            &clang_Type_getTemplateArgumentAsType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getTemplateArgumentAsType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getTemplateArgumentAsType(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getTemplateArgumentAsType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getTemplateArgumentAsType

using Entity_clang_Type_getTemplateArgumentAsType =
    Bind_clang_Type_getTemplateArgumentAsType<>;

#else

struct Entity_clang_Type_getTemplateArgumentAsType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getTemplateArgumentAsType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getTemplateArgumentAsType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getTemplateArgumentAsType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_getValueType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Gets the type contained by this atomic type.
 *
 * If a non-atomic type is passed in, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_getValueType_AddFunction
    handle.def("clang_Type_getValueType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_Type_getValueType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_getValueType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_getValueType(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_getValueType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_getValueType

using Entity_clang_Type_getValueType = Bind_clang_Type_getValueType<>;

#else

struct Entity_clang_Type_getValueType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_getValueType(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_getValueType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_getValueType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_isTransparentTagTypedef : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine if a typedef is 'transparent' tag.
 *
 * A typedef is considered 'transparent' if it shares a name and spelling
 * location with its underlying tag type, as is the case with the NS_ENUM macro.
 *
 * \returns non-zero if transparent and zero otherwise.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_isTransparentTagTypedef_AddFunction
    handle.def(
        "clang_Type_isTransparentTagTypedef",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_Type_isTransparentTagTypedef),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_isTransparentTagTypedef(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_isTransparentTagTypedef(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_isTransparentTagTypedef"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_isTransparentTagTypedef

using Entity_clang_Type_isTransparentTagTypedef =
    Bind_clang_Type_isTransparentTagTypedef<>;

#else

struct Entity_clang_Type_isTransparentTagTypedef
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_isTransparentTagTypedef(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_isTransparentTagTypedef"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_isTransparentTagTypedef

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_Type_visitFields : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Visit the fields of a particular type.
 *
 * This function visits all the direct fields of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited field. The traversal may be ended prematurely, if
 * the visitor returns \c CXFieldVisit_Break.
 *
 * \param T the record type whose field may be visited.
 *
 * \param visitor the visitor function that will be invoked for each
 * field of \p T.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXFieldVisit_Break.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_Type_visitFields_AddFunction
    handle.def(
        "clang_Type_visitFields",
        [](CXType T,
           std::function<CXVisitorResult(CXCursor,
                                         pybind11_weaver::WrappedPtrT<void *>)>
               visitor,
           pybind11_weaver::WrappedPtrT<void *> client_data) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  unsigned int(CXType, CXVisitorResult(*)(CXCursor, void *),
                               void *)>::type>(&clang_Type_visitFields),
              T,
              pybind11_weaver::FnPointerWrapper<
                  CXVisitorResult, CXCursor,
                  pybind11_weaver::WrappedPtrT<void *>>::
                  GetCptr<CXVisitorResult, CXCursor, void *>::Run(
                      (visitor), pybind11_weaver::Guardian(),
                      [](CXCursor arg0_0, void *arg0_1) {
                        auto to_call = pybind11_weaver::FnPointerWrapper<
                            CXVisitorResult, CXCursor,
                            pybind11_weaver::WrappedPtrT<void *>>::
                            GetFnProxy(__DATE__ __TIME__ __FILE__, __COUNTER__);
                        return to_call(arg0_0,
                                       pybind11_weaver::WrapP<void *>(arg0_1));
                      },
                      /* clang-format off */
__DATE__ __TIME__ __FILE__, 
__COUNTER__ - 1
                      /* clang-format on */
                      ),
              (client_data)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_Type_visitFields(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_Type_visitFields(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_Type_visitFields"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_Type_visitFields

using Entity_clang_Type_visitFields = Bind_clang_Type_visitFields<>;

#else

struct Entity_clang_Type_visitFields : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_Type_visitFields(EntityScope parent_h) {}
  static const char *Key() { return "clang_Type_visitFields"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_Type_visitFields

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_VerbatimBlockLineComment_getText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_VerbatimBlockLine AST node.
 *
 * \returns text contained in the AST node.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_VerbatimBlockLineComment_getText_AddFunction
    handle.def(
        "clang_VerbatimBlockLineComment_getText",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_VerbatimBlockLineComment_getText),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_VerbatimBlockLineComment_getText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_VerbatimBlockLineComment_getText(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_VerbatimBlockLineComment_getText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_VerbatimBlockLineComment_getText

using Entity_clang_VerbatimBlockLineComment_getText =
    Bind_clang_VerbatimBlockLineComment_getText<>;

#else

struct Entity_clang_VerbatimBlockLineComment_getText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_VerbatimBlockLineComment_getText(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_VerbatimBlockLineComment_getText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_VerbatimBlockLineComment_getText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_VerbatimLineComment_getText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * \param Comment a \c CXComment_VerbatimLine AST node.
 *
 * \returns text contained in the AST node.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_VerbatimLineComment_getText_AddFunction
    handle.def(
        "clang_VerbatimLineComment_getText",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXComment)>::type>(
            &clang_VerbatimLineComment_getText),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_VerbatimLineComment_getText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_VerbatimLineComment_getText(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_VerbatimLineComment_getText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_VerbatimLineComment_getText

using Entity_clang_VerbatimLineComment_getText =
    Bind_clang_VerbatimLineComment_getText<>;

#else

struct Entity_clang_VerbatimLineComment_getText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_VerbatimLineComment_getText(EntityScope parent_h) {}
  static const char *Key() { return "clang_VerbatimLineComment_getText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_VerbatimLineComment_getText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_VirtualFileOverlay_addFileMapping : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Map an absolute virtual file path to an absolute real one.
 * The virtual path must be canonicalized (not contain "."/"..").
 * \returns 0 for success, non-zero to indicate an error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_VirtualFileOverlay_addFileMapping_AddFunction
    handle.def(
        "clang_VirtualFileOverlay_addFileMapping",
        [](pybind11_weaver::WrappedPtrT<CXVirtualFileOverlayImpl *> arg0,
           const char *virtualPath, const char *realPath) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXErrorCode(CXVirtualFileOverlayImpl *, const char *,
                                    const char *)>::type>(
                  &clang_VirtualFileOverlay_addFileMapping),
              (arg0)->Cptr(), virtualPath, realPath);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_VirtualFileOverlay_addFileMapping(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_VirtualFileOverlay_addFileMapping(EntityScope parent_h,
                                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_VirtualFileOverlay_addFileMapping"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_addFileMapping

using Entity_clang_VirtualFileOverlay_addFileMapping =
    Bind_clang_VirtualFileOverlay_addFileMapping<>;

#else

struct Entity_clang_VirtualFileOverlay_addFileMapping
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_VirtualFileOverlay_addFileMapping(
      EntityScope parent_h) {}
  static const char *Key() { return "clang_VirtualFileOverlay_addFileMapping"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_addFileMapping

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_VirtualFileOverlay_create : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Create a \c CXVirtualFileOverlay object.
 * Must be disposed with \c clang_VirtualFileOverlay_dispose().
 *
 * \param options is reserved, always pass 0.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_VirtualFileOverlay_create_AddFunction
    handle.def(
        "clang_VirtualFileOverlay_create",
        [](unsigned int options) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXVirtualFileOverlayImpl *(unsigned int)>::type>(
                  &clang_VirtualFileOverlay_create),
              options);
          return pybind11_weaver::WrapP<CXVirtualFileOverlayImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_VirtualFileOverlay_create(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_VirtualFileOverlay_create(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_VirtualFileOverlay_create"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_create

using Entity_clang_VirtualFileOverlay_create =
    Bind_clang_VirtualFileOverlay_create<>;

#else

struct Entity_clang_VirtualFileOverlay_create
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_VirtualFileOverlay_create(EntityScope parent_h) {}
  static const char *Key() { return "clang_VirtualFileOverlay_create"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_create

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_VirtualFileOverlay_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Dispose a \c CXVirtualFileOverlay object.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_VirtualFileOverlay_dispose_AddFunction
    handle.def(
        "clang_VirtualFileOverlay_dispose",
        [](pybind11_weaver::WrappedPtrT<CXVirtualFileOverlayImpl *> arg0) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, void(CXVirtualFileOverlayImpl *)>::type>(
                                 &clang_VirtualFileOverlay_dispose),
                             (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_VirtualFileOverlay_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_VirtualFileOverlay_dispose(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_VirtualFileOverlay_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_dispose

using Entity_clang_VirtualFileOverlay_dispose =
    Bind_clang_VirtualFileOverlay_dispose<>;

#else

struct Entity_clang_VirtualFileOverlay_dispose
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_VirtualFileOverlay_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_VirtualFileOverlay_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_VirtualFileOverlay_setCaseSensitivity : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Set the case sensitivity for the \c CXVirtualFileOverlay object.
 * The \c CXVirtualFileOverlay object is case-sensitive by default, this
 * option can be used to override the default.
 * \returns 0 for success, non-zero to indicate an error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_VirtualFileOverlay_setCaseSensitivity_AddFunction
    handle.def(
        "clang_VirtualFileOverlay_setCaseSensitivity",
        [](pybind11_weaver::WrappedPtrT<CXVirtualFileOverlayImpl *> arg0,
           int caseSensitive) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXErrorCode(CXVirtualFileOverlayImpl *, int)>::type>(
                  &clang_VirtualFileOverlay_setCaseSensitivity),
              (arg0)->Cptr(), caseSensitive);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_VirtualFileOverlay_setCaseSensitivity(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_VirtualFileOverlay_setCaseSensitivity(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_VirtualFileOverlay_setCaseSensitivity";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_setCaseSensitivity

using Entity_clang_VirtualFileOverlay_setCaseSensitivity =
    Bind_clang_VirtualFileOverlay_setCaseSensitivity<>;

#else

struct Entity_clang_VirtualFileOverlay_setCaseSensitivity
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_VirtualFileOverlay_setCaseSensitivity(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_VirtualFileOverlay_setCaseSensitivity";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_setCaseSensitivity

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_VirtualFileOverlay_writeToBuffer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Write out the \c CXVirtualFileOverlay object to a char buffer.
 *
 * \param options is reserved, always pass 0.
 * \param out_buffer_ptr pointer to receive the buffer pointer, which should be
 * disposed using \c clang_free().
 * \param out_buffer_size pointer to receive the buffer size.
 * \returns 0 for success, non-zero to indicate an error.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_VirtualFileOverlay_writeToBuffer_AddFunction
    handle.def(
        "clang_VirtualFileOverlay_writeToBuffer",
        [](pybind11_weaver::WrappedPtrT<CXVirtualFileOverlayImpl *> arg0,
           unsigned int options,
           pybind11_weaver::WrappedPtrT<char **> out_buffer_ptr,
           unsigned int *out_buffer_size) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXErrorCode(CXVirtualFileOverlayImpl *, unsigned int,
                                    char **, unsigned int *)>::type>(
                  &clang_VirtualFileOverlay_writeToBuffer),
              (arg0)->Cptr(), options, (out_buffer_ptr)->Cptr(),
              out_buffer_size);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_VirtualFileOverlay_writeToBuffer(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_VirtualFileOverlay_writeToBuffer(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_VirtualFileOverlay_writeToBuffer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_writeToBuffer

using Entity_clang_VirtualFileOverlay_writeToBuffer =
    Bind_clang_VirtualFileOverlay_writeToBuffer<>;

#else

struct Entity_clang_VirtualFileOverlay_writeToBuffer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_VirtualFileOverlay_writeToBuffer(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_VirtualFileOverlay_writeToBuffer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_VirtualFileOverlay_writeToBuffer

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_annotateTokens : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Annotate the given set of tokens by providing cursors for each token
 * that can be mapped to a specific entity within the abstract syntax tree.
 *
 * This token-annotation routine is equivalent to invoking
 * clang_getCursor() for the source locations of each of the
 * tokens. The cursors provided are filtered, so that only those
 * cursors that have a direct correspondence to the token are
 * accepted. For example, given a function call \c f(x),
 * clang_getCursor() would provide the following cursors:
 *
 *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.
 *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.
 *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.
 *
 * Only the first and last of these cursors will occur within the
 * annotate, since the tokens "f" and "x' directly refer to a function
 * and a variable, respectively, but the parentheses are just a small
 * part of the full syntax of the function call expression, which is
 * not provided as an annotation.
 *
 * \param TU the translation unit that owns the given tokens.
 *
 * \param Tokens the set of tokens to annotate.
 *
 * \param NumTokens the number of tokens in \p Tokens.
 *
 * \param Cursors an array of \p NumTokens cursors, whose contents will be
 * replaced with the cursors corresponding to each token.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_annotateTokens_AddFunction
    handle.def(
        "clang_annotateTokens",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           CXToken *Tokens, unsigned int NumTokens, CXCursor *Cursors) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXTranslationUnitImpl *, CXToken *, unsigned int,
                             CXCursor *)>::type>(&clang_annotateTokens),
              (TU)->Cptr(), Tokens, NumTokens, Cursors);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_annotateTokens(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_annotateTokens(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_annotateTokens"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_annotateTokens

using Entity_clang_annotateTokens = Bind_clang_annotateTokens<>;

#else

struct Entity_clang_annotateTokens : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_annotateTokens(EntityScope parent_h) {}
  static const char *Key() { return "clang_annotateTokens"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_annotateTokens

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_codeCompleteAt : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Perform code completion at a given location in a translation unit.
 *
 * This function performs code completion at a particular file, line, and
 * column within source code, providing results that suggest potential
 * code snippets based on the context of the completion. The basic model
 * for code completion is that Clang will parse a complete source file,
 * performing syntax checking up to the location where code-completion has
 * been requested. At that point, a special code-completion token is passed
 * to the parser, which recognizes this token and determines, based on the
 * current location in the C/Objective-C/C++ grammar and the state of
 * semantic analysis, what completions to provide. These completions are
 * returned via a new \c CXCodeCompleteResults structure.
 *
 * Code completion itself is meant to be triggered by the client when the
 * user types punctuation characters or whitespace, at which point the
 * code-completion location will coincide with the cursor. For example, if \c p
 * is a pointer, code-completion might be triggered after the "-" and then
 * after the ">" in \c p->. When the code-completion location is after the ">",
 * the completion results will provide, e.g., the members of the struct that
 * "p" points to. The client is responsible for placing the cursor at the
 * beginning of the token currently being typed, then filtering the results
 * based on the contents of the token. For example, when code-completing for
 * the expression \c p->get, the client should provide the location just after
 * the ">" (e.g., pointing at the "g") to this code-completion hook. Then, the
 * client can filter the results based on the current token text ("get"), only
 * showing those results that start with "get". The intent of this interface
 * is to separate the relatively high-latency acquisition of code-completion
 * results from the filtering of results on a per-character basis, which must
 * have a lower latency.
 *
 * \param TU The translation unit in which code-completion should
 * occur. The source files for this translation unit need not be
 * completely up-to-date (and the contents of those source files may
 * be overridden via \p unsaved_files). Cursors referring into the
 * translation unit may be invalidated by this invocation.
 *
 * \param complete_filename The name of the source file where code
 * completion should be performed. This filename may be any file
 * included in the translation unit.
 *
 * \param complete_line The line at which code-completion should occur.
 *
 * \param complete_column The column at which code-completion should occur.
 * Note that the column should point just after the syntactic construct that
 * initiated code completion, and not in the middle of a lexical token.
 *
 * \param unsaved_files the Files that have not yet been saved to disk
 * but may be required for parsing or code completion, including the
 * contents of those files.  The contents and name of these files (as
 * specified by CXUnsavedFile) are copied when necessary, so the
 * client only needs to guarantee their validity until the call to
 * this function returns.
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options Extra options that control the behavior of code
 * completion, expressed as a bitwise OR of the enumerators of the
 * CXCodeComplete_Flags enumeration. The
 * \c clang_defaultCodeCompleteOptions() function returns a default set
 * of code-completion options.
 *
 * \returns If successful, a new \c CXCodeCompleteResults structure
 * containing code-completion results, which should eventually be
 * freed with \c clang_disposeCodeCompleteResults(). If code
 * completion fails, returns NULL.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_codeCompleteAt_AddFunction
    handle.def(
        "clang_codeCompleteAt",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           const char *complete_filename, unsigned int complete_line,
           unsigned int complete_column, CXUnsavedFile *unsaved_files,
           unsigned int num_unsaved_files, unsigned int options) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXCodeCompleteResults *(
                            CXTranslationUnitImpl *, const char *, unsigned int,
                            unsigned int, CXUnsavedFile *, unsigned int,
                            unsigned int)>::type>(&clang_codeCompleteAt),
              (TU)->Cptr(), complete_filename, complete_line, complete_column,
              unsaved_files, num_unsaved_files, options);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_codeCompleteAt(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_codeCompleteAt(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_codeCompleteAt"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_codeCompleteAt

using Entity_clang_codeCompleteAt = Bind_clang_codeCompleteAt<>;

#else

struct Entity_clang_codeCompleteAt : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_codeCompleteAt(EntityScope parent_h) {}
  static const char *Key() { return "clang_codeCompleteAt"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_codeCompleteAt

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_codeCompleteGetContainerKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the cursor kind for the container for the current code
 * completion context. The container is only guaranteed to be set for
 * contexts where a container exists (i.e. member accesses or Objective-C
 * message sends); if there is not a container, this function will return
 * CXCursor_InvalidCode.
 *
 * \param Results the code completion results to query
 *
 * \param IsIncomplete on return, this value will be false if Clang has complete
 * information about the container. If Clang does not have complete
 * information, this value will be true.
 *
 * \returns the container kind, or CXCursor_InvalidCode if there is not a
 * container
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_codeCompleteGetContainerKind_AddFunction
    handle.def(
        "clang_codeCompleteGetContainerKind",
        static_cast<pybind11_weaver::FnPtrT<
            void, CXCursorKind(CXCodeCompleteResults *, unsigned int *)>::type>(
            &clang_codeCompleteGetContainerKind),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_codeCompleteGetContainerKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_codeCompleteGetContainerKind(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_codeCompleteGetContainerKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetContainerKind

using Entity_clang_codeCompleteGetContainerKind =
    Bind_clang_codeCompleteGetContainerKind<>;

#else

struct Entity_clang_codeCompleteGetContainerKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_codeCompleteGetContainerKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_codeCompleteGetContainerKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetContainerKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_codeCompleteGetContainerUSR : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the USR for the container for the current code completion
 * context. If there is not a container for the current context, this
 * function will return the empty string.
 *
 * \param Results the code completion results to query
 *
 * \returns the USR for the container
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_codeCompleteGetContainerUSR_AddFunction
    handle.def("clang_codeCompleteGetContainerUSR",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(CXCodeCompleteResults *)>::type>(
                   &clang_codeCompleteGetContainerUSR),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_codeCompleteGetContainerUSR(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_codeCompleteGetContainerUSR(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_codeCompleteGetContainerUSR"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetContainerUSR

using Entity_clang_codeCompleteGetContainerUSR =
    Bind_clang_codeCompleteGetContainerUSR<>;

#else

struct Entity_clang_codeCompleteGetContainerUSR
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_codeCompleteGetContainerUSR(EntityScope parent_h) {}
  static const char *Key() { return "clang_codeCompleteGetContainerUSR"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetContainerUSR

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_codeCompleteGetContexts : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determines what completions are appropriate for the context
 * the given code completion.
 *
 * \param Results the code completion results to query
 *
 * \returns the kinds of completions that are appropriate for use
 * along with the given code completion results.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_codeCompleteGetContexts_AddFunction
    handle.def("clang_codeCompleteGetContexts",
               static_cast<pybind11_weaver::FnPtrT<
                   void, unsigned long long(CXCodeCompleteResults *)>::type>(
                   &clang_codeCompleteGetContexts),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_codeCompleteGetContexts(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_codeCompleteGetContexts(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_codeCompleteGetContexts"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetContexts

using Entity_clang_codeCompleteGetContexts =
    Bind_clang_codeCompleteGetContexts<>;

#else

struct Entity_clang_codeCompleteGetContexts
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_codeCompleteGetContexts(EntityScope parent_h) {}
  static const char *Key() { return "clang_codeCompleteGetContexts"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetContexts

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_codeCompleteGetDiagnostic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a diagnostic associated with the given code completion.
 *
 * \param Results the code completion results to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_codeCompleteGetDiagnostic_AddFunction
    handle.def(
        "clang_codeCompleteGetDiagnostic",
        [](CXCodeCompleteResults *Results, unsigned int Index) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void *(CXCodeCompleteResults *, unsigned int)>::type>(
                  &clang_codeCompleteGetDiagnostic),
              Results, Index);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_codeCompleteGetDiagnostic(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_codeCompleteGetDiagnostic(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_codeCompleteGetDiagnostic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetDiagnostic

using Entity_clang_codeCompleteGetDiagnostic =
    Bind_clang_codeCompleteGetDiagnostic<>;

#else

struct Entity_clang_codeCompleteGetDiagnostic
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_codeCompleteGetDiagnostic(EntityScope parent_h) {}
  static const char *Key() { return "clang_codeCompleteGetDiagnostic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetDiagnostic

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_codeCompleteGetNumDiagnostics : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the number of diagnostics produced prior to the
 * location where code completion was performed.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_codeCompleteGetNumDiagnostics_AddFunction
    handle.def("clang_codeCompleteGetNumDiagnostics",
               static_cast<pybind11_weaver::FnPtrT<
                   void, unsigned int(CXCodeCompleteResults *)>::type>(
                   &clang_codeCompleteGetNumDiagnostics),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_codeCompleteGetNumDiagnostics(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_codeCompleteGetNumDiagnostics(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_codeCompleteGetNumDiagnostics"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetNumDiagnostics

using Entity_clang_codeCompleteGetNumDiagnostics =
    Bind_clang_codeCompleteGetNumDiagnostics<>;

#else

struct Entity_clang_codeCompleteGetNumDiagnostics
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_codeCompleteGetNumDiagnostics(EntityScope parent_h) {}
  static const char *Key() { return "clang_codeCompleteGetNumDiagnostics"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetNumDiagnostics

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_codeCompleteGetObjCSelector : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the currently-entered selector for an Objective-C message
 * send, formatted like "initWithFoo:bar:". Only guaranteed to return a
 * non-empty string for CXCompletionContext_ObjCInstanceMessage and
 * CXCompletionContext_ObjCClassMessage.
 *
 * \param Results the code completion results to query
 *
 * \returns the selector (or partial selector) that has been entered thus far
 * for an Objective-C message send.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_codeCompleteGetObjCSelector_AddFunction
    handle.def("clang_codeCompleteGetObjCSelector",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(CXCodeCompleteResults *)>::type>(
                   &clang_codeCompleteGetObjCSelector),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_codeCompleteGetObjCSelector(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_codeCompleteGetObjCSelector(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_codeCompleteGetObjCSelector"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetObjCSelector

using Entity_clang_codeCompleteGetObjCSelector =
    Bind_clang_codeCompleteGetObjCSelector<>;

#else

struct Entity_clang_codeCompleteGetObjCSelector
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_codeCompleteGetObjCSelector(EntityScope parent_h) {}
  static const char *Key() { return "clang_codeCompleteGetObjCSelector"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_codeCompleteGetObjCSelector

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_constructUSR_ObjCCategory : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Construct a USR for a specified Objective-C category.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_constructUSR_ObjCCategory_AddFunction
    handle.def("clang_constructUSR_ObjCCategory",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(const char *, const char *)>::type>(
                   &clang_constructUSR_ObjCCategory),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_constructUSR_ObjCCategory(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_constructUSR_ObjCCategory(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_constructUSR_ObjCCategory"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCCategory

using Entity_clang_constructUSR_ObjCCategory =
    Bind_clang_constructUSR_ObjCCategory<>;

#else

struct Entity_clang_constructUSR_ObjCCategory
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_constructUSR_ObjCCategory(EntityScope parent_h) {}
  static const char *Key() { return "clang_constructUSR_ObjCCategory"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCCategory

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_constructUSR_ObjCClass : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Construct a USR for a specified Objective-C class.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_constructUSR_ObjCClass_AddFunction
    handle.def("clang_constructUSR_ObjCClass",
               static_cast<
                   pybind11_weaver::FnPtrT<void, CXString(const char *)>::type>(
                   &clang_constructUSR_ObjCClass),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_constructUSR_ObjCClass(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_constructUSR_ObjCClass(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_constructUSR_ObjCClass"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCClass

using Entity_clang_constructUSR_ObjCClass = Bind_clang_constructUSR_ObjCClass<>;

#else

struct Entity_clang_constructUSR_ObjCClass
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_constructUSR_ObjCClass(EntityScope parent_h) {}
  static const char *Key() { return "clang_constructUSR_ObjCClass"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCClass

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_constructUSR_ObjCIvar : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Construct a USR for a specified Objective-C instance variable and
 *   the USR for its containing class.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_constructUSR_ObjCIvar_AddFunction
    handle.def(
        "clang_constructUSR_ObjCIvar",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(const char *,
                                                           CXString)>::type>(
            &clang_constructUSR_ObjCIvar),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_constructUSR_ObjCIvar(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_constructUSR_ObjCIvar(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_constructUSR_ObjCIvar"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCIvar

using Entity_clang_constructUSR_ObjCIvar = Bind_clang_constructUSR_ObjCIvar<>;

#else

struct Entity_clang_constructUSR_ObjCIvar
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_constructUSR_ObjCIvar(EntityScope parent_h) {}
  static const char *Key() { return "clang_constructUSR_ObjCIvar"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCIvar

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_constructUSR_ObjCMethod : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Construct a USR for a specified Objective-C method and
 *   the USR for its containing class.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_constructUSR_ObjCMethod_AddFunction
    handle.def("clang_constructUSR_ObjCMethod",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXString(const char *, unsigned int, CXString)>::type>(
                   &clang_constructUSR_ObjCMethod),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_constructUSR_ObjCMethod(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_constructUSR_ObjCMethod(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_constructUSR_ObjCMethod"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCMethod

using Entity_clang_constructUSR_ObjCMethod =
    Bind_clang_constructUSR_ObjCMethod<>;

#else

struct Entity_clang_constructUSR_ObjCMethod
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_constructUSR_ObjCMethod(EntityScope parent_h) {}
  static const char *Key() { return "clang_constructUSR_ObjCMethod"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCMethod

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_constructUSR_ObjCProperty : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Construct a USR for a specified Objective-C property and the USR
 *  for its containing class.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_constructUSR_ObjCProperty_AddFunction
    handle.def(
        "clang_constructUSR_ObjCProperty",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(const char *,
                                                           CXString)>::type>(
            &clang_constructUSR_ObjCProperty),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_constructUSR_ObjCProperty(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_constructUSR_ObjCProperty(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_constructUSR_ObjCProperty"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCProperty

using Entity_clang_constructUSR_ObjCProperty =
    Bind_clang_constructUSR_ObjCProperty<>;

#else

struct Entity_clang_constructUSR_ObjCProperty
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_constructUSR_ObjCProperty(EntityScope parent_h) {}
  static const char *Key() { return "clang_constructUSR_ObjCProperty"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCProperty

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_constructUSR_ObjCProtocol : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Construct a USR for a specified Objective-C protocol.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_constructUSR_ObjCProtocol_AddFunction
    handle.def("clang_constructUSR_ObjCProtocol",
               static_cast<
                   pybind11_weaver::FnPtrT<void, CXString(const char *)>::type>(
                   &clang_constructUSR_ObjCProtocol),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_constructUSR_ObjCProtocol(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_constructUSR_ObjCProtocol(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_constructUSR_ObjCProtocol"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCProtocol

using Entity_clang_constructUSR_ObjCProtocol =
    Bind_clang_constructUSR_ObjCProtocol<>;

#else

struct Entity_clang_constructUSR_ObjCProtocol
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_constructUSR_ObjCProtocol(EntityScope parent_h) {}
  static const char *Key() { return "clang_constructUSR_ObjCProtocol"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_constructUSR_ObjCProtocol

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_createAPISet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Traverses the translation unit to create a \c CXAPISet.
 *
 * \param tu is the \c CXTranslationUnit to build the \c CXAPISet for.
 *
 * \param out_api is a pointer to the output of this function. It is needs to be
 * disposed of by calling clang_disposeAPISet.
 *
 * \returns Error code indicating success or failure of the APISet creation.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_createAPISet_AddFunction
    handle.def(
        "clang_createAPISet",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           pybind11_weaver::WrappedPtrT<CXAPISetImpl **> out_api) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXErrorCode(CXTranslationUnitImpl *,
                                                   CXAPISetImpl **)>::type>(
                                 &clang_createAPISet),
                             (tu)->Cptr(), (out_api)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_createAPISet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_createAPISet(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_createAPISet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_createAPISet

using Entity_clang_createAPISet = Bind_clang_createAPISet<>;

#else

struct Entity_clang_createAPISet : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_createAPISet(EntityScope parent_h) {}
  static const char *Key() { return "clang_createAPISet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_createAPISet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_createCXCursorSet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Creates an empty CXCursorSet.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_createCXCursorSet_AddFunction
    handle.def(
        "clang_createCXCursorSet",
        []() {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXCursorSetImpl *()>::type>(
                  &clang_createCXCursorSet));
          return pybind11_weaver::WrapP<CXCursorSetImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_createCXCursorSet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_createCXCursorSet(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_createCXCursorSet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_createCXCursorSet

using Entity_clang_createCXCursorSet = Bind_clang_createCXCursorSet<>;

#else

struct Entity_clang_createCXCursorSet : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_createCXCursorSet(EntityScope parent_h) {}
  static const char *Key() { return "clang_createCXCursorSet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_createCXCursorSet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_createIndex : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Provides a shared context for creating translation units.
 *
 * It provides two options:
 *
 * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"
 * declarations (when loading any new translation units). A "local" declaration
 * is one that belongs in the translation unit itself and not in a precompiled
 * header that was used by the translation unit. If zero, all declarations
 * will be enumerated.
 *
 * Here is an example:
 *
 * \code
 *   // excludeDeclsFromPCH = 1, displayDiagnostics=1
 *   Idx = clang_createIndex(1, 1);
 *
 *   // IndexTest.pch was produced with the following command:
 *   // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"
 *   TU = clang_createTranslationUnit(Idx, "IndexTest.pch");
 *
 *   // This will load all the symbols from 'IndexTest.pch'
 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),
 *                       TranslationUnitVisitor, 0);
 *   clang_disposeTranslationUnit(TU);
 *
 *   // This will load all the symbols from 'IndexTest.c', excluding symbols
 *   // from 'IndexTest.pch'.
 *   char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };
 *   TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,
 *                                                  0, 0);
 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),
 *                       TranslationUnitVisitor, 0);
 *   clang_disposeTranslationUnit(TU);
 * \endcode
 *
 * This process of creating the 'pch', loading it separately, and using it (via
 * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks
 * (which gives the indexer the same performance benefit as the compiler).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_createIndex_AddFunction
    handle.def(
        "clang_createIndex",
        [](int excludeDeclarationsFromPCH, int displayDiagnostics) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void *(int, int)>::type>(
                  &clang_createIndex),
              excludeDeclarationsFromPCH, displayDiagnostics);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_createIndex(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_createIndex(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_createIndex"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_createIndex

using Entity_clang_createIndex = Bind_clang_createIndex<>;

#else

struct Entity_clang_createIndex : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_createIndex(EntityScope parent_h) {}
  static const char *Key() { return "clang_createIndex"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_createIndex

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_createTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Same as \c clang_createTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_createTranslationUnit_AddFunction
    handle.def(
        "clang_createTranslationUnit",
        [](pybind11_weaver::WrappedPtrT<void *> CIdx,
           const char *ast_filename) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXTranslationUnitImpl *(void *, const char *)>::type>(
                  &clang_createTranslationUnit),
              (CIdx)->Cptr(), ast_filename);
          return pybind11_weaver::WrapP<CXTranslationUnitImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_createTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_createTranslationUnit(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_createTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_createTranslationUnit

using Entity_clang_createTranslationUnit = Bind_clang_createTranslationUnit<>;

#else

struct Entity_clang_createTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_createTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_createTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_createTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_createTranslationUnit2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Create a translation unit from an AST file (\c -emit-ast).
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit.
 *
 * \returns Zero on success, otherwise returns an error code.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_createTranslationUnit2_AddFunction
    handle.def(
        "clang_createTranslationUnit2",
        [](pybind11_weaver::WrappedPtrT<void *> CIdx, const char *ast_filename,
           pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl **> out_TU) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXErrorCode(void *, const char *,
                                    CXTranslationUnitImpl **)>::type>(
                  &clang_createTranslationUnit2),
              (CIdx)->Cptr(), ast_filename, (out_TU)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_createTranslationUnit2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_createTranslationUnit2(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_createTranslationUnit2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_createTranslationUnit2

using Entity_clang_createTranslationUnit2 = Bind_clang_createTranslationUnit2<>;

#else

struct Entity_clang_createTranslationUnit2
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_createTranslationUnit2(EntityScope parent_h) {}
  static const char *Key() { return "clang_createTranslationUnit2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_createTranslationUnit2

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_createTranslationUnitFromSourceFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the CXTranslationUnit for a given source file and the provided
 * command line arguments one would pass to the compiler.
 *
 * Note: The 'source_filename' argument is optional.  If the caller provides a
 * NULL pointer, the name of the source file is expected to reside in the
 * specified command line arguments.
 *
 * Note: When encountered in 'clang_command_line_args', the following options
 * are ignored:
 *
 *   '-c'
 *   '-emit-ast'
 *   '-fsyntax-only'
 *   '-o \<output file>'  (both '-o' and '\<output file>' are ignored)
 *
 * \param CIdx The index object with which the translation unit will be
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \p clang_command_line_args.
 *
 * \param num_clang_command_line_args The number of command-line arguments in
 * \p clang_command_line_args.
 *
 * \param clang_command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c',
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for code completion, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_createTranslationUnitFromSourceFile_AddFunction
    handle.def(
        "clang_createTranslationUnitFromSourceFile",
        [](pybind11_weaver::WrappedPtrT<void *> CIdx,
           const char *source_filename, int num_clang_command_line_args,
           pybind11_weaver::WrappedPtrT<const char *const *>
               clang_command_line_args,
           unsigned int num_unsaved_files, CXUnsavedFile *unsaved_files) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXTranslationUnitImpl *(
                            void *, const char *, int, const char *const *,
                            unsigned int, CXUnsavedFile *)>::type>(
                  &clang_createTranslationUnitFromSourceFile),
              (CIdx)->Cptr(), source_filename, num_clang_command_line_args,
              (clang_command_line_args)->Cptr(), num_unsaved_files,
              unsaved_files);
          return pybind11_weaver::WrapP<CXTranslationUnitImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_createTranslationUnitFromSourceFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_createTranslationUnitFromSourceFile(EntityScope parent_h,
                                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_createTranslationUnitFromSourceFile";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_createTranslationUnitFromSourceFile

using Entity_clang_createTranslationUnitFromSourceFile =
    Bind_clang_createTranslationUnitFromSourceFile<>;

#else

struct Entity_clang_createTranslationUnitFromSourceFile
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_createTranslationUnitFromSourceFile(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_createTranslationUnitFromSourceFile";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_createTranslationUnitFromSourceFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_defaultCodeCompleteOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns a default set of code-completion options that can be
 * passed to\c clang_codeCompleteAt().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_defaultCodeCompleteOptions_AddFunction
    handle.def("clang_defaultCodeCompleteOptions",
               static_cast<pybind11_weaver::FnPtrT<void, unsigned int()>::type>(
                   &clang_defaultCodeCompleteOptions),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_defaultCodeCompleteOptions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_defaultCodeCompleteOptions(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_defaultCodeCompleteOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_defaultCodeCompleteOptions

using Entity_clang_defaultCodeCompleteOptions =
    Bind_clang_defaultCodeCompleteOptions<>;

#else

struct Entity_clang_defaultCodeCompleteOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_defaultCodeCompleteOptions(EntityScope parent_h) {}
  static const char *Key() { return "clang_defaultCodeCompleteOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_defaultCodeCompleteOptions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_defaultDiagnosticDisplayOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the set of display options most similar to the
 * default behavior of the clang compiler.
 *
 * \returns A set of display options suitable for use with \c
 * clang_formatDiagnostic().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_defaultDiagnosticDisplayOptions_AddFunction
    handle.def("clang_defaultDiagnosticDisplayOptions",
               static_cast<pybind11_weaver::FnPtrT<void, unsigned int()>::type>(
                   &clang_defaultDiagnosticDisplayOptions),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_defaultDiagnosticDisplayOptions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_defaultDiagnosticDisplayOptions(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_defaultDiagnosticDisplayOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_defaultDiagnosticDisplayOptions

using Entity_clang_defaultDiagnosticDisplayOptions =
    Bind_clang_defaultDiagnosticDisplayOptions<>;

#else

struct Entity_clang_defaultDiagnosticDisplayOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_defaultDiagnosticDisplayOptions(EntityScope parent_h) {}
  static const char *Key() { return "clang_defaultDiagnosticDisplayOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_defaultDiagnosticDisplayOptions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_defaultEditingTranslationUnitOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the set of flags that is suitable for parsing a translation
 * unit that is being edited.
 *
 * The set of flags returned provide options for \c clang_parseTranslationUnit()
 * to indicate that the translation unit is likely to be reparsed many times,
 * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly
 * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag
 * set contains an unspecified set of optimizations (e.g., the precompiled
 * preamble) geared toward improving the performance of these routines. The
 * set of optimizations enabled may change from one version to the next.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_defaultEditingTranslationUnitOptions_AddFunction
    handle.def("clang_defaultEditingTranslationUnitOptions",
               static_cast<pybind11_weaver::FnPtrT<void, unsigned int()>::type>(
                   &clang_defaultEditingTranslationUnitOptions),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_defaultEditingTranslationUnitOptions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_defaultEditingTranslationUnitOptions(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_defaultEditingTranslationUnitOptions";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_defaultEditingTranslationUnitOptions

using Entity_clang_defaultEditingTranslationUnitOptions =
    Bind_clang_defaultEditingTranslationUnitOptions<>;

#else

struct Entity_clang_defaultEditingTranslationUnitOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_defaultEditingTranslationUnitOptions(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_defaultEditingTranslationUnitOptions";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_defaultEditingTranslationUnitOptions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_defaultReparseOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the set of flags that is suitable for reparsing a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_reparseTranslationUnit() by default. The returned flag
 * set contains an unspecified set of optimizations geared toward common uses
 * of reparsing. The set of optimizations enabled may change from one version
 * to the next.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_defaultReparseOptions_AddFunction
    handle.def(
        "clang_defaultReparseOptions",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXTranslationUnitImpl *)>::type>(
                  &clang_defaultReparseOptions),
              (TU)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_defaultReparseOptions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_defaultReparseOptions(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_defaultReparseOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_defaultReparseOptions

using Entity_clang_defaultReparseOptions = Bind_clang_defaultReparseOptions<>;

#else

struct Entity_clang_defaultReparseOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_defaultReparseOptions(EntityScope parent_h) {}
  static const char *Key() { return "clang_defaultReparseOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_defaultReparseOptions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_defaultSaveOptions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the set of flags that is suitable for saving a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_saveTranslationUnit() by default. The returned flag
 * set contains an unspecified set of options that save translation units with
 * the most commonly-requested data.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_defaultSaveOptions_AddFunction
    handle.def(
        "clang_defaultSaveOptions",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXTranslationUnitImpl *)>::type>(
                  &clang_defaultSaveOptions),
              (TU)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_defaultSaveOptions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_defaultSaveOptions(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_defaultSaveOptions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_defaultSaveOptions

using Entity_clang_defaultSaveOptions = Bind_clang_defaultSaveOptions<>;

#else

struct Entity_clang_defaultSaveOptions
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_defaultSaveOptions(EntityScope parent_h) {}
  static const char *Key() { return "clang_defaultSaveOptions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_defaultSaveOptions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeAPISet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Dispose of an APISet.
 *
 * The provided \c CXAPISet can not be used after this function is called.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeAPISet_AddFunction
    handle.def(
        "clang_disposeAPISet",
        [](pybind11_weaver::WrappedPtrT<CXAPISetImpl *> api) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void(CXAPISetImpl *)>::type>(
                  &clang_disposeAPISet),
              (api)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeAPISet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeAPISet(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeAPISet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeAPISet

using Entity_clang_disposeAPISet = Bind_clang_disposeAPISet<>;

#else

struct Entity_clang_disposeAPISet : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeAPISet(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeAPISet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeAPISet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeCXCursorSet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Disposes a CXCursorSet and releases its associated memory.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeCXCursorSet_AddFunction
    handle.def(
        "clang_disposeCXCursorSet",
        [](pybind11_weaver::WrappedPtrT<CXCursorSetImpl *> cset) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void(CXCursorSetImpl *)>::type>(
                  &clang_disposeCXCursorSet),
              (cset)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeCXCursorSet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeCXCursorSet(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeCXCursorSet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeCXCursorSet

using Entity_clang_disposeCXCursorSet = Bind_clang_disposeCXCursorSet<>;

#else

struct Entity_clang_disposeCXCursorSet
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeCXCursorSet(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeCXCursorSet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeCXCursorSet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeCXPlatformAvailability : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the memory associated with a \c CXPlatformAvailability structure.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeCXPlatformAvailability_AddFunction
    handle.def("clang_disposeCXPlatformAvailability",
               static_cast<pybind11_weaver::FnPtrT<
                   void, void(CXPlatformAvailability *)>::type>(
                   &clang_disposeCXPlatformAvailability),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeCXPlatformAvailability(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeCXPlatformAvailability(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeCXPlatformAvailability"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeCXPlatformAvailability

using Entity_clang_disposeCXPlatformAvailability =
    Bind_clang_disposeCXPlatformAvailability<>;

#else

struct Entity_clang_disposeCXPlatformAvailability
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeCXPlatformAvailability(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeCXPlatformAvailability"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeCXPlatformAvailability

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeCXTUResourceUsage : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_disposeCXTUResourceUsage_AddFunction
    handle.def(
        "clang_disposeCXTUResourceUsage",
        static_cast<
            pybind11_weaver::FnPtrT<void, void(CXTUResourceUsage)>::type>(
            &clang_disposeCXTUResourceUsage));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeCXTUResourceUsage(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeCXTUResourceUsage(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeCXTUResourceUsage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeCXTUResourceUsage

using Entity_clang_disposeCXTUResourceUsage =
    Bind_clang_disposeCXTUResourceUsage<>;

#else

struct Entity_clang_disposeCXTUResourceUsage
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeCXTUResourceUsage(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeCXTUResourceUsage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeCXTUResourceUsage

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeCodeCompleteResults : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the given set of code-completion results.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeCodeCompleteResults_AddFunction
    handle.def(
        "clang_disposeCodeCompleteResults",
        static_cast<
            pybind11_weaver::FnPtrT<void, void(CXCodeCompleteResults *)>::type>(
            &clang_disposeCodeCompleteResults),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeCodeCompleteResults(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeCodeCompleteResults(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeCodeCompleteResults"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeCodeCompleteResults

using Entity_clang_disposeCodeCompleteResults =
    Bind_clang_disposeCodeCompleteResults<>;

#else

struct Entity_clang_disposeCodeCompleteResults
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeCodeCompleteResults(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeCodeCompleteResults"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeCodeCompleteResults

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeDiagnostic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Destroy a diagnostic.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeDiagnostic_AddFunction
    handle.def(
        "clang_disposeDiagnostic",
        [](pybind11_weaver::WrappedPtrT<void *> Diagnostic) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_disposeDiagnostic),
              (Diagnostic)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeDiagnostic(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeDiagnostic(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeDiagnostic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeDiagnostic

using Entity_clang_disposeDiagnostic = Bind_clang_disposeDiagnostic<>;

#else

struct Entity_clang_disposeDiagnostic : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeDiagnostic(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeDiagnostic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeDiagnostic

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeDiagnosticSet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Release a CXDiagnosticSet and all of its contained diagnostics.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeDiagnosticSet_AddFunction
    handle.def(
        "clang_disposeDiagnosticSet",
        [](pybind11_weaver::WrappedPtrT<void *> Diags) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_disposeDiagnosticSet),
              (Diags)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeDiagnosticSet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeDiagnosticSet(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeDiagnosticSet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeDiagnosticSet

using Entity_clang_disposeDiagnosticSet = Bind_clang_disposeDiagnosticSet<>;

#else

struct Entity_clang_disposeDiagnosticSet
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeDiagnosticSet(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeDiagnosticSet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeDiagnosticSet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeIndex : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Destroy the given index.
 *
 * The index must not be destroyed until all of the translation units created
 * within that index have been destroyed.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeIndex_AddFunction
    handle.def(
        "clang_disposeIndex",
        [](pybind11_weaver::WrappedPtrT<void *> index) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_disposeIndex),
              (index)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeIndex(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeIndex(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeIndex"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeIndex

using Entity_clang_disposeIndex = Bind_clang_disposeIndex<>;

#else

struct Entity_clang_disposeIndex : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeIndex(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeIndex"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeIndex

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeOverriddenCursors : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the set of overridden cursors returned by \c
 * clang_getOverriddenCursors().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeOverriddenCursors_AddFunction
    handle.def(
        "clang_disposeOverriddenCursors",
        static_cast<pybind11_weaver::FnPtrT<void, void(CXCursor *)>::type>(
            &clang_disposeOverriddenCursors),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeOverriddenCursors(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeOverriddenCursors(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeOverriddenCursors"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeOverriddenCursors

using Entity_clang_disposeOverriddenCursors =
    Bind_clang_disposeOverriddenCursors<>;

#else

struct Entity_clang_disposeOverriddenCursors
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeOverriddenCursors(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeOverriddenCursors"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeOverriddenCursors

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeSourceRangeList : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Destroy the given \c CXSourceRangeList.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeSourceRangeList_AddFunction
    handle.def(
        "clang_disposeSourceRangeList",
        static_cast<
            pybind11_weaver::FnPtrT<void, void(CXSourceRangeList *)>::type>(
            &clang_disposeSourceRangeList),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeSourceRangeList(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeSourceRangeList(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeSourceRangeList"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeSourceRangeList

using Entity_clang_disposeSourceRangeList = Bind_clang_disposeSourceRangeList<>;

#else

struct Entity_clang_disposeSourceRangeList
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeSourceRangeList(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeSourceRangeList"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeSourceRangeList

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeString : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the given string.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeString_AddFunction
    handle.def("clang_disposeString",
               static_cast<pybind11_weaver::FnPtrT<void, void(CXString)>::type>(
                   &clang_disposeString),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeString(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeString(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeString"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeString

using Entity_clang_disposeString = Bind_clang_disposeString<>;

#else

struct Entity_clang_disposeString : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeString(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeString"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeString

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeStringSet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the given string set.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeStringSet_AddFunction
    handle.def(
        "clang_disposeStringSet",
        static_cast<pybind11_weaver::FnPtrT<void, void(CXStringSet *)>::type>(
            &clang_disposeStringSet),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeStringSet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeStringSet(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeStringSet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeStringSet

using Entity_clang_disposeStringSet = Bind_clang_disposeStringSet<>;

#else

struct Entity_clang_disposeStringSet : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeStringSet(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeStringSet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeStringSet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeTokens : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Free the given set of tokens.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeTokens_AddFunction
    handle.def(
        "clang_disposeTokens",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           CXToken *Tokens, unsigned int NumTokens) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXTranslationUnitImpl *, CXToken *,
                             unsigned int)>::type>(&clang_disposeTokens),
              (TU)->Cptr(), Tokens, NumTokens);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeTokens(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeTokens(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeTokens"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeTokens

using Entity_clang_disposeTokens = Bind_clang_disposeTokens<>;

#else

struct Entity_clang_disposeTokens : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeTokens(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeTokens"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeTokens

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_disposeTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Destroy the specified CXTranslationUnit object.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_disposeTranslationUnit_AddFunction
    handle.def(
        "clang_disposeTranslationUnit",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, void(CXTranslationUnitImpl *)>::type>(
                                 &clang_disposeTranslationUnit),
                             (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_disposeTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_disposeTranslationUnit(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_disposeTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_disposeTranslationUnit

using Entity_clang_disposeTranslationUnit = Bind_clang_disposeTranslationUnit<>;

#else

struct Entity_clang_disposeTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_disposeTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_disposeTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_disposeTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_enableStackTraces : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_enableStackTraces_AddFunction
    handle.def("clang_enableStackTraces",
               static_cast<pybind11_weaver::FnPtrT<void, void()>::type>(
                   &clang_enableStackTraces));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_enableStackTraces(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_enableStackTraces(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_enableStackTraces"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_enableStackTraces

using Entity_clang_enableStackTraces = Bind_clang_enableStackTraces<>;

#else

struct Entity_clang_enableStackTraces : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_enableStackTraces(EntityScope parent_h) {}
  static const char *Key() { return "clang_enableStackTraces"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_enableStackTraces

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_equalCursors : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether two cursors are equivalent.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_equalCursors_AddFunction
    handle.def(
        "clang_equalCursors",
        static_cast<pybind11_weaver::FnPtrT<
            void, unsigned int(CXCursor, CXCursor)>::type>(&clang_equalCursors),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_equalCursors(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_equalCursors(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_equalCursors"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_equalCursors

using Entity_clang_equalCursors = Bind_clang_equalCursors<>;

#else

struct Entity_clang_equalCursors : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_equalCursors(EntityScope parent_h) {}
  static const char *Key() { return "clang_equalCursors"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_equalCursors

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_equalLocations : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether two source locations, which must refer into
 * the same translation unit, refer to exactly the same point in the source
 * code.
 *
 * \returns non-zero if the source locations refer to the same location, zero
 * if they refer to different locations.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_equalLocations_AddFunction
    handle.def(
        "clang_equalLocations",
        static_cast<pybind11_weaver::FnPtrT<
            void, unsigned int(CXSourceLocation, CXSourceLocation)>::type>(
            &clang_equalLocations),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_equalLocations(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_equalLocations(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_equalLocations"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_equalLocations

using Entity_clang_equalLocations = Bind_clang_equalLocations<>;

#else

struct Entity_clang_equalLocations : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_equalLocations(EntityScope parent_h) {}
  static const char *Key() { return "clang_equalLocations"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_equalLocations

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_equalRanges : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether two ranges are equivalent.
 *
 * \returns non-zero if the ranges are the same, zero if they differ.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_equalRanges_AddFunction
    handle.def("clang_equalRanges",
               static_cast<pybind11_weaver::FnPtrT<
                   void, unsigned int(CXSourceRange, CXSourceRange)>::type>(
                   &clang_equalRanges),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_equalRanges(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_equalRanges(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_equalRanges"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_equalRanges

using Entity_clang_equalRanges = Bind_clang_equalRanges<>;

#else

struct Entity_clang_equalRanges : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_equalRanges(EntityScope parent_h) {}
  static const char *Key() { return "clang_equalRanges"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_equalRanges

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_equalTypes : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether two CXTypes represent the same type.
 *
 * \returns non-zero if the CXTypes represent the same type and
 *          zero otherwise.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_equalTypes_AddFunction
    handle.def(
        "clang_equalTypes",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXType, CXType)>::type>(
            &clang_equalTypes),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_equalTypes(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_equalTypes(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_equalTypes"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_equalTypes

using Entity_clang_equalTypes = Bind_clang_equalTypes<>;

#else

struct Entity_clang_equalTypes : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_equalTypes(EntityScope parent_h) {}
  static const char *Key() { return "clang_equalTypes"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_equalTypes

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_executeOnThread : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_executeOnThread_AddFunction
    handle.def(
        "clang_executeOnThread",
        [](std::function<void(pybind11_weaver::WrappedPtrT<void *>)> fn,
           pybind11_weaver::WrappedPtrT<void *> user_data,
           unsigned int stack_size) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(void (*)(void *), void *, unsigned int)>::type>(
                  &clang_executeOnThread),
              pybind11_weaver::FnPointerWrapper<
                  void, pybind11_weaver::WrappedPtrT<void *>>::
                  GetCptr<void, void *>::Run(
                      (fn), pybind11_weaver::Guardian(),
                      [](void *arg0_0) {
                        auto to_call = pybind11_weaver::FnPointerWrapper<
                            void, pybind11_weaver::WrappedPtrT<void *>>::
                            GetFnProxy(__DATE__ __TIME__ __FILE__, __COUNTER__);
                        return to_call(pybind11_weaver::WrapP<void *>(arg0_0));
                      },
                      /* clang-format off */
__DATE__ __TIME__ __FILE__, 
__COUNTER__ - 1
                      /* clang-format on */
                      ),
              (user_data)->Cptr(), stack_size);
        });
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_executeOnThread(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_executeOnThread(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_executeOnThread"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_executeOnThread

using Entity_clang_executeOnThread = Bind_clang_executeOnThread<>;

#else

struct Entity_clang_executeOnThread : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_executeOnThread(EntityScope parent_h) {}
  static const char *Key() { return "clang_executeOnThread"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_executeOnThread

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_findIncludesInFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Find #import/#include directives in a specific file.
 *
 * \param TU translation unit containing the file to query.
 *
 * \param file to search for #import/#include directives.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each directive found.
 *
 * \returns one of the CXResult enumerators.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_findIncludesInFile_AddFunction
    handle.def(
        "clang_findIncludesInFile",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           pybind11_weaver::WrappedPtrT<void *> file,
           CXCursorAndRangeVisitor visitor) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXResult(CXTranslationUnitImpl *, void *,
                                 CXCursorAndRangeVisitor)>::type>(
                  &clang_findIncludesInFile),
              (TU)->Cptr(), (file)->Cptr(), visitor);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_findIncludesInFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_findIncludesInFile(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_findIncludesInFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_findIncludesInFile

using Entity_clang_findIncludesInFile = Bind_clang_findIncludesInFile<>;

#else

struct Entity_clang_findIncludesInFile
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_findIncludesInFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_findIncludesInFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_findIncludesInFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_findReferencesInFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Find references of a declaration in a specific file.
 *
 * \param cursor pointing to a declaration or a reference of one.
 *
 * \param file to search for references.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each reference found.
 * The CXSourceRange will point inside the file; if the reference is inside
 * a macro (and not a macro argument) the CXSourceRange will be invalid.
 *
 * \returns one of the CXResult enumerators.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_findReferencesInFile_AddFunction
    handle.def(
        "clang_findReferencesInFile",
        [](CXCursor cursor, pybind11_weaver::WrappedPtrT<void *> file,
           CXCursorAndRangeVisitor visitor) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  CXResult(CXCursor, void *, CXCursorAndRangeVisitor)>::type>(
                  &clang_findReferencesInFile),
              cursor, (file)->Cptr(), visitor);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_findReferencesInFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_findReferencesInFile(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_findReferencesInFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_findReferencesInFile

using Entity_clang_findReferencesInFile = Bind_clang_findReferencesInFile<>;

#else

struct Entity_clang_findReferencesInFile
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_findReferencesInFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_findReferencesInFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_findReferencesInFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_formatDiagnostic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Format the given diagnostic in a manner that is suitable for display.
 *
 * This routine will format the given diagnostic to a string, rendering
 * the diagnostic according to the various options given. The
 * \c clang_defaultDiagnosticDisplayOptions() function returns the set of
 * options that most closely mimics the behavior of the clang compiler.
 *
 * \param Diagnostic The diagnostic to print.
 *
 * \param Options A set of options that control the diagnostic display,
 * created by combining \c CXDiagnosticDisplayOptions values.
 *
 * \returns A new string containing for formatted diagnostic.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_formatDiagnostic_AddFunction
    handle.def(
        "clang_formatDiagnostic",
        [](pybind11_weaver::WrappedPtrT<void *> Diagnostic,
           unsigned int Options) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, unsigned int)>::type>(
                                 &clang_formatDiagnostic),
                             (Diagnostic)->Cptr(), Options);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_formatDiagnostic(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_formatDiagnostic(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_formatDiagnostic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_formatDiagnostic

using Entity_clang_formatDiagnostic = Bind_clang_formatDiagnostic<>;

#else

struct Entity_clang_formatDiagnostic : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_formatDiagnostic(EntityScope parent_h) {}
  static const char *Key() { return "clang_formatDiagnostic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_formatDiagnostic

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_free : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * free memory allocated by libclang, such as the buffer returned by
 * \c CXVirtualFileOverlay() or \c clang_ModuleMapDescriptor_writeToBuffer().
 *
 * \param buffer memory pointer to free.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_free_AddFunction
    handle.def(
        "clang_free",
        [](pybind11_weaver::WrappedPtrT<void *> buffer) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_free),
              (buffer)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_free(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_free(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_free"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_free

using Entity_clang_free = Bind_clang_free<>;

#else

struct Entity_clang_free : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_free(EntityScope parent_h) {}
  static const char *Key() { return "clang_free"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_free

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getAddressSpace : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the address space of the given type.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getAddressSpace_AddFunction
    handle.def(
        "clang_getAddressSpace",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_getAddressSpace),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getAddressSpace(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getAddressSpace(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getAddressSpace"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getAddressSpace

using Entity_clang_getAddressSpace = Bind_clang_getAddressSpace<>;

#else

struct Entity_clang_getAddressSpace : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getAddressSpace(EntityScope parent_h) {}
  static const char *Key() { return "clang_getAddressSpace"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getAddressSpace

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getAllSkippedRanges : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve all ranges from all files that were skipped by the
 * preprocessor.
 *
 * The preprocessor will skip lines when they are surrounded by an
 * if/ifdef/ifndef directive whose condition does not evaluate to true.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getAllSkippedRanges_AddFunction
    handle.def(
        "clang_getAllSkippedRanges",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXSourceRangeList *(CXTranslationUnitImpl *)>::type>(
                  &clang_getAllSkippedRanges),
              (tu)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getAllSkippedRanges(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getAllSkippedRanges(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getAllSkippedRanges"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getAllSkippedRanges

using Entity_clang_getAllSkippedRanges = Bind_clang_getAllSkippedRanges<>;

#else

struct Entity_clang_getAllSkippedRanges
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getAllSkippedRanges(EntityScope parent_h) {}
  static const char *Key() { return "clang_getAllSkippedRanges"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getAllSkippedRanges

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getArgType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the type of a parameter of a function type.
 *
 * If a non-function type is passed in or the function does not have enough
 * parameters, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getArgType_AddFunction
    handle.def(
        "clang_getArgType",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXType(CXType, unsigned int)>::type>(
            &clang_getArgType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getArgType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getArgType(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getArgType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getArgType

using Entity_clang_getArgType = Bind_clang_getArgType<>;

#else

struct Entity_clang_getArgType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getArgType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getArgType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getArgType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getArrayElementType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the element type of an array type.
 *
 * If a non-array type is passed in, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getArrayElementType_AddFunction
    handle.def("clang_getArrayElementType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_getArrayElementType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getArrayElementType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getArrayElementType(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getArrayElementType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getArrayElementType

using Entity_clang_getArrayElementType = Bind_clang_getArrayElementType<>;

#else

struct Entity_clang_getArrayElementType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getArrayElementType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getArrayElementType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getArrayElementType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getArraySize : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the array size of a constant array.
 *
 * If a non-array type is passed in, -1 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getArraySize_AddFunction
    handle.def(
        "clang_getArraySize",
        static_cast<pybind11_weaver::FnPtrT<void, long long(CXType)>::type>(
            &clang_getArraySize),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getArraySize(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getArraySize(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getArraySize"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getArraySize

using Entity_clang_getArraySize = Bind_clang_getArraySize<>;

#else

struct Entity_clang_getArraySize : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getArraySize(EntityScope parent_h) {}
  static const char *Key() { return "clang_getArraySize"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getArraySize

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getBuildSessionTimestamp : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the timestamp for use with Clang's
 * \c -fbuild-session-timestamp= option.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getBuildSessionTimestamp_AddFunction
    handle.def(
        "clang_getBuildSessionTimestamp",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned long long()>::type>(
            &clang_getBuildSessionTimestamp),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getBuildSessionTimestamp(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getBuildSessionTimestamp(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getBuildSessionTimestamp"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getBuildSessionTimestamp

using Entity_clang_getBuildSessionTimestamp =
    Bind_clang_getBuildSessionTimestamp<>;

#else

struct Entity_clang_getBuildSessionTimestamp
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getBuildSessionTimestamp(EntityScope parent_h) {}
  static const char *Key() { return "clang_getBuildSessionTimestamp"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getBuildSessionTimestamp

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCString : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the character data associated with the given string.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCString_AddFunction
    handle.def("clang_getCString",
               static_cast<
                   pybind11_weaver::FnPtrT<void, const char *(CXString)>::type>(
                   &clang_getCString),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCString(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCString(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCString"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCString

using Entity_clang_getCString = Bind_clang_getCString<>;

#else

struct Entity_clang_getCString : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCString(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCString"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCString

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCXTUResourceUsage : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the memory usage of a translation unit.  This object
 *  should be released with clang_disposeCXTUResourceUsage().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCXTUResourceUsage_AddFunction
    handle.def(
        "clang_getCXTUResourceUsage",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXTUResourceUsage(CXTranslationUnitImpl *)>::type>(
                  &clang_getCXTUResourceUsage),
              (TU)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCXTUResourceUsage(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCXTUResourceUsage(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCXTUResourceUsage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCXTUResourceUsage

using Entity_clang_getCXTUResourceUsage = Bind_clang_getCXTUResourceUsage<>;

#else

struct Entity_clang_getCXTUResourceUsage
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCXTUResourceUsage(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCXTUResourceUsage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCXTUResourceUsage

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCXXAccessSpecifier : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the access control level for the referenced object.
 *
 * If the cursor refers to a C++ declaration, its access control level within
 * its parent scope is returned. Otherwise, if the cursor refers to a base
 * specifier or access specifier, the specifier itself is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCXXAccessSpecifier_AddFunction
    handle.def("clang_getCXXAccessSpecifier",
               static_cast<pybind11_weaver::FnPtrT<void, CX_CXXAccessSpecifier(
                                                             CXCursor)>::type>(
                   &clang_getCXXAccessSpecifier),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCXXAccessSpecifier(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCXXAccessSpecifier(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCXXAccessSpecifier"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCXXAccessSpecifier

using Entity_clang_getCXXAccessSpecifier = Bind_clang_getCXXAccessSpecifier<>;

#else

struct Entity_clang_getCXXAccessSpecifier
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCXXAccessSpecifier(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCXXAccessSpecifier"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCXXAccessSpecifier

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCanonicalCursor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the canonical cursor corresponding to the given cursor.
 *
 * In the C family of languages, many kinds of entities can be declared several
 * times within a single translation unit. For example, a structure type can
 * be forward-declared (possibly multiple times) and later defined:
 *
 * \code
 * struct X;
 * struct X;
 * struct X {
 *   int member;
 * };
 * \endcode
 *
 * The declarations and the definition of \c X are represented by three
 * different cursors, all of which are declarations of the same underlying
 * entity. One of these cursor is considered the "canonical" cursor, which
 * is effectively the representative for the underlying entity. One can
 * determine if two cursors are declarations of the same underlying entity by
 * comparing their canonical cursors.
 *
 * \returns The canonical cursor for the entity referred to by the given cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCanonicalCursor_AddFunction
    handle.def(
        "clang_getCanonicalCursor",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXCursor)>::type>(
            &clang_getCanonicalCursor),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCanonicalCursor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCanonicalCursor(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCanonicalCursor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCanonicalCursor

using Entity_clang_getCanonicalCursor = Bind_clang_getCanonicalCursor<>;

#else

struct Entity_clang_getCanonicalCursor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCanonicalCursor(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCanonicalCursor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCanonicalCursor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCanonicalType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the canonical type for a CXType.
 *
 * Clang's type system explicitly models typedefs and all the ways
 * a specific type can be represented.  The canonical type is the underlying
 * type with all the "sugar" removed.  For example, if 'T' is a typedef
 * for 'int', the canonical type for 'T' would be 'int'.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCanonicalType_AddFunction
    handle.def("clang_getCanonicalType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_getCanonicalType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCanonicalType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCanonicalType(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCanonicalType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCanonicalType

using Entity_clang_getCanonicalType = Bind_clang_getCanonicalType<>;

#else

struct Entity_clang_getCanonicalType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCanonicalType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCanonicalType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCanonicalType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getChildDiagnostics : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the child diagnostics of a CXDiagnostic.
 *
 * This CXDiagnosticSet does not need to be released by
 * clang_disposeDiagnosticSet.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getChildDiagnostics_AddFunction
    handle.def(
        "clang_getChildDiagnostics",
        [](pybind11_weaver::WrappedPtrT<void *> D) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void *(void *)>::type>(
                  &clang_getChildDiagnostics),
              (D)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getChildDiagnostics(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getChildDiagnostics(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getChildDiagnostics"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getChildDiagnostics

using Entity_clang_getChildDiagnostics = Bind_clang_getChildDiagnostics<>;

#else

struct Entity_clang_getChildDiagnostics
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getChildDiagnostics(EntityScope parent_h) {}
  static const char *Key() { return "clang_getChildDiagnostics"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getChildDiagnostics

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getClangVersion : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return a version string, suitable for showing to a user, but not
 *        intended to be parsed (the format is not guaranteed to be stable).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getClangVersion_AddFunction
    handle.def("clang_getClangVersion",
               static_cast<pybind11_weaver::FnPtrT<void, CXString()>::type>(
                   &clang_getClangVersion),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getClangVersion(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getClangVersion(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getClangVersion"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getClangVersion

using Entity_clang_getClangVersion = Bind_clang_getClangVersion<>;

#else

struct Entity_clang_getClangVersion : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getClangVersion(EntityScope parent_h) {}
  static const char *Key() { return "clang_getClangVersion"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getClangVersion

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionAnnotation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the annotation associated with the given completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param annotation_number the 0-based index of the annotation of the
 * completion string.
 *
 * \returns annotation string associated with the completion at index
 * \c annotation_number, or a NULL string if that annotation is not available.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionAnnotation_AddFunction
    handle.def(
        "clang_getCompletionAnnotation",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string,
           unsigned int annotation_number) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, unsigned int)>::type>(
                                 &clang_getCompletionAnnotation),
                             (completion_string)->Cptr(), annotation_number);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionAnnotation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionAnnotation(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionAnnotation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionAnnotation

using Entity_clang_getCompletionAnnotation =
    Bind_clang_getCompletionAnnotation<>;

#else

struct Entity_clang_getCompletionAnnotation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionAnnotation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionAnnotation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionAnnotation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionAvailability : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the availability of the entity that this code-completion
 * string refers to.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The availability of the completion string.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionAvailability_AddFunction
    handle.def(
        "clang_getCompletionAvailability",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXAvailabilityKind(void *)>::type>(
                                 &clang_getCompletionAvailability),
                             (completion_string)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionAvailability(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionAvailability(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionAvailability"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionAvailability

using Entity_clang_getCompletionAvailability =
    Bind_clang_getCompletionAvailability<>;

#else

struct Entity_clang_getCompletionAvailability
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionAvailability(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionAvailability"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionAvailability

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionBriefComment : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the brief documentation comment attached to the declaration
 * that corresponds to the given completion string.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionBriefComment_AddFunction
    handle.def(
        "clang_getCompletionBriefComment",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_getCompletionBriefComment),
              (completion_string)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionBriefComment(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionBriefComment(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionBriefComment"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionBriefComment

using Entity_clang_getCompletionBriefComment =
    Bind_clang_getCompletionBriefComment<>;

#else

struct Entity_clang_getCompletionBriefComment
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionBriefComment(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionBriefComment"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionBriefComment

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionChunkCompletionString : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the completion string associated with a particular chunk
 * within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the completion string associated with the chunk at index
 * \c chunk_number.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionChunkCompletionString_AddFunction
    handle.def(
        "clang_getCompletionChunkCompletionString",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string,
           unsigned int chunk_number) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(void *, unsigned int)>::type>(
                              &clang_getCompletionChunkCompletionString),
                          (completion_string)->Cptr(), chunk_number);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionChunkCompletionString(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionChunkCompletionString(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_getCompletionChunkCompletionString";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionChunkCompletionString

using Entity_clang_getCompletionChunkCompletionString =
    Bind_clang_getCompletionChunkCompletionString<>;

#else

struct Entity_clang_getCompletionChunkCompletionString
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionChunkCompletionString(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_getCompletionChunkCompletionString";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionChunkCompletionString

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionChunkKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the kind of a particular chunk within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the kind of the chunk at the index \c chunk_number.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionChunkKind_AddFunction
    handle.def(
        "clang_getCompletionChunkKind",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string,
           unsigned int chunk_number) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXCompletionChunkKind(void *, unsigned int)>::type>(
                  &clang_getCompletionChunkKind),
              (completion_string)->Cptr(), chunk_number);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionChunkKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionChunkKind(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionChunkKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionChunkKind

using Entity_clang_getCompletionChunkKind = Bind_clang_getCompletionChunkKind<>;

#else

struct Entity_clang_getCompletionChunkKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionChunkKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionChunkKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionChunkKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionChunkText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the text associated with a particular chunk within a
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the text associated with the chunk at index \c chunk_number.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionChunkText_AddFunction
    handle.def(
        "clang_getCompletionChunkText",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string,
           unsigned int chunk_number) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, unsigned int)>::type>(
                                 &clang_getCompletionChunkText),
                             (completion_string)->Cptr(), chunk_number);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionChunkText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionChunkText(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionChunkText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionChunkText

using Entity_clang_getCompletionChunkText = Bind_clang_getCompletionChunkText<>;

#else

struct Entity_clang_getCompletionChunkText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionChunkText(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionChunkText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionChunkText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionFixIt : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Fix-its that *must* be applied before inserting the text for the
 * corresponding completion.
 *
 * By default, clang_codeCompleteAt() only returns completions with empty
 * fix-its. Extra completions with non-empty fix-its should be explicitly
 * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.
 *
 * For the clients to be able to compute position of the cursor after applying
 * fix-its, the following conditions are guaranteed to hold for
 * replacement_range of the stored fix-its:
 *  - Ranges in the fix-its are guaranteed to never contain the completion
 *  point (or identifier under completion point, if any) inside them, except
 *  at the start or at the end of the range.
 *  - If a fix-it range starts or ends with completion point (or starts or
 *  ends after the identifier under completion point), it will contain at
 *  least one character. It allows to unambiguously recompute completion
 *  point after applying the fix-it.
 *
 * The intuition is that provided fix-its change code around the identifier we
 * complete, but are not allowed to touch the identifier itself or the
 * completion point. One example of completions with corrections are the ones
 * replacing '.' with '->' and vice versa:
 *
 * std::unique_ptr<std::vector<int>> vec_ptr;
 * In 'vec_ptr.^', one of the completions is 'push_back', it requires
 * replacing '.' with '->'.
 * In 'vec_ptr->^', one of the completions is 'release', it requires
 * replacing '->' with '.'.
 *
 * \param results The structure keeping all completion results
 *
 * \param completion_index The index of the completion
 *
 * \param fixit_index The index of the fix-it for the completion at
 * completion_index
 *
 * \param replacement_range The fix-it range that must be replaced before the
 * completion at completion_index can be applied
 *
 * \returns The fix-it string that must replace the code at replacement_range
 * before the completion at completion_index can be applied
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionFixIt_AddFunction
    handle.def(
        "clang_getCompletionFixIt",
        static_cast<pybind11_weaver::FnPtrT<
            void, CXString(CXCodeCompleteResults *, unsigned int, unsigned int,
                           CXSourceRange *)>::type>(&clang_getCompletionFixIt),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionFixIt(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionFixIt(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionFixIt"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionFixIt

using Entity_clang_getCompletionFixIt = Bind_clang_getCompletionFixIt<>;

#else

struct Entity_clang_getCompletionFixIt
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionFixIt(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionFixIt"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionFixIt

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionNumAnnotations : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the number of annotations associated with the given
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \returns the number of annotations associated with the given completion
 * string.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionNumAnnotations_AddFunction
    handle.def(
        "clang_getCompletionNumAnnotations",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_getCompletionNumAnnotations),
              (completion_string)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionNumAnnotations(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionNumAnnotations(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionNumAnnotations"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionNumAnnotations

using Entity_clang_getCompletionNumAnnotations =
    Bind_clang_getCompletionNumAnnotations<>;

#else

struct Entity_clang_getCompletionNumAnnotations
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionNumAnnotations(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionNumAnnotations"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionNumAnnotations

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionNumFixIts : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the number of fix-its for the given completion index.
 *
 * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts
 * option was set.
 *
 * \param results The structure keeping all completion results
 *
 * \param completion_index The index of the completion
 *
 * \return The number of fix-its which must be applied before the completion at
 * completion_index can be applied
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionNumFixIts_AddFunction
    handle.def(
        "clang_getCompletionNumFixIts",
        static_cast<pybind11_weaver::FnPtrT<
            void, unsigned int(CXCodeCompleteResults *, unsigned int)>::type>(
            &clang_getCompletionNumFixIts),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionNumFixIts(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionNumFixIts(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionNumFixIts"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionNumFixIts

using Entity_clang_getCompletionNumFixIts = Bind_clang_getCompletionNumFixIts<>;

#else

struct Entity_clang_getCompletionNumFixIts
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionNumFixIts(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionNumFixIts"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionNumFixIts

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionParent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the parent context of the given completion string.
 *
 * The parent context of a completion string is the semantic parent of
 * the declaration (if any) that the code completion represents. For example,
 * a code completion for an Objective-C method would have the method's class
 * or protocol as its context.
 *
 * \param completion_string The code completion string whose parent is
 * being queried.
 *
 * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.
 *
 * \returns The name of the completion parent, e.g., "NSObject" if
 * the completion string represents a method in the NSObject class.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionParent_AddFunction
    handle.def(
        "clang_getCompletionParent",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string,
           CXCursorKind *kind) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, CXCursorKind *)>::type>(
                                 &clang_getCompletionParent),
                             (completion_string)->Cptr(), kind);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionParent(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionParent(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionParent"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionParent

using Entity_clang_getCompletionParent = Bind_clang_getCompletionParent<>;

#else

struct Entity_clang_getCompletionParent
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionParent(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionParent"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionParent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCompletionPriority : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the priority of this code completion.
 *
 * The priority of a code completion indicates how likely it is that this
 * particular completion is the completion that the user will select. The
 * priority is selected by various internal heuristics.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The priority of this completion string. Smaller values indicate
 * higher-priority (more likely) completions.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCompletionPriority_AddFunction
    handle.def(
        "clang_getCompletionPriority",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_getCompletionPriority),
              (completion_string)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCompletionPriority(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCompletionPriority(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCompletionPriority"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCompletionPriority

using Entity_clang_getCompletionPriority = Bind_clang_getCompletionPriority<>;

#else

struct Entity_clang_getCompletionPriority
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCompletionPriority(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCompletionPriority"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCompletionPriority

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Map a source location to the cursor that describes the entity at that
 * location in the source code.
 *
 * clang_getCursor() maps an arbitrary source location within a translation
 * unit down to the most specific cursor that describes the entity at that
 * location. For example, given an expression \c x + y, invoking
 * clang_getCursor() with a source location pointing to "x" will return the
 * cursor for "x"; similarly for "y". If the cursor points anywhere between
 * "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()
 * will return a cursor referring to the "+" expression.
 *
 * \returns a cursor representing the entity at the given source location, or
 * a NULL cursor if no such entity can be found.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursor_AddFunction
    handle.def(
        "clang_getCursor",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0,
           CXSourceLocation arg1) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXCursor(CXTranslationUnitImpl *,
                                 CXSourceLocation)>::type>(&clang_getCursor),
              (arg0)->Cptr(), arg1);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursor(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursor

using Entity_clang_getCursor = Bind_clang_getCursor<>;

#else

struct Entity_clang_getCursor : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursor(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorAvailability : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the availability of the entity that this cursor refers to,
 * taking the current target platform into account.
 *
 * \param cursor The cursor to query.
 *
 * \returns The availability of the cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorAvailability_AddFunction
    handle.def(
        "clang_getCursorAvailability",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXAvailabilityKind(CXCursor)>::type>(
            &clang_getCursorAvailability),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorAvailability(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorAvailability(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorAvailability"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorAvailability

using Entity_clang_getCursorAvailability = Bind_clang_getCursorAvailability<>;

#else

struct Entity_clang_getCursorAvailability
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorAvailability(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorAvailability"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorAvailability

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorCompletionString : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a completion string for an arbitrary declaration or macro
 * definition cursor.
 *
 * \param cursor The cursor to query.
 *
 * \returns A non-context-sensitive completion string for declaration and macro
 * definition cursors, or NULL for other kinds of cursors.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorCompletionString_AddFunction
    handle.def(
        "clang_getCursorCompletionString",
        [](CXCursor cursor) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void *(CXCursor)>::type>(
                  &clang_getCursorCompletionString),
              cursor);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorCompletionString(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorCompletionString(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorCompletionString"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorCompletionString

using Entity_clang_getCursorCompletionString =
    Bind_clang_getCursorCompletionString<>;

#else

struct Entity_clang_getCursorCompletionString
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorCompletionString(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorCompletionString"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorCompletionString

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorDefinition : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 *  For a cursor that is either a reference to or a declaration
 *  of some entity, retrieve a cursor that describes the definition of
 *  that entity.
 *
 *  Some entities can be declared multiple times within a translation
 *  unit, but only one of those declarations can also be a
 *  definition. For example, given:
 *
 *  \code
 *  int f(int, int);
 *  int g(int x, int y) { return f(x, y); }
 *  int f(int a, int b) { return a + b; }
 *  int f(int, int);
 *  \endcode
 *
 *  there are three declarations of the function "f", but only the
 *  second one is a definition. The clang_getCursorDefinition()
 *  function will take any cursor pointing to a declaration of "f"
 *  (the first or fourth lines of the example) or a cursor referenced
 *  that uses "f" (the call to "f' inside "g") and will return a
 *  declaration cursor pointing to the definition (the second "f"
 *  declaration).
 *
 *  If given a cursor for which there is no corresponding definition,
 *  e.g., because there is no definition of that entity within this
 *  translation unit, returns a NULL cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorDefinition_AddFunction
    handle.def(
        "clang_getCursorDefinition",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXCursor)>::type>(
            &clang_getCursorDefinition),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorDefinition(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorDefinition(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorDefinition"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorDefinition

using Entity_clang_getCursorDefinition = Bind_clang_getCursorDefinition<>;

#else

struct Entity_clang_getCursorDefinition
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorDefinition(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorDefinition"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorDefinition

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorDisplayName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the display name for the entity referenced by this cursor.
 *
 * The display name contains extra information that helps identify the cursor,
 * such as the parameters of a function or template or the arguments of a
 * class template specialization.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorDisplayName_AddFunction
    handle.def(
        "clang_getCursorDisplayName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_getCursorDisplayName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorDisplayName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorDisplayName(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorDisplayName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorDisplayName

using Entity_clang_getCursorDisplayName = Bind_clang_getCursorDisplayName<>;

#else

struct Entity_clang_getCursorDisplayName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorDisplayName(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorDisplayName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorDisplayName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorExceptionSpecificationType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the exception specification type associated with a given cursor.
 * This is a value of type CXCursor_ExceptionSpecificationKind.
 *
 * This only returns a valid result if the cursor refers to a function or
 * method.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorExceptionSpecificationType_AddFunction
    handle.def("clang_getCursorExceptionSpecificationType",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_getCursorExceptionSpecificationType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorExceptionSpecificationType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorExceptionSpecificationType(EntityScope parent_h,
                                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_getCursorExceptionSpecificationType";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorExceptionSpecificationType

using Entity_clang_getCursorExceptionSpecificationType =
    Bind_clang_getCursorExceptionSpecificationType<>;

#else

struct Entity_clang_getCursorExceptionSpecificationType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorExceptionSpecificationType(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_getCursorExceptionSpecificationType";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorExceptionSpecificationType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorExtent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the physical extent of the source construct referenced by
 * the given cursor.
 *
 * The extent of a cursor starts with the file/line/column pointing at the
 * first character within the source construct that the cursor refers to and
 * ends with the last character within that source construct. For a
 * declaration, the extent covers the declaration itself. For a reference,
 * the extent covers the location of the reference (e.g., where the referenced
 * entity was actually used).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorExtent_AddFunction
    handle.def(
        "clang_getCursorExtent",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXSourceRange(CXCursor)>::type>(
            &clang_getCursorExtent),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorExtent(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorExtent(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorExtent"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorExtent

using Entity_clang_getCursorExtent = Bind_clang_getCursorExtent<>;

#else

struct Entity_clang_getCursorExtent : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorExtent(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorExtent"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorExtent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the kind of the given cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorKind_AddFunction
    handle.def("clang_getCursorKind",
               static_cast<
                   pybind11_weaver::FnPtrT<void, CXCursorKind(CXCursor)>::type>(
                   &clang_getCursorKind),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorKind

using Entity_clang_getCursorKind = Bind_clang_getCursorKind<>;

#else

struct Entity_clang_getCursorKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorKindSpelling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/* for debug/testing */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorKindSpelling_AddFunction
    handle.def("clang_getCursorKindSpelling",
               static_cast<
                   pybind11_weaver::FnPtrT<void, CXString(CXCursorKind)>::type>(
                   &clang_getCursorKindSpelling),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorKindSpelling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorKindSpelling(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorKindSpelling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorKindSpelling

using Entity_clang_getCursorKindSpelling = Bind_clang_getCursorKindSpelling<>;

#else

struct Entity_clang_getCursorKindSpelling
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorKindSpelling(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorKindSpelling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorKindSpelling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorLanguage : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the "language" of the entity referred to by a given cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorLanguage_AddFunction
    handle.def(
        "clang_getCursorLanguage",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXLanguageKind(CXCursor)>::type>(
            &clang_getCursorLanguage),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorLanguage(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorLanguage(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorLanguage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorLanguage

using Entity_clang_getCursorLanguage = Bind_clang_getCursorLanguage<>;

#else

struct Entity_clang_getCursorLanguage : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorLanguage(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorLanguage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorLanguage

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorLexicalParent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the lexical parent of the given cursor.
 *
 * The lexical parent of a cursor is the cursor in which the given \p cursor
 * was actually written. For many declarations, the lexical and semantic parents
 * are equivalent (the semantic parent is returned by
 * \c clang_getCursorSemanticParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 *  void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For declarations written in the global scope, the lexical parent is
 * the translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorLexicalParent_AddFunction
    handle.def(
        "clang_getCursorLexicalParent",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXCursor)>::type>(
            &clang_getCursorLexicalParent),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorLexicalParent(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorLexicalParent(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorLexicalParent"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorLexicalParent

using Entity_clang_getCursorLexicalParent = Bind_clang_getCursorLexicalParent<>;

#else

struct Entity_clang_getCursorLexicalParent
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorLexicalParent(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorLexicalParent"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorLexicalParent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorLinkage : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the linkage of the entity referred to by a given cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorLinkage_AddFunction
    handle.def(
        "clang_getCursorLinkage",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXLinkageKind(CXCursor)>::type>(
            &clang_getCursorLinkage),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorLinkage(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorLinkage(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorLinkage"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorLinkage

using Entity_clang_getCursorLinkage = Bind_clang_getCursorLinkage<>;

#else

struct Entity_clang_getCursorLinkage : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorLinkage(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorLinkage"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorLinkage

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the physical location of the source constructor referenced
 * by the given cursor.
 *
 * The location of a declaration is typically the location of the name of that
 * declaration, where the name of that declaration would occur if it is
 * unnamed, or some keyword that introduces that particular declaration.
 * The location of a reference is where that reference occurs within the
 * source code.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorLocation_AddFunction
    handle.def(
        "clang_getCursorLocation",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXSourceLocation(CXCursor)>::type>(
            &clang_getCursorLocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorLocation(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorLocation

using Entity_clang_getCursorLocation = Bind_clang_getCursorLocation<>;

#else

struct Entity_clang_getCursorLocation : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorPlatformAvailability : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the availability of the entity that this cursor refers to
 * on any platforms for which availability information is known.
 *
 * \param cursor The cursor to query.
 *
 * \param always_deprecated If non-NULL, will be set to indicate whether the
 * entity is deprecated on all platforms.
 *
 * \param deprecated_message If non-NULL, will be set to the message text
 * provided along with the unconditional deprecation of this entity. The client
 * is responsible for deallocating this string.
 *
 * \param always_unavailable If non-NULL, will be set to indicate whether the
 * entity is unavailable on all platforms.
 *
 * \param unavailable_message If non-NULL, will be set to the message text
 * provided along with the unconditional unavailability of this entity. The
 * client is responsible for deallocating this string.
 *
 * \param availability If non-NULL, an array of CXPlatformAvailability instances
 * that will be populated with platform availability information, up to either
 * the number of platforms for which availability information is available (as
 * returned by this function) or \c availability_size, whichever is smaller.
 *
 * \param availability_size The number of elements available in the
 * \c availability array.
 *
 * \returns The number of platforms (N) for which availability information is
 * available (which is unrelated to \c availability_size).
 *
 * Note that the client is responsible for calling
 * \c clang_disposeCXPlatformAvailability to free each of the
 * platform-availability structures returned. There are
 * \c min(N, availability_size) such structures.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorPlatformAvailability_AddFunction
    handle.def("clang_getCursorPlatformAvailability",
               static_cast<pybind11_weaver::FnPtrT<
                   void, int(CXCursor, int *, CXString *, int *, CXString *,
                             CXPlatformAvailability *, int)>::type>(
                   &clang_getCursorPlatformAvailability),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorPlatformAvailability(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorPlatformAvailability(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorPlatformAvailability"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorPlatformAvailability

using Entity_clang_getCursorPlatformAvailability =
    Bind_clang_getCursorPlatformAvailability<>;

#else

struct Entity_clang_getCursorPlatformAvailability
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorPlatformAvailability(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorPlatformAvailability"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorPlatformAvailability

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorPrettyPrinted : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Pretty print declarations.
 *
 * \param Cursor The cursor representing a declaration.
 *
 * \param Policy The policy to control the entities being printed. If
 * NULL, a default policy is used.
 *
 * \returns The pretty printed declaration or the empty string for
 * other cursors.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorPrettyPrinted_AddFunction
    handle.def(
        "clang_getCursorPrettyPrinted",
        [](CXCursor Cursor, pybind11_weaver::WrappedPtrT<void *> Policy) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(CXCursor, void *)>::type>(
                                 &clang_getCursorPrettyPrinted),
                             Cursor, (Policy)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorPrettyPrinted(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorPrettyPrinted(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorPrettyPrinted"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorPrettyPrinted

using Entity_clang_getCursorPrettyPrinted = Bind_clang_getCursorPrettyPrinted<>;

#else

struct Entity_clang_getCursorPrettyPrinted
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorPrettyPrinted(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorPrettyPrinted"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorPrettyPrinted

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorPrintingPolicy : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the default policy for the cursor.
 *
 * The policy should be released after use with \c
 * clang_PrintingPolicy_dispose.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorPrintingPolicy_AddFunction
    handle.def(
        "clang_getCursorPrintingPolicy",
        [](CXCursor arg0) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void *(CXCursor)>::type>(
                  &clang_getCursorPrintingPolicy),
              arg0);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorPrintingPolicy(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorPrintingPolicy(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorPrintingPolicy"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorPrintingPolicy

using Entity_clang_getCursorPrintingPolicy =
    Bind_clang_getCursorPrintingPolicy<>;

#else

struct Entity_clang_getCursorPrintingPolicy
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorPrintingPolicy(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorPrintingPolicy"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorPrintingPolicy

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorReferenceNameRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that references something else, return the source range
 * covering that reference.
 *
 * \param C A cursor pointing to a member reference, a declaration reference, or
 * an operator call.
 * \param NameFlags A bitset with three independent flags:
 * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and
 * CXNameRange_WantSinglePiece.
 * \param PieceIndex For contiguous names or when passing the flag
 * CXNameRange_WantSinglePiece, only one piece with index 0 is
 * available. When the CXNameRange_WantSinglePiece flag is not passed for a
 * non-contiguous names, this index can be used to retrieve the individual
 * pieces of the name. See also CXNameRange_WantSinglePiece.
 *
 * \returns The piece of the name pointed to by the given cursor. If there is no
 * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorReferenceNameRange_AddFunction
    handle.def(
        "clang_getCursorReferenceNameRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, CXSourceRange(CXCursor, unsigned int, unsigned int)>::type>(
            &clang_getCursorReferenceNameRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorReferenceNameRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorReferenceNameRange(EntityScope parent_h,
                                                  HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorReferenceNameRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorReferenceNameRange

using Entity_clang_getCursorReferenceNameRange =
    Bind_clang_getCursorReferenceNameRange<>;

#else

struct Entity_clang_getCursorReferenceNameRange
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorReferenceNameRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorReferenceNameRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorReferenceNameRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorReferenced : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str =
        R"_pb11_weaver(/** For a cursor that is a reference, retrieve a cursor representing the
 * entity that it references.
 *
 * Reference cursors refer to other entities in the AST. For example, an
 * Objective-C superclass reference cursor refers to an Objective-C class.
 * This function produces the cursor for the Objective-C class from the
 * cursor for the superclass reference. If the input cursor is a declaration or
 * definition, it returns that declaration or definition unchanged.
 * Otherwise, returns the NULL cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorReferenced_AddFunction
    handle.def(
        "clang_getCursorReferenced",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXCursor)>::type>(
            &clang_getCursorReferenced),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorReferenced(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorReferenced(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorReferenced"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorReferenced

using Entity_clang_getCursorReferenced = Bind_clang_getCursorReferenced<>;

#else

struct Entity_clang_getCursorReferenced
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorReferenced(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorReferenced"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorReferenced

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorResultType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the return type associated with a given cursor.
 *
 * This only returns a valid type if the cursor refers to a function or method.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorResultType_AddFunction
    handle.def(
        "clang_getCursorResultType",
        static_cast<pybind11_weaver::FnPtrT<void, CXType(CXCursor)>::type>(
            &clang_getCursorResultType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorResultType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorResultType(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorResultType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorResultType

using Entity_clang_getCursorResultType = Bind_clang_getCursorResultType<>;

#else

struct Entity_clang_getCursorResultType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorResultType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorResultType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorResultType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorSemanticParent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the semantic parent of the given cursor.
 *
 * The semantic parent of a cursor is the cursor that semantically contains
 * the given \p cursor. For many declarations, the lexical and semantic parents
 * are equivalent (the lexical parent is returned by
 * \c clang_getCursorLexicalParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 *  void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For global declarations, the semantic parent is the translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorSemanticParent_AddFunction
    handle.def(
        "clang_getCursorSemanticParent",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXCursor)>::type>(
            &clang_getCursorSemanticParent),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorSemanticParent(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorSemanticParent(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorSemanticParent"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorSemanticParent

using Entity_clang_getCursorSemanticParent =
    Bind_clang_getCursorSemanticParent<>;

#else

struct Entity_clang_getCursorSemanticParent
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorSemanticParent(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorSemanticParent"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorSemanticParent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorSpelling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a name for the entity referenced by this cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorSpelling_AddFunction
    handle.def(
        "clang_getCursorSpelling",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_getCursorSpelling),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorSpelling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorSpelling(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorSpelling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorSpelling

using Entity_clang_getCursorSpelling = Bind_clang_getCursorSpelling<>;

#else

struct Entity_clang_getCursorSpelling : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorSpelling(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorSpelling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorSpelling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorTLSKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the "thread-local storage (TLS) kind" of the declaration
 * referred to by a cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorTLSKind_AddFunction
    handle.def(
        "clang_getCursorTLSKind",
        static_cast<pybind11_weaver::FnPtrT<void, CXTLSKind(CXCursor)>::type>(
            &clang_getCursorTLSKind),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorTLSKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorTLSKind(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorTLSKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorTLSKind

using Entity_clang_getCursorTLSKind = Bind_clang_getCursorTLSKind<>;

#else

struct Entity_clang_getCursorTLSKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorTLSKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorTLSKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorTLSKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the type of a CXCursor (if any).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorType_AddFunction
    handle.def(
        "clang_getCursorType",
        static_cast<pybind11_weaver::FnPtrT<void, CXType(CXCursor)>::type>(
            &clang_getCursorType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorType(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorType

using Entity_clang_getCursorType = Bind_clang_getCursorType<>;

#else

struct Entity_clang_getCursorType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorUSR : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a Unified Symbol Resolution (USR) for the entity referenced
 * by the given cursor.
 *
 * A Unified Symbol Resolution (USR) is a string that identifies a particular
 * entity (function, class, variable, etc.) within a program. USRs can be
 * compared across translation units to determine, e.g., when references in
 * one translation refer to an entity defined in another translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorUSR_AddFunction
    handle.def(
        "clang_getCursorUSR",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_getCursorUSR),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorUSR(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorUSR(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorUSR"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorUSR

using Entity_clang_getCursorUSR = Bind_clang_getCursorUSR<>;

#else

struct Entity_clang_getCursorUSR : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorUSR(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorUSR"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorUSR

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getCursorVisibility : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Describe the visibility of the entity referred to by a cursor.
 *
 * This returns the default visibility if not explicitly specified by
 * a visibility attribute. The default visibility may be changed by
 * commandline arguments.
 *
 * \param cursor The cursor to query.
 *
 * \returns The visibility of the cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getCursorVisibility_AddFunction
    handle.def(
        "clang_getCursorVisibility",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXVisibilityKind(CXCursor)>::type>(
            &clang_getCursorVisibility),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getCursorVisibility(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getCursorVisibility(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getCursorVisibility"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getCursorVisibility

using Entity_clang_getCursorVisibility = Bind_clang_getCursorVisibility<>;

#else

struct Entity_clang_getCursorVisibility
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getCursorVisibility(EntityScope parent_h) {}
  static const char *Key() { return "clang_getCursorVisibility"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getCursorVisibility

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDeclObjCTypeEncoding : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the Objective-C type encoding for the specified declaration.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDeclObjCTypeEncoding_AddFunction
    handle.def(
        "clang_getDeclObjCTypeEncoding",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_getDeclObjCTypeEncoding),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDeclObjCTypeEncoding(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDeclObjCTypeEncoding(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDeclObjCTypeEncoding"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDeclObjCTypeEncoding

using Entity_clang_getDeclObjCTypeEncoding =
    Bind_clang_getDeclObjCTypeEncoding<>;

#else

struct Entity_clang_getDeclObjCTypeEncoding
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDeclObjCTypeEncoding(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDeclObjCTypeEncoding"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDeclObjCTypeEncoding

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDefinitionSpellingAndExtent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_getDefinitionSpellingAndExtent_AddFunction
    handle.def("clang_getDefinitionSpellingAndExtent",
               [](CXCursor arg0,
                  pybind11_weaver::WrappedPtrT<const char **> startBuf,
                  pybind11_weaver::WrappedPtrT<const char **> endBuf,
                  unsigned int *startLine, unsigned int *startColumn,
                  unsigned int *endLine, unsigned int *endColumn) {
                 return std::invoke(
                     static_cast<pybind11_weaver::FnPtrT<
                         void, void(CXCursor, const char **, const char **,
                                    unsigned int *, unsigned int *,
                                    unsigned int *, unsigned int *)>::type>(
                         &clang_getDefinitionSpellingAndExtent),
                     arg0, (startBuf)->Cptr(), (endBuf)->Cptr(), startLine,
                     startColumn, endLine, endColumn);
               });
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDefinitionSpellingAndExtent(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDefinitionSpellingAndExtent(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDefinitionSpellingAndExtent"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDefinitionSpellingAndExtent

using Entity_clang_getDefinitionSpellingAndExtent =
    Bind_clang_getDefinitionSpellingAndExtent<>;

#else

struct Entity_clang_getDefinitionSpellingAndExtent
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDefinitionSpellingAndExtent(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDefinitionSpellingAndExtent"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDefinitionSpellingAndExtent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnostic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a diagnostic associated with the given translation unit.
 *
 * \param Unit the translation unit to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnostic_AddFunction
    handle.def(
        "clang_getDiagnostic",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> Unit,
           unsigned int Index) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void *(CXTranslationUnitImpl *, unsigned int)>::type>(
                  &clang_getDiagnostic),
              (Unit)->Cptr(), Index);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnostic(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnostic(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnostic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnostic

using Entity_clang_getDiagnostic = Bind_clang_getDiagnostic<>;

#else

struct Entity_clang_getDiagnostic : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnostic(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnostic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnostic

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticCategory : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the category number for this diagnostic.
 *
 * Diagnostics can be categorized into groups along with other, related
 * diagnostics (e.g., diagnostics under the same warning flag). This routine
 * retrieves the category number for the given diagnostic.
 *
 * \returns The number of the category that contains this diagnostic, or zero
 * if this diagnostic is uncategorized.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticCategory_AddFunction
    handle.def(
        "clang_getDiagnosticCategory",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_getDiagnosticCategory),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticCategory(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticCategory(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticCategory"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticCategory

using Entity_clang_getDiagnosticCategory = Bind_clang_getDiagnosticCategory<>;

#else

struct Entity_clang_getDiagnosticCategory
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticCategory(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticCategory"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticCategory

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticCategoryName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the name of a particular diagnostic category.  This
 *  is now deprecated.  Use clang_getDiagnosticCategoryText()
 *  instead.
 *
 * \param Category A diagnostic category number, as returned by
 * \c clang_getDiagnosticCategory().
 *
 * \returns The name of the given diagnostic category.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticCategoryName_AddFunction
    handle.def("clang_getDiagnosticCategoryName",
               static_cast<
                   pybind11_weaver::FnPtrT<void, CXString(unsigned int)>::type>(
                   &clang_getDiagnosticCategoryName),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticCategoryName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticCategoryName(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticCategoryName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticCategoryName

using Entity_clang_getDiagnosticCategoryName =
    Bind_clang_getDiagnosticCategoryName<>;

#else

struct Entity_clang_getDiagnosticCategoryName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticCategoryName(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticCategoryName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticCategoryName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticCategoryText : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the diagnostic category text for a given diagnostic.
 *
 * \returns The text of the given diagnostic category.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticCategoryText_AddFunction
    handle.def(
        "clang_getDiagnosticCategoryText",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_getDiagnosticCategoryText),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticCategoryText(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticCategoryText(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticCategoryText"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticCategoryText

using Entity_clang_getDiagnosticCategoryText =
    Bind_clang_getDiagnosticCategoryText<>;

#else

struct Entity_clang_getDiagnosticCategoryText
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticCategoryText(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticCategoryText"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticCategoryText

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticFixIt : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the replacement information for a given fix-it.
 *
 * Fix-its are described in terms of a source range whose contents
 * should be replaced by a string. This approach generalizes over
 * three kinds of operations: removal of source code (the range covers
 * the code to be removed and the replacement string is empty),
 * replacement of source code (the range covers the code to be
 * replaced and the replacement string provides the new code), and
 * insertion (both the start and end of the range point at the
 * insertion location, and the replacement string provides the text to
 * insert).
 *
 * \param Diagnostic The diagnostic whose fix-its are being queried.
 *
 * \param FixIt The zero-based index of the fix-it.
 *
 * \param ReplacementRange The source range whose contents will be
 * replaced with the returned replacement string. Note that source
 * ranges are half-open ranges [a, b), so the source code should be
 * replaced from a and up to (but not including) b.
 *
 * \returns A string containing text that should be replace the source
 * code indicated by the \c ReplacementRange.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticFixIt_AddFunction
    handle.def(
        "clang_getDiagnosticFixIt",
        [](pybind11_weaver::WrappedPtrT<void *> Diagnostic, unsigned int FixIt,
           CXSourceRange *ReplacementRange) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXString(void *, unsigned int, CXSourceRange *)>::type>(
                  &clang_getDiagnosticFixIt),
              (Diagnostic)->Cptr(), FixIt, ReplacementRange);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticFixIt(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticFixIt(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticFixIt"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticFixIt

using Entity_clang_getDiagnosticFixIt = Bind_clang_getDiagnosticFixIt<>;

#else

struct Entity_clang_getDiagnosticFixIt
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticFixIt(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticFixIt"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticFixIt

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticInSet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a diagnostic associated with the given CXDiagnosticSet.
 *
 * \param Diags the CXDiagnosticSet to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticInSet_AddFunction
    handle.def(
        "clang_getDiagnosticInSet",
        [](pybind11_weaver::WrappedPtrT<void *> Diags, unsigned int Index) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(void *, unsigned int)>::type>(
                              &clang_getDiagnosticInSet),
                          (Diags)->Cptr(), Index);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticInSet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticInSet(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticInSet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticInSet

using Entity_clang_getDiagnosticInSet = Bind_clang_getDiagnosticInSet<>;

#else

struct Entity_clang_getDiagnosticInSet
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticInSet(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticInSet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticInSet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the source location of the given diagnostic.
 *
 * This location is where Clang would print the caret ('^') when
 * displaying the diagnostic on the command line.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticLocation_AddFunction
    handle.def(
        "clang_getDiagnosticLocation",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXSourceLocation(void *)>::type>(
                                 &clang_getDiagnosticLocation),
                             (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticLocation(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticLocation

using Entity_clang_getDiagnosticLocation = Bind_clang_getDiagnosticLocation<>;

#else

struct Entity_clang_getDiagnosticLocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticNumFixIts : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the number of fix-it hints associated with the
 * given diagnostic.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticNumFixIts_AddFunction
    handle.def(
        "clang_getDiagnosticNumFixIts",
        [](pybind11_weaver::WrappedPtrT<void *> Diagnostic) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_getDiagnosticNumFixIts),
              (Diagnostic)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticNumFixIts(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticNumFixIts(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticNumFixIts"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticNumFixIts

using Entity_clang_getDiagnosticNumFixIts = Bind_clang_getDiagnosticNumFixIts<>;

#else

struct Entity_clang_getDiagnosticNumFixIts
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticNumFixIts(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticNumFixIts"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticNumFixIts

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticNumRanges : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the number of source ranges associated with the given
 * diagnostic.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticNumRanges_AddFunction
    handle.def(
        "clang_getDiagnosticNumRanges",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_getDiagnosticNumRanges),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticNumRanges(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticNumRanges(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticNumRanges"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticNumRanges

using Entity_clang_getDiagnosticNumRanges = Bind_clang_getDiagnosticNumRanges<>;

#else

struct Entity_clang_getDiagnosticNumRanges
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticNumRanges(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticNumRanges"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticNumRanges

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticOption : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the name of the command-line option that enabled this
 * diagnostic.
 *
 * \param Diag The diagnostic to be queried.
 *
 * \param Disable If non-NULL, will be set to the option that disables this
 * diagnostic (if any).
 *
 * \returns A string that contains the command-line option used to enable this
 * warning, such as "-Wconversion" or "-pedantic".
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticOption_AddFunction
    handle.def(
        "clang_getDiagnosticOption",
        [](pybind11_weaver::WrappedPtrT<void *> Diag, CXString *Disable) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXString(void *, CXString *)>::type>(
                                 &clang_getDiagnosticOption),
                             (Diag)->Cptr(), Disable);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticOption(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticOption(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticOption"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticOption

using Entity_clang_getDiagnosticOption = Bind_clang_getDiagnosticOption<>;

#else

struct Entity_clang_getDiagnosticOption
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticOption(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticOption"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticOption

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a source range associated with the diagnostic.
 *
 * A diagnostic's source ranges highlight important elements in the source
 * code. On the command line, Clang displays source ranges by
 * underlining them with '~' characters.
 *
 * \param Diagnostic the diagnostic whose range is being extracted.
 *
 * \param Range the zero-based index specifying which range to
 *
 * \returns the requested source range.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticRange_AddFunction
    handle.def(
        "clang_getDiagnosticRange",
        [](pybind11_weaver::WrappedPtrT<void *> Diagnostic,
           unsigned int Range) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXSourceRange(void *, unsigned int)>::type>(
                  &clang_getDiagnosticRange),
              (Diagnostic)->Cptr(), Range);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticRange(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticRange

using Entity_clang_getDiagnosticRange = Bind_clang_getDiagnosticRange<>;

#else

struct Entity_clang_getDiagnosticRange
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticSetFromTU : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the complete set of diagnostics associated with a
 *        translation unit.
 *
 * \param Unit the translation unit to query.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticSetFromTU_AddFunction
    handle.def(
        "clang_getDiagnosticSetFromTU",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> Unit) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(CXTranslationUnitImpl *)>::type>(
                              &clang_getDiagnosticSetFromTU),
                          (Unit)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticSetFromTU(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticSetFromTU(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticSetFromTU"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticSetFromTU

using Entity_clang_getDiagnosticSetFromTU = Bind_clang_getDiagnosticSetFromTU<>;

#else

struct Entity_clang_getDiagnosticSetFromTU
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticSetFromTU(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticSetFromTU"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticSetFromTU

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticSeverity : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the severity of the given diagnostic.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticSeverity_AddFunction
    handle.def(
        "clang_getDiagnosticSeverity",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXDiagnosticSeverity(void *)>::type>(
                                 &clang_getDiagnosticSeverity),
                             (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticSeverity(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticSeverity(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticSeverity"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticSeverity

using Entity_clang_getDiagnosticSeverity = Bind_clang_getDiagnosticSeverity<>;

#else

struct Entity_clang_getDiagnosticSeverity
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticSeverity(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticSeverity"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticSeverity

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getDiagnosticSpelling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the text of the given diagnostic.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getDiagnosticSpelling_AddFunction
    handle.def(
        "clang_getDiagnosticSpelling",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_getDiagnosticSpelling),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getDiagnosticSpelling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getDiagnosticSpelling(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getDiagnosticSpelling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticSpelling

using Entity_clang_getDiagnosticSpelling = Bind_clang_getDiagnosticSpelling<>;

#else

struct Entity_clang_getDiagnosticSpelling
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getDiagnosticSpelling(EntityScope parent_h) {}
  static const char *Key() { return "clang_getDiagnosticSpelling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getDiagnosticSpelling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getElementType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the element type of an array, complex, or vector type.
 *
 * If a type is passed in that is not an array, complex, or vector type,
 * an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getElementType_AddFunction
    handle.def("clang_getElementType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_getElementType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getElementType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getElementType(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getElementType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getElementType

using Entity_clang_getElementType = Bind_clang_getElementType<>;

#else

struct Entity_clang_getElementType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getElementType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getElementType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getElementType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getEnumConstantDeclUnsignedValue : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the integer value of an enum constant declaration as an unsigned
 *  long long.
 *
 * If the cursor does not reference an enum constant declaration, ULLONG_MAX is
 * returned. Since this is also potentially a valid constant value, the kind of
 * the cursor must be verified before calling this function.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getEnumConstantDeclUnsignedValue_AddFunction
    handle.def(
        "clang_getEnumConstantDeclUnsignedValue",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned long long(CXCursor)>::type>(
            &clang_getEnumConstantDeclUnsignedValue),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getEnumConstantDeclUnsignedValue(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getEnumConstantDeclUnsignedValue(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getEnumConstantDeclUnsignedValue"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getEnumConstantDeclUnsignedValue

using Entity_clang_getEnumConstantDeclUnsignedValue =
    Bind_clang_getEnumConstantDeclUnsignedValue<>;

#else

struct Entity_clang_getEnumConstantDeclUnsignedValue
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getEnumConstantDeclUnsignedValue(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_getEnumConstantDeclUnsignedValue"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getEnumConstantDeclUnsignedValue

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getEnumConstantDeclValue : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the integer value of an enum constant declaration as a signed
 *  long long.
 *
 * If the cursor does not reference an enum constant declaration, LLONG_MIN is
 * returned. Since this is also potentially a valid constant value, the kind of
 * the cursor must be verified before calling this function.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getEnumConstantDeclValue_AddFunction
    handle.def(
        "clang_getEnumConstantDeclValue",
        static_cast<pybind11_weaver::FnPtrT<void, long long(CXCursor)>::type>(
            &clang_getEnumConstantDeclValue),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getEnumConstantDeclValue(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getEnumConstantDeclValue(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getEnumConstantDeclValue"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getEnumConstantDeclValue

using Entity_clang_getEnumConstantDeclValue =
    Bind_clang_getEnumConstantDeclValue<>;

#else

struct Entity_clang_getEnumConstantDeclValue
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getEnumConstantDeclValue(EntityScope parent_h) {}
  static const char *Key() { return "clang_getEnumConstantDeclValue"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getEnumConstantDeclValue

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getEnumDeclIntegerType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the integer type of an enum declaration.
 *
 * If the cursor does not reference an enum declaration, an invalid type is
 * returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getEnumDeclIntegerType_AddFunction
    handle.def(
        "clang_getEnumDeclIntegerType",
        static_cast<pybind11_weaver::FnPtrT<void, CXType(CXCursor)>::type>(
            &clang_getEnumDeclIntegerType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getEnumDeclIntegerType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getEnumDeclIntegerType(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getEnumDeclIntegerType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getEnumDeclIntegerType

using Entity_clang_getEnumDeclIntegerType = Bind_clang_getEnumDeclIntegerType<>;

#else

struct Entity_clang_getEnumDeclIntegerType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getEnumDeclIntegerType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getEnumDeclIntegerType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getEnumDeclIntegerType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getExceptionSpecificationType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the exception specification type associated with a function type.
 * This is a value of type CXCursor_ExceptionSpecificationKind.
 *
 * If a non-function type is passed in, an error code of -1 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getExceptionSpecificationType_AddFunction
    handle.def("clang_getExceptionSpecificationType",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXType)>::type>(
                   &clang_getExceptionSpecificationType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getExceptionSpecificationType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getExceptionSpecificationType(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getExceptionSpecificationType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getExceptionSpecificationType

using Entity_clang_getExceptionSpecificationType =
    Bind_clang_getExceptionSpecificationType<>;

#else

struct Entity_clang_getExceptionSpecificationType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getExceptionSpecificationType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getExceptionSpecificationType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getExceptionSpecificationType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getExpansionLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getExpansionLocation_AddFunction
    handle.def(
        "clang_getExpansionLocation",
        [](CXSourceLocation location,
           pybind11_weaver::WrappedPtrT<void **> file, unsigned int *line,
           unsigned int *column, unsigned int *offset) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXSourceLocation, void **, unsigned int *,
                             unsigned int *, unsigned int *)>::type>(
                  &clang_getExpansionLocation),
              location, (file)->Cptr(), line, column, offset);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getExpansionLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getExpansionLocation(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getExpansionLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getExpansionLocation

using Entity_clang_getExpansionLocation = Bind_clang_getExpansionLocation<>;

#else

struct Entity_clang_getExpansionLocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getExpansionLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getExpansionLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getExpansionLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFieldDeclBitWidth : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the bit width of a bit field declaration as an integer.
 *
 * If a cursor that is not a bit field declaration is passed in, -1 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFieldDeclBitWidth_AddFunction
    handle.def("clang_getFieldDeclBitWidth",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXCursor)>::type>(
                   &clang_getFieldDeclBitWidth),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFieldDeclBitWidth(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFieldDeclBitWidth(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFieldDeclBitWidth"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFieldDeclBitWidth

using Entity_clang_getFieldDeclBitWidth = Bind_clang_getFieldDeclBitWidth<>;

#else

struct Entity_clang_getFieldDeclBitWidth
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFieldDeclBitWidth(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFieldDeclBitWidth"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFieldDeclBitWidth

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a file handle within the given translation unit.
 *
 * \param tu the translation unit
 *
 * \param file_name the name of the file.
 *
 * \returns the file handle for the named file in the translation unit \p tu,
 * or a NULL file handle if the file was not a part of this translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFile_AddFunction
    handle.def(
        "clang_getFile",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           const char *file_name) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void *(CXTranslationUnitImpl *, const char *)>::type>(
                  &clang_getFile),
              (tu)->Cptr(), file_name);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFile(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFile

using Entity_clang_getFile = Bind_clang_getFile<>;

#else

struct Entity_clang_getFile : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFileContents : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the buffer associated with the given file.
 *
 * \param tu the translation unit
 *
 * \param file the file for which to retrieve the buffer.
 *
 * \param size [out] if non-NULL, will be set to the size of the buffer.
 *
 * \returns a pointer to the buffer in memory that holds the contents of
 * \p file, or a NULL pointer when the file is not loaded.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFileContents_AddFunction
    handle.def(
        "clang_getFileContents",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           pybind11_weaver::WrappedPtrT<void *> file, unsigned long *size) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, const char *(CXTranslationUnitImpl *, void *,
                                     unsigned long *)>::type>(
                  &clang_getFileContents),
              (tu)->Cptr(), (file)->Cptr(), size);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFileContents(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFileContents(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFileContents"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFileContents

using Entity_clang_getFileContents = Bind_clang_getFileContents<>;

#else

struct Entity_clang_getFileContents : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFileContents(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFileContents"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFileContents

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFileLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, return where the macro was
 * expanded or where the macro argument was written, if the location points at
 * a macro argument.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFileLocation_AddFunction
    handle.def(
        "clang_getFileLocation",
        [](CXSourceLocation location,
           pybind11_weaver::WrappedPtrT<void **> file, unsigned int *line,
           unsigned int *column, unsigned int *offset) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXSourceLocation, void **, unsigned int *,
                             unsigned int *, unsigned int *)>::type>(
                  &clang_getFileLocation),
              location, (file)->Cptr(), line, column, offset);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFileLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFileLocation(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFileLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFileLocation

using Entity_clang_getFileLocation = Bind_clang_getFileLocation<>;

#else

struct Entity_clang_getFileLocation : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFileLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFileLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFileLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFileName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the complete file and path name of the given file.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFileName_AddFunction
    handle.def(
        "clang_getFileName",
        [](pybind11_weaver::WrappedPtrT<void *> SFile) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, CXString(void *)>::type>(
                  &clang_getFileName),
              (SFile)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFileName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFileName(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFileName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFileName

using Entity_clang_getFileName = Bind_clang_getFileName<>;

#else

struct Entity_clang_getFileName : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFileName(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFileName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFileName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFileTime : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the last modification time of the given file.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFileTime_AddFunction
    handle.def(
        "clang_getFileTime",
        [](pybind11_weaver::WrappedPtrT<void *> SFile) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, long(void *)>::type>(
                  &clang_getFileTime),
              (SFile)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFileTime(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFileTime(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFileTime"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFileTime

using Entity_clang_getFileTime = Bind_clang_getFileTime<>;

#else

struct Entity_clang_getFileTime : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFileTime(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFileTime"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFileTime

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFileUniqueID : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the unique ID for the given \c file.
 *
 * \param file the file to get the ID for.
 * \param outID stores the returned CXFileUniqueID.
 * \returns If there was a failure getting the unique ID, returns non-zero,
 * otherwise returns 0.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFileUniqueID_AddFunction
    handle.def(
        "clang_getFileUniqueID",
        [](pybind11_weaver::WrappedPtrT<void *> file, CXFileUniqueID *outID) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, int(void *, CXFileUniqueID *)>::type>(
                                 &clang_getFileUniqueID),
                             (file)->Cptr(), outID);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFileUniqueID(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFileUniqueID(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFileUniqueID"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFileUniqueID

using Entity_clang_getFileUniqueID = Bind_clang_getFileUniqueID<>;

#else

struct Entity_clang_getFileUniqueID : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFileUniqueID(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFileUniqueID"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFileUniqueID

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getFunctionTypeCallingConv : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the calling convention associated with a function type.
 *
 * If a non-function type is passed in, CXCallingConv_Invalid is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getFunctionTypeCallingConv_AddFunction
    handle.def(
        "clang_getFunctionTypeCallingConv",
        static_cast<pybind11_weaver::FnPtrT<void, CXCallingConv(CXType)>::type>(
            &clang_getFunctionTypeCallingConv),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getFunctionTypeCallingConv(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getFunctionTypeCallingConv(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getFunctionTypeCallingConv"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getFunctionTypeCallingConv

using Entity_clang_getFunctionTypeCallingConv =
    Bind_clang_getFunctionTypeCallingConv<>;

#else

struct Entity_clang_getFunctionTypeCallingConv
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getFunctionTypeCallingConv(EntityScope parent_h) {}
  static const char *Key() { return "clang_getFunctionTypeCallingConv"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getFunctionTypeCallingConv

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getIBOutletCollectionType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * For cursors representing an iboutletcollection attribute,
 *  this function returns the collection element type.
 *
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getIBOutletCollectionType_AddFunction
    handle.def(
        "clang_getIBOutletCollectionType",
        static_cast<pybind11_weaver::FnPtrT<void, CXType(CXCursor)>::type>(
            &clang_getIBOutletCollectionType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getIBOutletCollectionType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getIBOutletCollectionType(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getIBOutletCollectionType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getIBOutletCollectionType

using Entity_clang_getIBOutletCollectionType =
    Bind_clang_getIBOutletCollectionType<>;

#else

struct Entity_clang_getIBOutletCollectionType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getIBOutletCollectionType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getIBOutletCollectionType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getIBOutletCollectionType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getIncludedFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the file that is included by the given inclusion directive
 * cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getIncludedFile_AddFunction
    handle.def(
        "clang_getIncludedFile",
        [](CXCursor cursor) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void *(CXCursor)>::type>(
                  &clang_getIncludedFile),
              cursor);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getIncludedFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getIncludedFile(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getIncludedFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getIncludedFile

using Entity_clang_getIncludedFile = Bind_clang_getIncludedFile<>;

#else

struct Entity_clang_getIncludedFile : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getIncludedFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_getIncludedFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getIncludedFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getInclusions : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Visit the set of preprocessor inclusions in a translation unit.
 *   The visitor function is called with the provided data for every included
 *   file.  This does not include headers included by the PCH file (unless one
 *   is inspecting the inclusions in the PCH file itself).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getInclusions_AddFunction
    handle.def(
        "clang_getInclusions",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           std::function<void(pybind11_weaver::WrappedPtrT<void *>,
                              CXSourceLocation *, unsigned int,
                              pybind11_weaver::WrappedPtrT<void *>)>
               visitor,
           pybind11_weaver::WrappedPtrT<void *> client_data) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXTranslationUnitImpl *,
                             void (*)(void *, CXSourceLocation *, unsigned int,
                                      void *),
                             void *)>::type>(&clang_getInclusions),
              (tu)->Cptr(),
              pybind11_weaver::FnPointerWrapper<
                  void, pybind11_weaver::WrappedPtrT<void *>,
                  CXSourceLocation *, unsigned int,
                  pybind11_weaver::WrappedPtrT<void *>>::
                  GetCptr<void, void *, CXSourceLocation *, unsigned int,
                          void *>::
                      Run((visitor), pybind11_weaver::Guardian(),
                          [](void *arg0_0, CXSourceLocation *arg0_1,
                             unsigned int arg0_2, void *arg0_3) {
                            auto to_call = pybind11_weaver::FnPointerWrapper<
                                void, pybind11_weaver::WrappedPtrT<void *>,
                                CXSourceLocation *, unsigned int,
                                pybind11_weaver::WrappedPtrT<void *>>::
                                GetFnProxy(__DATE__ __TIME__ __FILE__,
                                           __COUNTER__);
                            return to_call(
                                pybind11_weaver::WrapP<void *>(arg0_0), arg0_1,
                                arg0_2, pybind11_weaver::WrapP<void *>(arg0_3));
                          },
                          /* clang-format off */
__DATE__ __TIME__ __FILE__, 
__COUNTER__ - 1
                          /* clang-format on */
                          ),
              (client_data)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getInclusions(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getInclusions(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getInclusions"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getInclusions

using Entity_clang_getInclusions = Bind_clang_getInclusions<>;

#else

struct Entity_clang_getInclusions : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getInclusions(EntityScope parent_h) {}
  static const char *Key() { return "clang_getInclusions"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getInclusions

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getInstantiationLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Legacy API to retrieve the file, line, column, and offset represented
 * by the given source location.
 *
 * This interface has been replaced by the newer interface
 * #clang_getExpansionLocation(). See that interface's documentation for
 * details.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getInstantiationLocation_AddFunction
    handle.def(
        "clang_getInstantiationLocation",
        [](CXSourceLocation location,
           pybind11_weaver::WrappedPtrT<void **> file, unsigned int *line,
           unsigned int *column, unsigned int *offset) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXSourceLocation, void **, unsigned int *,
                             unsigned int *, unsigned int *)>::type>(
                  &clang_getInstantiationLocation),
              location, (file)->Cptr(), line, column, offset);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getInstantiationLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getInstantiationLocation(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getInstantiationLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getInstantiationLocation

using Entity_clang_getInstantiationLocation =
    Bind_clang_getInstantiationLocation<>;

#else

struct Entity_clang_getInstantiationLocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getInstantiationLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getInstantiationLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getInstantiationLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieves the source location associated with a given file/line/column
 * in a particular translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getLocation_AddFunction
    handle.def(
        "clang_getLocation",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           pybind11_weaver::WrappedPtrT<void *> file, unsigned int line,
           unsigned int column) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXSourceLocation(CXTranslationUnitImpl *, void *,
                                         unsigned int, unsigned int)>::type>(
                  &clang_getLocation),
              (tu)->Cptr(), (file)->Cptr(), line, column);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getLocation(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getLocation

using Entity_clang_getLocation = Bind_clang_getLocation<>;

#else

struct Entity_clang_getLocation : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getLocationForOffset : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieves the source location associated with a given character offset
 * in a particular translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getLocationForOffset_AddFunction
    handle.def(
        "clang_getLocationForOffset",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           pybind11_weaver::WrappedPtrT<void *> file, unsigned int offset) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXSourceLocation(CXTranslationUnitImpl *, void *,
                                         unsigned int)>::type>(
                  &clang_getLocationForOffset),
              (tu)->Cptr(), (file)->Cptr(), offset);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getLocationForOffset(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getLocationForOffset(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getLocationForOffset"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getLocationForOffset

using Entity_clang_getLocationForOffset = Bind_clang_getLocationForOffset<>;

#else

struct Entity_clang_getLocationForOffset
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getLocationForOffset(EntityScope parent_h) {}
  static const char *Key() { return "clang_getLocationForOffset"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getLocationForOffset

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getModuleForFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a CXFile header file, return the module that contains it, if one
 * exists.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getModuleForFile_AddFunction
    handle.def(
        "clang_getModuleForFile",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0,
           pybind11_weaver::WrappedPtrT<void *> arg1) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void *(CXTranslationUnitImpl *, void *)>::type>(
                  &clang_getModuleForFile),
              (arg0)->Cptr(), (arg1)->Cptr());
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getModuleForFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getModuleForFile(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getModuleForFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getModuleForFile

using Entity_clang_getModuleForFile = Bind_clang_getModuleForFile<>;

#else

struct Entity_clang_getModuleForFile : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getModuleForFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_getModuleForFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getModuleForFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNonReferenceType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * For reference types (e.g., "const int&"), returns the type that the
 * reference refers to (e.g "const int").
 *
 * Otherwise, returns the type itself.
 *
 * A type that has kind \c CXType_LValueReference or
 * \c CXType_RValueReference is a reference type.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNonReferenceType_AddFunction
    handle.def("clang_getNonReferenceType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_getNonReferenceType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNonReferenceType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNonReferenceType(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNonReferenceType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNonReferenceType

using Entity_clang_getNonReferenceType = Bind_clang_getNonReferenceType<>;

#else

struct Entity_clang_getNonReferenceType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNonReferenceType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNonReferenceType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNonReferenceType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNullCursor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the NULL cursor, which represents no entity.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNullCursor_AddFunction
    handle.def("clang_getNullCursor",
               static_cast<pybind11_weaver::FnPtrT<void, CXCursor()>::type>(
                   &clang_getNullCursor),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNullCursor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNullCursor(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNullCursor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNullCursor

using Entity_clang_getNullCursor = Bind_clang_getNullCursor<>;

#else

struct Entity_clang_getNullCursor : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNullCursor(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNullCursor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNullCursor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNullLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a NULL (invalid) source location.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNullLocation_AddFunction
    handle.def(
        "clang_getNullLocation",
        static_cast<pybind11_weaver::FnPtrT<void, CXSourceLocation()>::type>(
            &clang_getNullLocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNullLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNullLocation(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNullLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNullLocation

using Entity_clang_getNullLocation = Bind_clang_getNullLocation<>;

#else

struct Entity_clang_getNullLocation : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNullLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNullLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNullLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNullRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a NULL (invalid) source range.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNullRange_AddFunction
    handle.def(
        "clang_getNullRange",
        static_cast<pybind11_weaver::FnPtrT<void, CXSourceRange()>::type>(
            &clang_getNullRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNullRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNullRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNullRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNullRange

using Entity_clang_getNullRange = Bind_clang_getNullRange<>;

#else

struct Entity_clang_getNullRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNullRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNullRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNullRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNumArgTypes : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the number of non-variadic parameters associated with a
 * function type.
 *
 * If a non-function type is passed in, -1 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNumArgTypes_AddFunction
    handle.def("clang_getNumArgTypes",
               static_cast<pybind11_weaver::FnPtrT<void, int(CXType)>::type>(
                   &clang_getNumArgTypes),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNumArgTypes(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNumArgTypes(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNumArgTypes"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNumArgTypes

using Entity_clang_getNumArgTypes = Bind_clang_getNumArgTypes<>;

#else

struct Entity_clang_getNumArgTypes : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNumArgTypes(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNumArgTypes"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNumArgTypes

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNumCompletionChunks : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the number of chunks in the given code-completion string.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNumCompletionChunks_AddFunction
    handle.def(
        "clang_getNumCompletionChunks",
        [](pybind11_weaver::WrappedPtrT<void *> completion_string) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_getNumCompletionChunks),
              (completion_string)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNumCompletionChunks(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNumCompletionChunks(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNumCompletionChunks"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNumCompletionChunks

using Entity_clang_getNumCompletionChunks = Bind_clang_getNumCompletionChunks<>;

#else

struct Entity_clang_getNumCompletionChunks
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNumCompletionChunks(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNumCompletionChunks"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNumCompletionChunks

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNumDiagnostics : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the number of diagnostics produced for the given
 * translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNumDiagnostics_AddFunction
    handle.def(
        "clang_getNumDiagnostics",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> Unit) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXTranslationUnitImpl *)>::type>(
                  &clang_getNumDiagnostics),
              (Unit)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNumDiagnostics(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNumDiagnostics(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNumDiagnostics"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNumDiagnostics

using Entity_clang_getNumDiagnostics = Bind_clang_getNumDiagnostics<>;

#else

struct Entity_clang_getNumDiagnostics : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNumDiagnostics(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNumDiagnostics"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNumDiagnostics

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNumDiagnosticsInSet : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the number of diagnostics in a CXDiagnosticSet.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNumDiagnosticsInSet_AddFunction
    handle.def(
        "clang_getNumDiagnosticsInSet",
        [](pybind11_weaver::WrappedPtrT<void *> Diags) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_getNumDiagnosticsInSet),
              (Diags)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNumDiagnosticsInSet(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNumDiagnosticsInSet(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNumDiagnosticsInSet"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNumDiagnosticsInSet

using Entity_clang_getNumDiagnosticsInSet = Bind_clang_getNumDiagnosticsInSet<>;

#else

struct Entity_clang_getNumDiagnosticsInSet
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNumDiagnosticsInSet(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNumDiagnosticsInSet"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNumDiagnosticsInSet

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNumElements : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the number of elements of an array or vector type.
 *
 * If a type is passed in that is not an array or vector type,
 * -1 is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNumElements_AddFunction
    handle.def(
        "clang_getNumElements",
        static_cast<pybind11_weaver::FnPtrT<void, long long(CXType)>::type>(
            &clang_getNumElements),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNumElements(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNumElements(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNumElements"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNumElements

using Entity_clang_getNumElements = Bind_clang_getNumElements<>;

#else

struct Entity_clang_getNumElements : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNumElements(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNumElements"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNumElements

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getNumOverloadedDecls : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the number of overloaded declarations referenced by a
 * \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \returns The number of overloaded declarations referenced by \c cursor. If it
 * is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getNumOverloadedDecls_AddFunction
    handle.def("clang_getNumOverloadedDecls",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_getNumOverloadedDecls),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getNumOverloadedDecls(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getNumOverloadedDecls(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getNumOverloadedDecls"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getNumOverloadedDecls

using Entity_clang_getNumOverloadedDecls = Bind_clang_getNumOverloadedDecls<>;

#else

struct Entity_clang_getNumOverloadedDecls
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getNumOverloadedDecls(EntityScope parent_h) {}
  static const char *Key() { return "clang_getNumOverloadedDecls"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getNumOverloadedDecls

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getOverloadedDecl : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a cursor for one of the overloaded declarations referenced
 * by a \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \param index The zero-based index into the set of overloaded declarations in
 * the cursor.
 *
 * \returns A cursor representing the declaration referenced by the given
 * \c cursor at the specified \c index. If the cursor does not have an
 * associated set of overloaded declarations, or if the index is out of bounds,
 * returns \c clang_getNullCursor();
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getOverloadedDecl_AddFunction
    handle.def("clang_getOverloadedDecl",
               static_cast<pybind11_weaver::FnPtrT<
                   void, CXCursor(CXCursor, unsigned int)>::type>(
                   &clang_getOverloadedDecl),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getOverloadedDecl(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getOverloadedDecl(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getOverloadedDecl"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getOverloadedDecl

using Entity_clang_getOverloadedDecl = Bind_clang_getOverloadedDecl<>;

#else

struct Entity_clang_getOverloadedDecl : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getOverloadedDecl(EntityScope parent_h) {}
  static const char *Key() { return "clang_getOverloadedDecl"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getOverloadedDecl

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getOverriddenCursors : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the set of methods that are overridden by the given
 * method.
 *
 * In both Objective-C and C++, a method (aka virtual member function,
 * in C++) can override a virtual method in a base class. For
 * Objective-C, a method is said to override any method in the class's
 * base class, its protocols, or its categories' protocols, that has the same
 * selector and is of the same kind (class or instance).
 * If no such method exists, the search continues to the class's superclass,
 * its protocols, and its categories, and so on. A method from an Objective-C
 * implementation is considered to override the same methods as its
 * corresponding method in the interface.
 *
 * For C++, a virtual member function overrides any virtual member
 * function with the same signature that occurs in its base
 * classes. With multiple inheritance, a virtual member function can
 * override several virtual member functions coming from different
 * base classes.
 *
 * In all cases, this function determines the immediate overridden
 * method, rather than all of the overridden methods. For example, if
 * a method is originally declared in a class A, then overridden in B
 * (which in inherits from A) and also in C (which inherited from B),
 * then the only overridden method returned from this function when
 * invoked on C's method will be B's method. The client may then
 * invoke this function again, given the previously-found overridden
 * methods, to map out the complete method-override set.
 *
 * \param cursor A cursor representing an Objective-C or C++
 * method. This routine will compute the set of methods that this
 * method overrides.
 *
 * \param overridden A pointer whose pointee will be replaced with a
 * pointer to an array of cursors, representing the set of overridden
 * methods. If there are no overridden methods, the pointee will be
 * set to NULL. The pointee must be freed via a call to
 * \c clang_disposeOverriddenCursors().
 *
 * \param num_overridden A pointer to the number of overridden
 * functions, will be set to the number of overridden functions in the
 * array pointed to by \p overridden.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getOverriddenCursors_AddFunction
    handle.def(
        "clang_getOverriddenCursors",
        [](CXCursor cursor,
           pybind11_weaver::WrappedPtrT<CXCursor **> overridden,
           unsigned int *num_overridden) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXCursor, CXCursor **, unsigned int *)>::type>(
                  &clang_getOverriddenCursors),
              cursor, (overridden)->Cptr(), num_overridden);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getOverriddenCursors(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getOverriddenCursors(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getOverriddenCursors"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getOverriddenCursors

using Entity_clang_getOverriddenCursors = Bind_clang_getOverriddenCursors<>;

#else

struct Entity_clang_getOverriddenCursors
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getOverriddenCursors(EntityScope parent_h) {}
  static const char *Key() { return "clang_getOverriddenCursors"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getOverriddenCursors

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getPointeeType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * For pointer types, returns the type of the pointee.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getPointeeType_AddFunction
    handle.def("clang_getPointeeType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_getPointeeType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getPointeeType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getPointeeType(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getPointeeType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getPointeeType

using Entity_clang_getPointeeType = Bind_clang_getPointeeType<>;

#else

struct Entity_clang_getPointeeType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getPointeeType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getPointeeType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getPointeeType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getPresumedLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the file, line and column represented by the given source
 * location, as specified in a # line directive.
 *
 * Example: given the following source code in a file somefile.c
 *
 * \code
 * #123 "dummy.c" 1
 *
 * static int func(void)
 * {
 *     return 0;
 * }
 * \endcode
 *
 * the location information returned by this function would be
 *
 * File: dummy.c Line: 124 Column: 12
 *
 * whereas clang_getExpansionLocation would have returned
 *
 * File: somefile.c Line: 3 Column: 12
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param filename [out] if non-NULL, will be set to the filename of the
 * source location. Note that filenames returned will be for "virtual" files,
 * which don't necessarily exist on the machine running clang - e.g. when
 * parsing preprocessed output obtained from a different environment. If
 * a non-NULL value is passed in, remember to dispose of the returned value
 * using \c clang_disposeString() once you've finished with it. For an invalid
 * source location, an empty string is returned.
 *
 * \param line [out] if non-NULL, will be set to the line number of the
 * source location. For an invalid source location, zero is returned.
 *
 * \param column [out] if non-NULL, will be set to the column number of the
 * source location. For an invalid source location, zero is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getPresumedLocation_AddFunction
    handle.def(
        "clang_getPresumedLocation",
        static_cast<pybind11_weaver::FnPtrT<
            void, void(CXSourceLocation, CXString *, unsigned int *,
                       unsigned int *)>::type>(&clang_getPresumedLocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getPresumedLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getPresumedLocation(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getPresumedLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getPresumedLocation

using Entity_clang_getPresumedLocation = Bind_clang_getPresumedLocation<>;

#else

struct Entity_clang_getPresumedLocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getPresumedLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getPresumedLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getPresumedLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getRange : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a source range given the beginning and ending source
 * locations.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getRange_AddFunction
    handle.def(
        "clang_getRange",
        static_cast<pybind11_weaver::FnPtrT<
            void, CXSourceRange(CXSourceLocation, CXSourceLocation)>::type>(
            &clang_getRange),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getRange(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getRange(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getRange"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getRange

using Entity_clang_getRange = Bind_clang_getRange<>;

#else

struct Entity_clang_getRange : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getRange(EntityScope parent_h) {}
  static const char *Key() { return "clang_getRange"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getRange

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getRangeEnd : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a source location representing the last character within a
 * source range.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getRangeEnd_AddFunction
    handle.def(
        "clang_getRangeEnd",
        static_cast<pybind11_weaver::FnPtrT<
            void, CXSourceLocation(CXSourceRange)>::type>(&clang_getRangeEnd),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getRangeEnd(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getRangeEnd(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getRangeEnd"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getRangeEnd

using Entity_clang_getRangeEnd = Bind_clang_getRangeEnd<>;

#else

struct Entity_clang_getRangeEnd : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getRangeEnd(EntityScope parent_h) {}
  static const char *Key() { return "clang_getRangeEnd"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getRangeEnd

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getRangeStart : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a source location representing the first character within a
 * source range.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getRangeStart_AddFunction
    handle.def(
        "clang_getRangeStart",
        static_cast<pybind11_weaver::FnPtrT<
            void, CXSourceLocation(CXSourceRange)>::type>(&clang_getRangeStart),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getRangeStart(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getRangeStart(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getRangeStart"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getRangeStart

using Entity_clang_getRangeStart = Bind_clang_getRangeStart<>;

#else

struct Entity_clang_getRangeStart : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getRangeStart(EntityScope parent_h) {}
  static const char *Key() { return "clang_getRangeStart"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getRangeStart

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getRemappings : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a remapping.
 *
 * \param path the path that contains metadata about remappings.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getRemappings_AddFunction
    handle.def(
        "clang_getRemappings",
        [](const char *path) {
          auto &&__ret__ = std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, void *(const char *)>::type>(
                  &clang_getRemappings),
              path);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getRemappings(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getRemappings(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getRemappings"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getRemappings

using Entity_clang_getRemappings = Bind_clang_getRemappings<>;

#else

struct Entity_clang_getRemappings : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getRemappings(EntityScope parent_h) {}
  static const char *Key() { return "clang_getRemappings"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getRemappings

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getRemappingsFromFileList : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a remapping.
 *
 * \param filePaths pointer to an array of file paths containing remapping info.
 *
 * \param numFiles number of file paths.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getRemappingsFromFileList_AddFunction
    handle.def(
        "clang_getRemappingsFromFileList",
        [](pybind11_weaver::WrappedPtrT<const char **> filePaths,
           unsigned int numFiles) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(const char **, unsigned int)>::type>(
                              &clang_getRemappingsFromFileList),
                          (filePaths)->Cptr(), numFiles);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getRemappingsFromFileList(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getRemappingsFromFileList(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getRemappingsFromFileList"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getRemappingsFromFileList

using Entity_clang_getRemappingsFromFileList =
    Bind_clang_getRemappingsFromFileList<>;

#else

struct Entity_clang_getRemappingsFromFileList
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getRemappingsFromFileList(EntityScope parent_h) {}
  static const char *Key() { return "clang_getRemappingsFromFileList"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getRemappingsFromFileList

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getResultType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the return type associated with a function type.
 *
 * If a non-function type is passed in, an invalid type is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getResultType_AddFunction
    handle.def("clang_getResultType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_getResultType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getResultType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getResultType(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getResultType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getResultType

using Entity_clang_getResultType = Bind_clang_getResultType<>;

#else

struct Entity_clang_getResultType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getResultType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getResultType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getResultType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getSkippedRanges : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve all ranges that were skipped by the preprocessor.
 *
 * The preprocessor will skip lines when they are surrounded by an
 * if/ifdef/ifndef directive whose condition does not evaluate to true.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getSkippedRanges_AddFunction
    handle.def(
        "clang_getSkippedRanges",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           pybind11_weaver::WrappedPtrT<void *> file) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  CXSourceRangeList *(CXTranslationUnitImpl *, void *)>::type>(
                  &clang_getSkippedRanges),
              (tu)->Cptr(), (file)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getSkippedRanges(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getSkippedRanges(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getSkippedRanges"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getSkippedRanges

using Entity_clang_getSkippedRanges = Bind_clang_getSkippedRanges<>;

#else

struct Entity_clang_getSkippedRanges : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getSkippedRanges(EntityScope parent_h) {}
  static const char *Key() { return "clang_getSkippedRanges"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getSkippedRanges

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getSpecializedCursorTemplate : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that may represent a specialization or instantiation
 * of a template, retrieve the cursor that represents the template that it
 * specializes or from which it was instantiated.
 *
 * This routine determines the template involved both for explicit
 * specializations of templates and for implicit instantiations of the template,
 * both of which are referred to as "specializations". For a class template
 * specialization (e.g., \c std::vector<bool>), this routine will return
 * either the primary template (\c std::vector) or, if the specialization was
 * instantiated from a class template partial specialization, the class template
 * partial specialization. For a class template partial specialization and a
 * function template specialization (including instantiations), this
 * this routine will return the specialized template.
 *
 * For members of a class template (e.g., member functions, member classes, or
 * static data members), returns the specialized or instantiated member.
 * Although not strictly "templates" in the C++ language, members of class
 * templates have the same notions of specializations and instantiations that
 * templates do, so this routine treats them similarly.
 *
 * \param C A cursor that may be a specialization of a template or a member
 * of a template.
 *
 * \returns If the given cursor is a specialization or instantiation of a
 * template or a member thereof, the template or member that it specializes or
 * from which it was instantiated. Otherwise, returns a NULL cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getSpecializedCursorTemplate_AddFunction
    handle.def(
        "clang_getSpecializedCursorTemplate",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXCursor)>::type>(
            &clang_getSpecializedCursorTemplate),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getSpecializedCursorTemplate(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getSpecializedCursorTemplate(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getSpecializedCursorTemplate"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getSpecializedCursorTemplate

using Entity_clang_getSpecializedCursorTemplate =
    Bind_clang_getSpecializedCursorTemplate<>;

#else

struct Entity_clang_getSpecializedCursorTemplate
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getSpecializedCursorTemplate(EntityScope parent_h) {}
  static const char *Key() { return "clang_getSpecializedCursorTemplate"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getSpecializedCursorTemplate

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getSpellingLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro instantiation, return where the
 * location was originally spelled in the source file.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getSpellingLocation_AddFunction
    handle.def(
        "clang_getSpellingLocation",
        [](CXSourceLocation location,
           pybind11_weaver::WrappedPtrT<void **> file, unsigned int *line,
           unsigned int *column, unsigned int *offset) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXSourceLocation, void **, unsigned int *,
                             unsigned int *, unsigned int *)>::type>(
                  &clang_getSpellingLocation),
              location, (file)->Cptr(), line, column, offset);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getSpellingLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getSpellingLocation(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getSpellingLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getSpellingLocation

using Entity_clang_getSpellingLocation = Bind_clang_getSpellingLocation<>;

#else

struct Entity_clang_getSpellingLocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getSpellingLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getSpellingLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getSpellingLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getSymbolGraphForCursor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Generate a single symbol symbol graph for the declaration at the given
 * cursor. Returns a null string if the AST node for the cursor isn't a
 * declaration.
 *
 * The output contains the symbol graph as well as some additional information
 * about related symbols.
 *
 * \param cursor the declaration for which to generate the single symbol symbol
 * graph.
 *
 * \returns a string containing the serialized symbol graph representation for
 * the symbol being queried or a null string if it can not be found in the
 * APISet.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getSymbolGraphForCursor_AddFunction
    handle.def(
        "clang_getSymbolGraphForCursor",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXCursor)>::type>(
            &clang_getSymbolGraphForCursor),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getSymbolGraphForCursor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getSymbolGraphForCursor(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getSymbolGraphForCursor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getSymbolGraphForCursor

using Entity_clang_getSymbolGraphForCursor =
    Bind_clang_getSymbolGraphForCursor<>;

#else

struct Entity_clang_getSymbolGraphForCursor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getSymbolGraphForCursor(EntityScope parent_h) {}
  static const char *Key() { return "clang_getSymbolGraphForCursor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getSymbolGraphForCursor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getSymbolGraphForUSR : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Generate a single symbol symbol graph for the given USR. Returns a null
 * string if the associated symbol can not be found in the provided \c CXAPISet.
 *
 * The output contains the symbol graph as well as some additional information
 * about related symbols.
 *
 * \param usr is a string containing the USR of the symbol to generate the
 * symbol graph for.
 *
 * \param api the \c CXAPISet to look for the symbol in.
 *
 * \returns a string containing the serialized symbol graph representation for
 * the symbol being queried or a null string if it can not be found in the
 * APISet.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getSymbolGraphForUSR_AddFunction
    handle.def(
        "clang_getSymbolGraphForUSR",
        [](const char *usr, pybind11_weaver::WrappedPtrT<CXAPISetImpl *> api) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXString(const char *, CXAPISetImpl *)>::type>(
                  &clang_getSymbolGraphForUSR),
              usr, (api)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getSymbolGraphForUSR(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getSymbolGraphForUSR(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getSymbolGraphForUSR"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getSymbolGraphForUSR

using Entity_clang_getSymbolGraphForUSR = Bind_clang_getSymbolGraphForUSR<>;

#else

struct Entity_clang_getSymbolGraphForUSR
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getSymbolGraphForUSR(EntityScope parent_h) {}
  static const char *Key() { return "clang_getSymbolGraphForUSR"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getSymbolGraphForUSR

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTUResourceUsageName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the human-readable null-terminated C string that represents
 *  the name of the memory category.  This string should never be freed.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTUResourceUsageName_AddFunction
    handle.def("clang_getTUResourceUsageName",
               static_cast<pybind11_weaver::FnPtrT<
                   void, const char *(CXTUResourceUsageKind)>::type>(
                   &clang_getTUResourceUsageName),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTUResourceUsageName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTUResourceUsageName(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTUResourceUsageName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTUResourceUsageName

using Entity_clang_getTUResourceUsageName = Bind_clang_getTUResourceUsageName<>;

#else

struct Entity_clang_getTUResourceUsageName
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTUResourceUsageName(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTUResourceUsageName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTUResourceUsageName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTemplateCursorKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Given a cursor that represents a template, determine
 * the cursor kind of the specializations would be generated by instantiating
 * the template.
 *
 * This routine can be used to determine what flavor of function template,
 * class template, or class template partial specialization is stored in the
 * cursor. For example, it can describe whether a class template cursor is
 * declared with "struct", "class" or "union".
 *
 * \param C The cursor to query. This cursor should represent a template
 * declaration.
 *
 * \returns The cursor kind of the specializations that would be generated
 * by instantiating the template \p C. If \p C is not a template, returns
 * \c CXCursor_NoDeclFound.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTemplateCursorKind_AddFunction
    handle.def("clang_getTemplateCursorKind",
               static_cast<
                   pybind11_weaver::FnPtrT<void, CXCursorKind(CXCursor)>::type>(
                   &clang_getTemplateCursorKind),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTemplateCursorKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTemplateCursorKind(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTemplateCursorKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTemplateCursorKind

using Entity_clang_getTemplateCursorKind = Bind_clang_getTemplateCursorKind<>;

#else

struct Entity_clang_getTemplateCursorKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTemplateCursorKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTemplateCursorKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTemplateCursorKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getToken : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the raw lexical token starting with the given location.
 *
 * \param TU the translation unit whose text is being tokenized.
 *
 * \param Location the source location with which the token starts.
 *
 * \returns The token starting with the given location or NULL if no such token
 * exist. The returned pointer must be freed with clang_disposeTokens before the
 * translation unit is destroyed.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getToken_AddFunction
    handle.def(
        "clang_getToken",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           CXSourceLocation Location) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXToken *(CXTranslationUnitImpl *,
                                  CXSourceLocation)>::type>(&clang_getToken),
              (TU)->Cptr(), Location);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getToken(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getToken(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getToken"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getToken

using Entity_clang_getToken = Bind_clang_getToken<>;

#else

struct Entity_clang_getToken : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getToken(EntityScope parent_h) {}
  static const char *Key() { return "clang_getToken"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getToken

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTokenExtent : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve a source range that covers the given token.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTokenExtent_AddFunction
    handle.def(
        "clang_getTokenExtent",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0,
           CXToken arg1) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXSourceRange(CXTranslationUnitImpl *, CXToken)>::type>(
                  &clang_getTokenExtent),
              (arg0)->Cptr(), arg1);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTokenExtent(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTokenExtent(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTokenExtent"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTokenExtent

using Entity_clang_getTokenExtent = Bind_clang_getTokenExtent<>;

#else

struct Entity_clang_getTokenExtent : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTokenExtent(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTokenExtent"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTokenExtent

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTokenKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the kind of the given token.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTokenKind_AddFunction
    handle.def(
        "clang_getTokenKind",
        static_cast<pybind11_weaver::FnPtrT<void, CXTokenKind(CXToken)>::type>(
            &clang_getTokenKind),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTokenKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTokenKind(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTokenKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTokenKind

using Entity_clang_getTokenKind = Bind_clang_getTokenKind<>;

#else

struct Entity_clang_getTokenKind : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTokenKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTokenKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTokenKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTokenLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the source location of the given token.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTokenLocation_AddFunction
    handle.def(
        "clang_getTokenLocation",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0,
           CXToken arg1) {
          return std::invoke(static_cast<pybind11_weaver::FnPtrT<
                                 void, CXSourceLocation(CXTranslationUnitImpl *,
                                                        CXToken)>::type>(
                                 &clang_getTokenLocation),
                             (arg0)->Cptr(), arg1);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTokenLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTokenLocation(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTokenLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTokenLocation

using Entity_clang_getTokenLocation = Bind_clang_getTokenLocation<>;

#else

struct Entity_clang_getTokenLocation : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTokenLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTokenLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTokenLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTokenSpelling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the spelling of the given token.
 *
 * The spelling of a token is the textual representation of that token, e.g.,
 * the text of an identifier or keyword.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTokenSpelling_AddFunction
    handle.def(
        "clang_getTokenSpelling",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0,
           CXToken arg1) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXString(CXTranslationUnitImpl *, CXToken)>::type>(
                  &clang_getTokenSpelling),
              (arg0)->Cptr(), arg1);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTokenSpelling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTokenSpelling(EntityScope parent_h,
                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTokenSpelling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTokenSpelling

using Entity_clang_getTokenSpelling = Bind_clang_getTokenSpelling<>;

#else

struct Entity_clang_getTokenSpelling : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTokenSpelling(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTokenSpelling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTokenSpelling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTranslationUnitCursor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the cursor that represents the given translation unit.
 *
 * The translation unit cursor can be used to start traversing the
 * various declarations within the given translation unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTranslationUnitCursor_AddFunction
    handle.def(
        "clang_getTranslationUnitCursor",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXCursor(CXTranslationUnitImpl *)>::type>(
                  &clang_getTranslationUnitCursor),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTranslationUnitCursor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTranslationUnitCursor(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTranslationUnitCursor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTranslationUnitCursor

using Entity_clang_getTranslationUnitCursor =
    Bind_clang_getTranslationUnitCursor<>;

#else

struct Entity_clang_getTranslationUnitCursor
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTranslationUnitCursor(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTranslationUnitCursor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTranslationUnitCursor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTranslationUnitSpelling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the original translation unit source file name.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTranslationUnitSpelling_AddFunction
    handle.def(
        "clang_getTranslationUnitSpelling",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> CTUnit) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXString(CXTranslationUnitImpl *)>::type>(
                  &clang_getTranslationUnitSpelling),
              (CTUnit)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTranslationUnitSpelling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTranslationUnitSpelling(EntityScope parent_h,
                                                 HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTranslationUnitSpelling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTranslationUnitSpelling

using Entity_clang_getTranslationUnitSpelling =
    Bind_clang_getTranslationUnitSpelling<>;

#else

struct Entity_clang_getTranslationUnitSpelling
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTranslationUnitSpelling(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTranslationUnitSpelling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTranslationUnitSpelling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTranslationUnitTargetInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get target information for this translation unit.
 *
 * The CXTargetInfo object cannot outlive the CXTranslationUnit object.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTranslationUnitTargetInfo_AddFunction
    handle.def(
        "clang_getTranslationUnitTargetInfo",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> CTUnit) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXTargetInfoImpl *(CXTranslationUnitImpl *)>::type>(
                  &clang_getTranslationUnitTargetInfo),
              (CTUnit)->Cptr());
          return pybind11_weaver::WrapP<CXTargetInfoImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTranslationUnitTargetInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTranslationUnitTargetInfo(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTranslationUnitTargetInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTranslationUnitTargetInfo

using Entity_clang_getTranslationUnitTargetInfo =
    Bind_clang_getTranslationUnitTargetInfo<>;

#else

struct Entity_clang_getTranslationUnitTargetInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTranslationUnitTargetInfo(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTranslationUnitTargetInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTranslationUnitTargetInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTypeDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return the cursor for the declaration of the given type.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTypeDeclaration_AddFunction
    handle.def(
        "clang_getTypeDeclaration",
        static_cast<pybind11_weaver::FnPtrT<void, CXCursor(CXType)>::type>(
            &clang_getTypeDeclaration),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTypeDeclaration(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTypeDeclaration(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTypeDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTypeDeclaration

using Entity_clang_getTypeDeclaration = Bind_clang_getTypeDeclaration<>;

#else

struct Entity_clang_getTypeDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTypeDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTypeDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTypeDeclaration

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTypeKindSpelling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the spelling of a given CXTypeKind.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTypeKindSpelling_AddFunction
    handle.def(
        "clang_getTypeKindSpelling",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXTypeKind)>::type>(
            &clang_getTypeKindSpelling),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTypeKindSpelling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTypeKindSpelling(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTypeKindSpelling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTypeKindSpelling

using Entity_clang_getTypeKindSpelling = Bind_clang_getTypeKindSpelling<>;

#else

struct Entity_clang_getTypeKindSpelling
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTypeKindSpelling(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTypeKindSpelling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTypeKindSpelling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTypeSpelling : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Pretty-print the underlying type using the rules of the
 * language of the translation unit from which it came.
 *
 * If the type is invalid, an empty string is returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTypeSpelling_AddFunction
    handle.def(
        "clang_getTypeSpelling",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXType)>::type>(
            &clang_getTypeSpelling),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTypeSpelling(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTypeSpelling(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTypeSpelling"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTypeSpelling

using Entity_clang_getTypeSpelling = Bind_clang_getTypeSpelling<>;

#else

struct Entity_clang_getTypeSpelling : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTypeSpelling(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTypeSpelling"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTypeSpelling

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTypedefDeclUnderlyingType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the underlying type of a typedef declaration.
 *
 * If the cursor does not reference a typedef declaration, an invalid type is
 * returned.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTypedefDeclUnderlyingType_AddFunction
    handle.def(
        "clang_getTypedefDeclUnderlyingType",
        static_cast<pybind11_weaver::FnPtrT<void, CXType(CXCursor)>::type>(
            &clang_getTypedefDeclUnderlyingType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTypedefDeclUnderlyingType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTypedefDeclUnderlyingType(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTypedefDeclUnderlyingType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTypedefDeclUnderlyingType

using Entity_clang_getTypedefDeclUnderlyingType =
    Bind_clang_getTypedefDeclUnderlyingType<>;

#else

struct Entity_clang_getTypedefDeclUnderlyingType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTypedefDeclUnderlyingType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTypedefDeclUnderlyingType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTypedefDeclUnderlyingType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getTypedefName : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns the typedef name of the given type.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getTypedefName_AddFunction
    handle.def(
        "clang_getTypedefName",
        static_cast<pybind11_weaver::FnPtrT<void, CXString(CXType)>::type>(
            &clang_getTypedefName),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getTypedefName(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getTypedefName(EntityScope parent_h,
                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getTypedefName"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getTypedefName

using Entity_clang_getTypedefName = Bind_clang_getTypedefName<>;

#else

struct Entity_clang_getTypedefName : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getTypedefName(EntityScope parent_h) {}
  static const char *Key() { return "clang_getTypedefName"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getTypedefName

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_getUnqualifiedType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the unqualified variant of the given type, removing as
 * little sugar as possible.
 *
 * For example, given the following series of typedefs:
 *
 * \code
 * typedef int Integer;
 * typedef const Integer CInteger;
 * typedef CInteger DifferenceType;
 * \endcode
 *
 * Executing \c clang_getUnqualifiedType() on a \c CXType that
 * represents \c DifferenceType, will desugar to a type representing
 * \c Integer, that has no qualifiers.
 *
 * And, executing \c clang_getUnqualifiedType() on the type of the
 * first argument of the following function declaration:
 *
 * \code
 * void foo(const int);
 * \endcode
 *
 * Will return a type representing \c int, removing the \c const
 * qualifier.
 *
 * Sugar over array types is not desugared.
 *
 * A type can be checked for qualifiers with \c
 * clang_isConstQualifiedType(), \c clang_isVolatileQualifiedType()
 * and \c clang_isRestrictQualifiedType().
 *
 * A type that resulted from a call to \c clang_getUnqualifiedType
 * will return \c false for all of the above calls.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_getUnqualifiedType_AddFunction
    handle.def("clang_getUnqualifiedType",
               static_cast<pybind11_weaver::FnPtrT<void, CXType(CXType)>::type>(
                   &clang_getUnqualifiedType),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_getUnqualifiedType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_getUnqualifiedType(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_getUnqualifiedType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_getUnqualifiedType

using Entity_clang_getUnqualifiedType = Bind_clang_getUnqualifiedType<>;

#else

struct Entity_clang_getUnqualifiedType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_getUnqualifiedType(EntityScope parent_h) {}
  static const char *Key() { return "clang_getUnqualifiedType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_getUnqualifiedType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_hashCursor : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Compute a hash value for the given cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_hashCursor_AddFunction
    handle.def("clang_hashCursor",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_hashCursor),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_hashCursor(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_hashCursor(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_hashCursor"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_hashCursor

using Entity_clang_hashCursor = Bind_clang_hashCursor<>;

#else

struct Entity_clang_hashCursor : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_hashCursor(EntityScope parent_h) {}
  static const char *Key() { return "clang_hashCursor"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_hashCursor

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_indexLoc_getCXSourceLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the CXSourceLocation represented by the given CXIdxLoc.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_indexLoc_getCXSourceLocation_AddFunction
    handle.def(
        "clang_indexLoc_getCXSourceLocation",
        static_cast<
            pybind11_weaver::FnPtrT<void, CXSourceLocation(CXIdxLoc)>::type>(
            &clang_indexLoc_getCXSourceLocation),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_indexLoc_getCXSourceLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_indexLoc_getCXSourceLocation(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_indexLoc_getCXSourceLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_indexLoc_getCXSourceLocation

using Entity_clang_indexLoc_getCXSourceLocation =
    Bind_clang_indexLoc_getCXSourceLocation<>;

#else

struct Entity_clang_indexLoc_getCXSourceLocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_indexLoc_getCXSourceLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_indexLoc_getCXSourceLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_indexLoc_getCXSourceLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_indexLoc_getFileLocation : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Retrieve the CXIdxFile, file, line, column, and offset represented by
 * the given CXIdxLoc.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion and if it refers into a macro argument
 * retrieves the location of the argument.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_indexLoc_getFileLocation_AddFunction
    handle.def(
        "clang_indexLoc_getFileLocation",
        [](CXIdxLoc loc, pybind11_weaver::WrappedPtrT<void **> indexFile,
           pybind11_weaver::WrappedPtrT<void **> file, unsigned int *line,
           unsigned int *column, unsigned int *offset) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXIdxLoc, void **, void **, unsigned int *,
                             unsigned int *, unsigned int *)>::type>(
                  &clang_indexLoc_getFileLocation),
              loc, (indexFile)->Cptr(), (file)->Cptr(), line, column, offset);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_indexLoc_getFileLocation(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_indexLoc_getFileLocation(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_indexLoc_getFileLocation"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_indexLoc_getFileLocation

using Entity_clang_indexLoc_getFileLocation =
    Bind_clang_indexLoc_getFileLocation<>;

#else

struct Entity_clang_indexLoc_getFileLocation
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_indexLoc_getFileLocation(EntityScope parent_h) {}
  static const char *Key() { return "clang_indexLoc_getFileLocation"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_indexLoc_getFileLocation

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_indexSourceFile : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Index the given source file and the translation unit corresponding
 * to that file via callbacks implemented through #IndexerCallbacks.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the invoked callbacks.
 *
 * \param index_callbacks Pointer to indexing callbacks that the client
 * implements.
 *
 * \param index_callbacks_size Size of #IndexerCallbacks structure that gets
 * passed in index_callbacks.
 *
 * \param index_options A bitmask of options that affects how indexing is
 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.
 *
 * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be
 * reused after indexing is finished. Set to \c NULL if you do not require it.
 *
 * \returns 0 on success or if there were errors from which the compiler could
 * recover.  If there is a failure from which there is no recovery, returns
 * a non-zero \c CXErrorCode.
 *
 * The rest of the parameters are the same as #clang_parseTranslationUnit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_indexSourceFile_AddFunction
    handle.def(
        "clang_indexSourceFile",
        [](pybind11_weaver::WrappedPtrT<void *> arg0,
           pybind11_weaver::WrappedPtrT<void *> client_data,
           IndexerCallbacks *index_callbacks, unsigned int index_callbacks_size,
           unsigned int index_options, const char *source_filename,
           pybind11_weaver::WrappedPtrT<const char *const *> command_line_args,
           int num_command_line_args, CXUnsavedFile *unsaved_files,
           unsigned int num_unsaved_files,
           pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl **> out_TU,
           unsigned int TU_options) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, int(void *, void *, IndexerCallbacks *, unsigned int,
                            unsigned int, const char *, const char *const *,
                            int, CXUnsavedFile *, unsigned int,
                            CXTranslationUnitImpl **, unsigned int)>::type>(
                  &clang_indexSourceFile),
              (arg0)->Cptr(), (client_data)->Cptr(), index_callbacks,
              index_callbacks_size, index_options, source_filename,
              (command_line_args)->Cptr(), num_command_line_args, unsaved_files,
              num_unsaved_files, (out_TU)->Cptr(), TU_options);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_indexSourceFile(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_indexSourceFile(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_indexSourceFile"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_indexSourceFile

using Entity_clang_indexSourceFile = Bind_clang_indexSourceFile<>;

#else

struct Entity_clang_indexSourceFile : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_indexSourceFile(EntityScope parent_h) {}
  static const char *Key() { return "clang_indexSourceFile"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_indexSourceFile

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_indexSourceFileFullArgv : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Same as clang_indexSourceFile but requires a full command line
 * for \c command_line_args including argv[0]. This is useful if the standard
 * library paths are relative to the binary.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_indexSourceFileFullArgv_AddFunction
    handle.def(
        "clang_indexSourceFileFullArgv",
        [](pybind11_weaver::WrappedPtrT<void *> arg0,
           pybind11_weaver::WrappedPtrT<void *> client_data,
           IndexerCallbacks *index_callbacks, unsigned int index_callbacks_size,
           unsigned int index_options, const char *source_filename,
           pybind11_weaver::WrappedPtrT<const char *const *> command_line_args,
           int num_command_line_args, CXUnsavedFile *unsaved_files,
           unsigned int num_unsaved_files,
           pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl **> out_TU,
           unsigned int TU_options) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, int(void *, void *, IndexerCallbacks *, unsigned int,
                            unsigned int, const char *, const char *const *,
                            int, CXUnsavedFile *, unsigned int,
                            CXTranslationUnitImpl **, unsigned int)>::type>(
                  &clang_indexSourceFileFullArgv),
              (arg0)->Cptr(), (client_data)->Cptr(), index_callbacks,
              index_callbacks_size, index_options, source_filename,
              (command_line_args)->Cptr(), num_command_line_args, unsaved_files,
              num_unsaved_files, (out_TU)->Cptr(), TU_options);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_indexSourceFileFullArgv(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_indexSourceFileFullArgv(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_indexSourceFileFullArgv"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_indexSourceFileFullArgv

using Entity_clang_indexSourceFileFullArgv =
    Bind_clang_indexSourceFileFullArgv<>;

#else

struct Entity_clang_indexSourceFileFullArgv
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_indexSourceFileFullArgv(EntityScope parent_h) {}
  static const char *Key() { return "clang_indexSourceFileFullArgv"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_indexSourceFileFullArgv

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_indexTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Index the given translation unit via callbacks implemented through
 * #IndexerCallbacks.
 *
 * The order of callback invocations is not guaranteed to be the same as
 * when indexing a source file. The high level order will be:
 *
 *   -Preprocessor callbacks invocations
 *   -Declaration/reference callbacks invocations
 *   -Diagnostic callback invocations
 *
 * The parameters are the same as #clang_indexSourceFile.
 *
 * \returns If there is a failure from which there is no recovery, returns
 * non-zero, otherwise returns 0.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_indexTranslationUnit_AddFunction
    handle.def(
        "clang_indexTranslationUnit",
        [](pybind11_weaver::WrappedPtrT<void *> arg0,
           pybind11_weaver::WrappedPtrT<void *> client_data,
           IndexerCallbacks *index_callbacks, unsigned int index_callbacks_size,
           unsigned int index_options,
           pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg5) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, int(void *, void *, IndexerCallbacks *, unsigned int,
                            unsigned int, CXTranslationUnitImpl *)>::type>(
                  &clang_indexTranslationUnit),
              (arg0)->Cptr(), (client_data)->Cptr(), index_callbacks,
              index_callbacks_size, index_options, (arg5)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_indexTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_indexTranslationUnit(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_indexTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_indexTranslationUnit

using Entity_clang_indexTranslationUnit = Bind_clang_indexTranslationUnit<>;

#else

struct Entity_clang_indexTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_indexTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_indexTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_indexTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getCXXClassDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_getCXXClassDeclInfo_AddFunction
    handle.def(
        "clang_index_getCXXClassDeclInfo",
        static_cast<pybind11_weaver::FnPtrT<
            void, const CXIdxCXXClassDeclInfo *(const CXIdxDeclInfo *)>::type>(
            &clang_index_getCXXClassDeclInfo));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getCXXClassDeclInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getCXXClassDeclInfo(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getCXXClassDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getCXXClassDeclInfo

using Entity_clang_index_getCXXClassDeclInfo =
    Bind_clang_index_getCXXClassDeclInfo<>;

#else

struct Entity_clang_index_getCXXClassDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getCXXClassDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_getCXXClassDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getCXXClassDeclInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getClientContainer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * For retrieving a custom CXIdxClientContainer attached to a
 * container.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_index_getClientContainer_AddFunction
    handle.def(
        "clang_index_getClientContainer",
        [](const CXIdxContainerInfo *arg0) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(const CXIdxContainerInfo *)>::type>(
                              &clang_index_getClientContainer),
                          arg0);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getClientContainer(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getClientContainer(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getClientContainer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getClientContainer

using Entity_clang_index_getClientContainer =
    Bind_clang_index_getClientContainer<>;

#else

struct Entity_clang_index_getClientContainer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getClientContainer(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_getClientContainer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getClientContainer

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getClientEntity : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * For retrieving a custom CXIdxClientEntity attached to an entity.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_index_getClientEntity_AddFunction
    handle.def(
        "clang_index_getClientEntity",
        [](const CXIdxEntityInfo *arg0) {
          auto &&__ret__ =
              std::invoke(static_cast<pybind11_weaver::FnPtrT<
                              void, void *(const CXIdxEntityInfo *)>::type>(
                              &clang_index_getClientEntity),
                          arg0);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getClientEntity(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getClientEntity(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getClientEntity"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getClientEntity

using Entity_clang_index_getClientEntity = Bind_clang_index_getClientEntity<>;

#else

struct Entity_clang_index_getClientEntity
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getClientEntity(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_getClientEntity"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getClientEntity

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getIBOutletCollectionAttrInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_getIBOutletCollectionAttrInfo_AddFunction
    handle.def(
        "clang_index_getIBOutletCollectionAttrInfo",
        static_cast<
            pybind11_weaver::FnPtrT<void, const CXIdxIBOutletCollectionAttrInfo
                                              *(const CXIdxAttrInfo *)>::type>(
            &clang_index_getIBOutletCollectionAttrInfo));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getIBOutletCollectionAttrInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getIBOutletCollectionAttrInfo(EntityScope parent_h,
                                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_index_getIBOutletCollectionAttrInfo";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getIBOutletCollectionAttrInfo

using Entity_clang_index_getIBOutletCollectionAttrInfo =
    Bind_clang_index_getIBOutletCollectionAttrInfo<>;

#else

struct Entity_clang_index_getIBOutletCollectionAttrInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getIBOutletCollectionAttrInfo(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_index_getIBOutletCollectionAttrInfo";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getIBOutletCollectionAttrInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getObjCCategoryDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_getObjCCategoryDeclInfo_AddFunction
    handle.def(
        "clang_index_getObjCCategoryDeclInfo",
        static_cast<
            pybind11_weaver::FnPtrT<void, const CXIdxObjCCategoryDeclInfo *(
                                              const CXIdxDeclInfo *)>::type>(
            &clang_index_getObjCCategoryDeclInfo));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getObjCCategoryDeclInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getObjCCategoryDeclInfo(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getObjCCategoryDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getObjCCategoryDeclInfo

using Entity_clang_index_getObjCCategoryDeclInfo =
    Bind_clang_index_getObjCCategoryDeclInfo<>;

#else

struct Entity_clang_index_getObjCCategoryDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getObjCCategoryDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_getObjCCategoryDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getObjCCategoryDeclInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getObjCContainerDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_getObjCContainerDeclInfo_AddFunction
    handle.def(
        "clang_index_getObjCContainerDeclInfo",
        static_cast<
            pybind11_weaver::FnPtrT<void, const CXIdxObjCContainerDeclInfo *(
                                              const CXIdxDeclInfo *)>::type>(
            &clang_index_getObjCContainerDeclInfo));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getObjCContainerDeclInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getObjCContainerDeclInfo(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getObjCContainerDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getObjCContainerDeclInfo

using Entity_clang_index_getObjCContainerDeclInfo =
    Bind_clang_index_getObjCContainerDeclInfo<>;

#else

struct Entity_clang_index_getObjCContainerDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getObjCContainerDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_getObjCContainerDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getObjCContainerDeclInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getObjCInterfaceDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_getObjCInterfaceDeclInfo_AddFunction
    handle.def(
        "clang_index_getObjCInterfaceDeclInfo",
        static_cast<
            pybind11_weaver::FnPtrT<void, const CXIdxObjCInterfaceDeclInfo *(
                                              const CXIdxDeclInfo *)>::type>(
            &clang_index_getObjCInterfaceDeclInfo));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getObjCInterfaceDeclInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getObjCInterfaceDeclInfo(EntityScope parent_h,
                                                     HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getObjCInterfaceDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getObjCInterfaceDeclInfo

using Entity_clang_index_getObjCInterfaceDeclInfo =
    Bind_clang_index_getObjCInterfaceDeclInfo<>;

#else

struct Entity_clang_index_getObjCInterfaceDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getObjCInterfaceDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_getObjCInterfaceDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getObjCInterfaceDeclInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getObjCPropertyDeclInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_getObjCPropertyDeclInfo_AddFunction
    handle.def(
        "clang_index_getObjCPropertyDeclInfo",
        static_cast<
            pybind11_weaver::FnPtrT<void, const CXIdxObjCPropertyDeclInfo *(
                                              const CXIdxDeclInfo *)>::type>(
            &clang_index_getObjCPropertyDeclInfo));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getObjCPropertyDeclInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getObjCPropertyDeclInfo(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getObjCPropertyDeclInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getObjCPropertyDeclInfo

using Entity_clang_index_getObjCPropertyDeclInfo =
    Bind_clang_index_getObjCPropertyDeclInfo<>;

#else

struct Entity_clang_index_getObjCPropertyDeclInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getObjCPropertyDeclInfo(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_getObjCPropertyDeclInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getObjCPropertyDeclInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_getObjCProtocolRefListInfo : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_getObjCProtocolRefListInfo_AddFunction
    handle.def(
        "clang_index_getObjCProtocolRefListInfo",
        static_cast<
            pybind11_weaver::FnPtrT<void, const CXIdxObjCProtocolRefListInfo *(
                                              const CXIdxDeclInfo *)>::type>(
            &clang_index_getObjCProtocolRefListInfo));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_getObjCProtocolRefListInfo(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_getObjCProtocolRefListInfo(EntityScope parent_h,
                                                       HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_getObjCProtocolRefListInfo"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_getObjCProtocolRefListInfo

using Entity_clang_index_getObjCProtocolRefListInfo =
    Bind_clang_index_getObjCProtocolRefListInfo<>;

#else

struct Entity_clang_index_getObjCProtocolRefListInfo
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_getObjCProtocolRefListInfo(EntityScope parent_h) {
  }
  static const char *Key() { return "clang_index_getObjCProtocolRefListInfo"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_getObjCProtocolRefListInfo

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_isEntityObjCContainerKind : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = nullptr;

#ifndef PB11_WEAVER_DISABLE_clang_index_isEntityObjCContainerKind_AddFunction
    handle.def(
        "clang_index_isEntityObjCContainerKind",
        static_cast<pybind11_weaver::FnPtrT<void, int(CXIdxEntityKind)>::type>(
            &clang_index_isEntityObjCContainerKind));
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_isEntityObjCContainerKind(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_isEntityObjCContainerKind(EntityScope parent_h,
                                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_isEntityObjCContainerKind"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_isEntityObjCContainerKind

using Entity_clang_index_isEntityObjCContainerKind =
    Bind_clang_index_isEntityObjCContainerKind<>;

#else

struct Entity_clang_index_isEntityObjCContainerKind
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_isEntityObjCContainerKind(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_isEntityObjCContainerKind"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_isEntityObjCContainerKind

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_setClientContainer : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * For setting a custom CXIdxClientContainer attached to a
 * container.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_index_setClientContainer_AddFunction
    handle.def(
        "clang_index_setClientContainer",
        [](const CXIdxContainerInfo *arg0,
           pybind11_weaver::WrappedPtrT<void *> arg1) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(const CXIdxContainerInfo *, void *)>::type>(
                  &clang_index_setClientContainer),
              arg0, (arg1)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_setClientContainer(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_setClientContainer(EntityScope parent_h,
                                               HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_setClientContainer"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_setClientContainer

using Entity_clang_index_setClientContainer =
    Bind_clang_index_setClientContainer<>;

#else

struct Entity_clang_index_setClientContainer
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_setClientContainer(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_setClientContainer"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_setClientContainer

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_index_setClientEntity : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * For setting a custom CXIdxClientEntity attached to an entity.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_index_setClientEntity_AddFunction
    handle.def(
        "clang_index_setClientEntity",
        [](const CXIdxEntityInfo *arg0,
           pybind11_weaver::WrappedPtrT<void *> arg1) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(const CXIdxEntityInfo *, void *)>::type>(
                  &clang_index_setClientEntity),
              arg0, (arg1)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_index_setClientEntity(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_index_setClientEntity(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_index_setClientEntity"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_index_setClientEntity

using Entity_clang_index_setClientEntity = Bind_clang_index_setClientEntity<>;

#else

struct Entity_clang_index_setClientEntity
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_index_setClientEntity(EntityScope parent_h) {}
  static const char *Key() { return "clang_index_setClientEntity"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_index_setClientEntity

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_install_aborting_llvm_fatal_error_handler
    : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Installs error handler that prints error message to stderr and calls abort().
 * Replaces currently installed error handler (if any).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_install_aborting_llvm_fatal_error_handler_AddFunction
    handle.def("clang_install_aborting_llvm_fatal_error_handler",
               static_cast<pybind11_weaver::FnPtrT<void, void()>::type>(
                   &clang_install_aborting_llvm_fatal_error_handler),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_install_aborting_llvm_fatal_error_handler(
      EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_install_aborting_llvm_fatal_error_handler(
      EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_install_aborting_llvm_fatal_error_handler";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_install_aborting_llvm_fatal_error_handler

using Entity_clang_install_aborting_llvm_fatal_error_handler =
    Bind_clang_install_aborting_llvm_fatal_error_handler<>;

#else

struct Entity_clang_install_aborting_llvm_fatal_error_handler
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_install_aborting_llvm_fatal_error_handler(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_install_aborting_llvm_fatal_error_handler";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_install_aborting_llvm_fatal_error_handler

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isAttribute : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor kind represents an attribute.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isAttribute_AddFunction
    handle.def(
        "clang_isAttribute",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isAttribute),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isAttribute(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isAttribute(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isAttribute"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isAttribute

using Entity_clang_isAttribute = Bind_clang_isAttribute<>;

#else

struct Entity_clang_isAttribute : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isAttribute(EntityScope parent_h) {}
  static const char *Key() { return "clang_isAttribute"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isAttribute

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isConstQualifiedType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether a CXType has the "const" qualifier set,
 * without looking through typedefs that may have added "const" at a
 * different level.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isConstQualifiedType_AddFunction
    handle.def(
        "clang_isConstQualifiedType",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_isConstQualifiedType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isConstQualifiedType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isConstQualifiedType(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isConstQualifiedType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isConstQualifiedType

using Entity_clang_isConstQualifiedType = Bind_clang_isConstQualifiedType<>;

#else

struct Entity_clang_isConstQualifiedType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isConstQualifiedType(EntityScope parent_h) {}
  static const char *Key() { return "clang_isConstQualifiedType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isConstQualifiedType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isCursorDefinition : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the declaration pointed to by this cursor
 * is also a definition of that entity.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isCursorDefinition_AddFunction
    handle.def("clang_isCursorDefinition",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_isCursorDefinition),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isCursorDefinition(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isCursorDefinition(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isCursorDefinition"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isCursorDefinition

using Entity_clang_isCursorDefinition = Bind_clang_isCursorDefinition<>;

#else

struct Entity_clang_isCursorDefinition
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isCursorDefinition(EntityScope parent_h) {}
  static const char *Key() { return "clang_isCursorDefinition"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isCursorDefinition

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor kind represents a declaration.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isDeclaration_AddFunction
    handle.def(
        "clang_isDeclaration",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isDeclaration),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isDeclaration(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isDeclaration(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isDeclaration

using Entity_clang_isDeclaration = Bind_clang_isDeclaration<>;

#else

struct Entity_clang_isDeclaration : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_isDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isDeclaration

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isExpression : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor kind represents an expression.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isExpression_AddFunction
    handle.def(
        "clang_isExpression",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isExpression),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isExpression(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isExpression(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isExpression"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isExpression

using Entity_clang_isExpression = Bind_clang_isExpression<>;

#else

struct Entity_clang_isExpression : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isExpression(EntityScope parent_h) {}
  static const char *Key() { return "clang_isExpression"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isExpression

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isFileMultipleIncludeGuarded : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given header is guarded against
 * multiple inclusions, either with the conventional
 * \#ifndef/\#define/\#endif macro guards or with \#pragma once.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isFileMultipleIncludeGuarded_AddFunction
    handle.def(
        "clang_isFileMultipleIncludeGuarded",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> tu,
           pybind11_weaver::WrappedPtrT<void *> file) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXTranslationUnitImpl *, void *)>::type>(
                  &clang_isFileMultipleIncludeGuarded),
              (tu)->Cptr(), (file)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isFileMultipleIncludeGuarded(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isFileMultipleIncludeGuarded(EntityScope parent_h,
                                                   HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isFileMultipleIncludeGuarded"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isFileMultipleIncludeGuarded

using Entity_clang_isFileMultipleIncludeGuarded =
    Bind_clang_isFileMultipleIncludeGuarded<>;

#else

struct Entity_clang_isFileMultipleIncludeGuarded
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isFileMultipleIncludeGuarded(EntityScope parent_h) {}
  static const char *Key() { return "clang_isFileMultipleIncludeGuarded"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isFileMultipleIncludeGuarded

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isFunctionTypeVariadic : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return 1 if the CXType is a variadic function type, and 0 otherwise.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isFunctionTypeVariadic_AddFunction
    handle.def(
        "clang_isFunctionTypeVariadic",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_isFunctionTypeVariadic),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isFunctionTypeVariadic(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isFunctionTypeVariadic(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isFunctionTypeVariadic"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isFunctionTypeVariadic

using Entity_clang_isFunctionTypeVariadic = Bind_clang_isFunctionTypeVariadic<>;

#else

struct Entity_clang_isFunctionTypeVariadic
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isFunctionTypeVariadic(EntityScope parent_h) {}
  static const char *Key() { return "clang_isFunctionTypeVariadic"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isFunctionTypeVariadic

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isInvalid : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor kind represents an invalid
 * cursor.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isInvalid_AddFunction
    handle.def(
        "clang_isInvalid",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isInvalid),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isInvalid(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isInvalid(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isInvalid"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isInvalid

using Entity_clang_isInvalid = Bind_clang_isInvalid<>;

#else

struct Entity_clang_isInvalid : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isInvalid(EntityScope parent_h) {}
  static const char *Key() { return "clang_isInvalid"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isInvalid

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isInvalidDeclaration : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given declaration is invalid.
 *
 * A declaration is invalid if it could not be parsed successfully.
 *
 * \returns non-zero if the cursor represents a declaration and it is
 * invalid, otherwise NULL.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isInvalidDeclaration_AddFunction
    handle.def("clang_isInvalidDeclaration",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_isInvalidDeclaration),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isInvalidDeclaration(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isInvalidDeclaration(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isInvalidDeclaration"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isInvalidDeclaration

using Entity_clang_isInvalidDeclaration = Bind_clang_isInvalidDeclaration<>;

#else

struct Entity_clang_isInvalidDeclaration
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isInvalidDeclaration(EntityScope parent_h) {}
  static const char *Key() { return "clang_isInvalidDeclaration"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isInvalidDeclaration

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isPODType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Return 1 if the CXType is a POD (plain old data) type, and 0
 *  otherwise.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isPODType_AddFunction
    handle.def(
        "clang_isPODType",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_isPODType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isPODType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isPODType(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isPODType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isPODType

using Entity_clang_isPODType = Bind_clang_isPODType<>;

#else

struct Entity_clang_isPODType : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isPODType(EntityScope parent_h) {}
  static const char *Key() { return "clang_isPODType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isPODType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isPreprocessing : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/***
 * Determine whether the given cursor represents a preprocessing
 * element, such as a preprocessor directive or macro instantiation.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isPreprocessing_AddFunction
    handle.def(
        "clang_isPreprocessing",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isPreprocessing),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isPreprocessing(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isPreprocessing(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isPreprocessing"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isPreprocessing

using Entity_clang_isPreprocessing = Bind_clang_isPreprocessing<>;

#else

struct Entity_clang_isPreprocessing : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isPreprocessing(EntityScope parent_h) {}
  static const char *Key() { return "clang_isPreprocessing"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isPreprocessing

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isReference : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor kind represents a simple
 * reference.
 *
 * Note that other kinds of cursors (such as expressions) can also refer to
 * other cursors. Use clang_getCursorReferenced() to determine whether a
 * particular cursor refers to another entity.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isReference_AddFunction
    handle.def(
        "clang_isReference",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isReference),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isReference(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isReference(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isReference"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isReference

using Entity_clang_isReference = Bind_clang_isReference<>;

#else

struct Entity_clang_isReference : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isReference(EntityScope parent_h) {}
  static const char *Key() { return "clang_isReference"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isReference

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isRestrictQualifiedType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether a CXType has the "restrict" qualifier set,
 * without looking through typedefs that may have added "restrict" at a
 * different level.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isRestrictQualifiedType_AddFunction
    handle.def(
        "clang_isRestrictQualifiedType",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_isRestrictQualifiedType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isRestrictQualifiedType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isRestrictQualifiedType(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isRestrictQualifiedType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isRestrictQualifiedType

using Entity_clang_isRestrictQualifiedType =
    Bind_clang_isRestrictQualifiedType<>;

#else

struct Entity_clang_isRestrictQualifiedType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isRestrictQualifiedType(EntityScope parent_h) {}
  static const char *Key() { return "clang_isRestrictQualifiedType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isRestrictQualifiedType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isStatement : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor kind represents a statement.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isStatement_AddFunction
    handle.def(
        "clang_isStatement",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isStatement),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isStatement(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isStatement(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isStatement"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isStatement

using Entity_clang_isStatement = Bind_clang_isStatement<>;

#else

struct Entity_clang_isStatement : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isStatement(EntityScope parent_h) {}
  static const char *Key() { return "clang_isStatement"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isStatement

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether the given cursor kind represents a translation
 * unit.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isTranslationUnit_AddFunction
    handle.def(
        "clang_isTranslationUnit",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isTranslationUnit),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isTranslationUnit(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isTranslationUnit

using Entity_clang_isTranslationUnit = Bind_clang_isTranslationUnit<>;

#else

struct Entity_clang_isTranslationUnit : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_isTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isUnexposed : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/***
 * Determine whether the given cursor represents a currently
 *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isUnexposed_AddFunction
    handle.def(
        "clang_isUnexposed",
        static_cast<
            pybind11_weaver::FnPtrT<void, unsigned int(CXCursorKind)>::type>(
            &clang_isUnexposed),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isUnexposed(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isUnexposed(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isUnexposed"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isUnexposed

using Entity_clang_isUnexposed = Bind_clang_isUnexposed<>;

#else

struct Entity_clang_isUnexposed : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isUnexposed(EntityScope parent_h) {}
  static const char *Key() { return "clang_isUnexposed"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isUnexposed

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isVirtualBase : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Returns 1 if the base class specified by the cursor with kind
 *   CX_CXXBaseSpecifier is virtual.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isVirtualBase_AddFunction
    handle.def("clang_isVirtualBase",
               static_cast<
                   pybind11_weaver::FnPtrT<void, unsigned int(CXCursor)>::type>(
                   &clang_isVirtualBase),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isVirtualBase(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isVirtualBase(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isVirtualBase"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isVirtualBase

using Entity_clang_isVirtualBase = Bind_clang_isVirtualBase<>;

#else

struct Entity_clang_isVirtualBase : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isVirtualBase(EntityScope parent_h) {}
  static const char *Key() { return "clang_isVirtualBase"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isVirtualBase

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_isVolatileQualifiedType : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine whether a CXType has the "volatile" qualifier set,
 * without looking through typedefs that may have added "volatile" at
 * a different level.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_isVolatileQualifiedType_AddFunction
    handle.def(
        "clang_isVolatileQualifiedType",
        static_cast<pybind11_weaver::FnPtrT<void, unsigned int(CXType)>::type>(
            &clang_isVolatileQualifiedType),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_isVolatileQualifiedType(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_isVolatileQualifiedType(EntityScope parent_h,
                                              HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_isVolatileQualifiedType"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_isVolatileQualifiedType

using Entity_clang_isVolatileQualifiedType =
    Bind_clang_isVolatileQualifiedType<>;

#else

struct Entity_clang_isVolatileQualifiedType
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_isVolatileQualifiedType(EntityScope parent_h) {}
  static const char *Key() { return "clang_isVolatileQualifiedType"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_isVolatileQualifiedType

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_loadDiagnostics : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Deserialize a set of diagnostics from a Clang diagnostics bitcode
 * file.
 *
 * \param file The name of the file to deserialize.
 * \param error A pointer to a enum value recording if there was a problem
 *        deserializing the diagnostics.
 * \param errorString A pointer to a CXString for recording the error string
 *        if the file was not successfully loaded.
 *
 * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These
 * diagnostics should be released using clang_disposeDiagnosticSet().
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_loadDiagnostics_AddFunction
    handle.def(
        "clang_loadDiagnostics",
        [](const char *file, CXLoadDiag_Error *error, CXString *errorString) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void *(const char *, CXLoadDiag_Error *,
                               CXString *)>::type>(&clang_loadDiagnostics),
              file, error, errorString);
          return pybind11_weaver::WrapP<void *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_loadDiagnostics(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_loadDiagnostics(EntityScope parent_h,
                                      HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_loadDiagnostics"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_loadDiagnostics

using Entity_clang_loadDiagnostics = Bind_clang_loadDiagnostics<>;

#else

struct Entity_clang_loadDiagnostics : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_loadDiagnostics(EntityScope parent_h) {}
  static const char *Key() { return "clang_loadDiagnostics"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_loadDiagnostics

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_parseTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Same as \c clang_parseTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_parseTranslationUnit_AddFunction
    handle.def(
        "clang_parseTranslationUnit",
        [](pybind11_weaver::WrappedPtrT<void *> CIdx,
           const char *source_filename,
           pybind11_weaver::WrappedPtrT<const char *const *> command_line_args,
           int num_command_line_args, CXUnsavedFile *unsaved_files,
           unsigned int num_unsaved_files, unsigned int options) {
          auto &&__ret__ = std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, CXTranslationUnitImpl *(
                            void *, const char *, const char *const *, int,
                            CXUnsavedFile *, unsigned int,
                            unsigned int)>::type>(&clang_parseTranslationUnit),
              (CIdx)->Cptr(), source_filename, (command_line_args)->Cptr(),
              num_command_line_args, unsaved_files, num_unsaved_files, options);
          return pybind11_weaver::WrapP<CXTranslationUnitImpl *>(__ret__);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_parseTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_parseTranslationUnit(EntityScope parent_h,
                                           HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_parseTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_parseTranslationUnit

using Entity_clang_parseTranslationUnit = Bind_clang_parseTranslationUnit<>;

#else

struct Entity_clang_parseTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_parseTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_parseTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_parseTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_parseTranslationUnit2 : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Parse the given source file and the translation unit corresponding
 * to that file.
 *
 * This routine is the main entry point for the Clang C API, providing the
 * ability to parse a source file into a translation unit that can then be
 * queried by other functions in the API. This routine accepts a set of
 * command-line arguments so that the compilation can be configured in the same
 * way that the compiler is configured on the command line.
 *
 * \param CIdx The index object with which the translation unit will be
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \c command_line_args.
 *
 * \param command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c',
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_command_line_args The number of command-line arguments in
 * \c command_line_args.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is managed but not its compilation. This should be a bitwise OR of the
 * CXTranslationUnit_XXX flags.
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit, describing the parsed code and containing any
 * diagnostics produced by the compiler.
 *
 * \returns Zero on success, otherwise returns an error code.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_parseTranslationUnit2_AddFunction
    handle.def(
        "clang_parseTranslationUnit2",
        [](pybind11_weaver::WrappedPtrT<void *> CIdx,
           const char *source_filename,
           pybind11_weaver::WrappedPtrT<const char *const *> command_line_args,
           int num_command_line_args, CXUnsavedFile *unsaved_files,
           unsigned int num_unsaved_files, unsigned int options,
           pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl **> out_TU) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  CXErrorCode(void *, const char *, const char *const *, int,
                              CXUnsavedFile *, unsigned int, unsigned int,
                              CXTranslationUnitImpl **)>::type>(
                  &clang_parseTranslationUnit2),
              (CIdx)->Cptr(), source_filename, (command_line_args)->Cptr(),
              num_command_line_args, unsaved_files, num_unsaved_files, options,
              (out_TU)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_parseTranslationUnit2(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_parseTranslationUnit2(EntityScope parent_h,
                                            HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_parseTranslationUnit2"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_parseTranslationUnit2

using Entity_clang_parseTranslationUnit2 = Bind_clang_parseTranslationUnit2<>;

#else

struct Entity_clang_parseTranslationUnit2
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_parseTranslationUnit2(EntityScope parent_h) {}
  static const char *Key() { return "clang_parseTranslationUnit2"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_parseTranslationUnit2

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_parseTranslationUnit2FullArgv : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Same as clang_parseTranslationUnit2 but requires a full command line
 * for \c command_line_args including argv[0]. This is useful if the standard
 * library paths are relative to the binary.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_parseTranslationUnit2FullArgv_AddFunction
    handle.def(
        "clang_parseTranslationUnit2FullArgv",
        [](pybind11_weaver::WrappedPtrT<void *> CIdx,
           const char *source_filename,
           pybind11_weaver::WrappedPtrT<const char *const *> command_line_args,
           int num_command_line_args, CXUnsavedFile *unsaved_files,
           unsigned int num_unsaved_files, unsigned int options,
           pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl **> out_TU) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void,
                  CXErrorCode(void *, const char *, const char *const *, int,
                              CXUnsavedFile *, unsigned int, unsigned int,
                              CXTranslationUnitImpl **)>::type>(
                  &clang_parseTranslationUnit2FullArgv),
              (CIdx)->Cptr(), source_filename, (command_line_args)->Cptr(),
              num_command_line_args, unsaved_files, num_unsaved_files, options,
              (out_TU)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_parseTranslationUnit2FullArgv(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_parseTranslationUnit2FullArgv(EntityScope parent_h,
                                                    HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_parseTranslationUnit2FullArgv"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_parseTranslationUnit2FullArgv

using Entity_clang_parseTranslationUnit2FullArgv =
    Bind_clang_parseTranslationUnit2FullArgv<>;

#else

struct Entity_clang_parseTranslationUnit2FullArgv
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_parseTranslationUnit2FullArgv(EntityScope parent_h) {}
  static const char *Key() { return "clang_parseTranslationUnit2FullArgv"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_parseTranslationUnit2FullArgv

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_remap_dispose : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Dispose the remapping.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_remap_dispose_AddFunction
    handle.def(
        "clang_remap_dispose",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<void, void(void *)>::type>(
                  &clang_remap_dispose),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_remap_dispose(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_remap_dispose(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_remap_dispose"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_remap_dispose

using Entity_clang_remap_dispose = Bind_clang_remap_dispose<>;

#else

struct Entity_clang_remap_dispose : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_remap_dispose(EntityScope parent_h) {}
  static const char *Key() { return "clang_remap_dispose"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_remap_dispose

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_remap_getFilenames : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Get the original and the associated filename from the remapping.
 *
 * \param original If non-NULL, will be set to the original filename.
 *
 * \param transformed If non-NULL, will be set to the filename that the original
 * is associated with.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_remap_getFilenames_AddFunction
    handle.def(
        "clang_remap_getFilenames",
        [](pybind11_weaver::WrappedPtrT<void *> arg0, unsigned int index,
           CXString *original, CXString *transformed) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(void *, unsigned int, CXString *,
                             CXString *)>::type>(&clang_remap_getFilenames),
              (arg0)->Cptr(), index, original, transformed);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_remap_getFilenames(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_remap_getFilenames(EntityScope parent_h,
                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_remap_getFilenames"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_remap_getFilenames

using Entity_clang_remap_getFilenames = Bind_clang_remap_getFilenames<>;

#else

struct Entity_clang_remap_getFilenames
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_remap_getFilenames(EntityScope parent_h) {}
  static const char *Key() { return "clang_remap_getFilenames"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_remap_getFilenames

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_remap_getNumFiles : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Determine the number of remappings.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_remap_getNumFiles_AddFunction
    handle.def(
        "clang_remap_getNumFiles",
        [](pybind11_weaver::WrappedPtrT<void *> arg0) {
          return std::invoke(
              static_cast<
                  pybind11_weaver::FnPtrT<void, unsigned int(void *)>::type>(
                  &clang_remap_getNumFiles),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_remap_getNumFiles(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_remap_getNumFiles(EntityScope parent_h,
                                        HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_remap_getNumFiles"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_remap_getNumFiles

using Entity_clang_remap_getNumFiles = Bind_clang_remap_getNumFiles<>;

#else

struct Entity_clang_remap_getNumFiles : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_remap_getNumFiles(EntityScope parent_h) {}
  static const char *Key() { return "clang_remap_getNumFiles"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_remap_getNumFiles

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_reparseTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Reparse the source files that produced this translation unit.
 *
 * This routine can be used to re-parse the source files that originally
 * created the given translation unit, for example because those source files
 * have changed (either on disk or as passed via \p unsaved_files). The
 * source code will be reparsed with the same command-line options as it
 * was originally parsed.
 *
 * Reparsing a translation unit invalidates all cursors and source locations
 * that refer into that translation unit. This makes reparsing a translation
 * unit semantically equivalent to destroying the translation unit and then
 * creating a new translation unit with the same command-line arguments.
 * However, it may be more efficient to reparse a translation
 * unit using this routine.
 *
 * \param TU The translation unit whose contents will be re-parsed. The
 * translation unit must originally have been built with
 * \c clang_createTranslationUnitFromSourceFile().
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files The files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 *
 * \param options A bitset of options composed of the flags in CXReparse_Flags.
 * The function \c clang_defaultReparseOptions() produces a default set of
 * options recommended for most uses, based on the translation unit.
 *
 * \returns 0 if the sources could be reparsed.  A non-zero error code will be
 * returned if reparsing was impossible, such that the translation unit is
 * invalid. In such cases, the only valid call for \c TU is
 * \c clang_disposeTranslationUnit(TU).  The error codes returned by this
 * routine are described by the \c CXErrorCode enum.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_reparseTranslationUnit_AddFunction
    handle.def(
        "clang_reparseTranslationUnit",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           unsigned int num_unsaved_files, CXUnsavedFile *unsaved_files,
           unsigned int options) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, int(CXTranslationUnitImpl *, unsigned int,
                            CXUnsavedFile *, unsigned int)>::type>(
                  &clang_reparseTranslationUnit),
              (TU)->Cptr(), num_unsaved_files, unsaved_files, options);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_reparseTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_reparseTranslationUnit(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_reparseTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_reparseTranslationUnit

using Entity_clang_reparseTranslationUnit = Bind_clang_reparseTranslationUnit<>;

#else

struct Entity_clang_reparseTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_reparseTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_reparseTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_reparseTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_saveTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Saves a translation unit into a serialized representation of
 * that translation unit on disk.
 *
 * Any translation unit that was parsed without error can be saved
 * into a file. The translation unit can then be deserialized into a
 * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,
 * if it is an incomplete translation unit that corresponds to a
 * header, used as a precompiled header when parsing other translation
 * units.
 *
 * \param TU The translation unit to save.
 *
 * \param FileName The file to which the translation unit will be saved.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is saved. This should be a bitwise OR of the
 * CXSaveTranslationUnit_XXX flags.
 *
 * \returns A value that will match one of the enumerators of the CXSaveError
 * enumeration. Zero (CXSaveError_None) indicates that the translation unit was
 * saved successfully, while a non-zero value indicates that a problem occurred.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_saveTranslationUnit_AddFunction
    handle.def(
        "clang_saveTranslationUnit",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           const char *FileName, unsigned int options) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, int(CXTranslationUnitImpl *, const char *,
                            unsigned int)>::type>(&clang_saveTranslationUnit),
              (TU)->Cptr(), FileName, options);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_saveTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_saveTranslationUnit(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_saveTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_saveTranslationUnit

using Entity_clang_saveTranslationUnit = Bind_clang_saveTranslationUnit<>;

#else

struct Entity_clang_saveTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_saveTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_saveTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_saveTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_sortCodeCompletionResults : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Sort the code-completion results in case-insensitive alphabetical
 * order.
 *
 * \param Results The set of results to sort.
 * \param NumResults The number of results in \p Results.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_sortCodeCompletionResults_AddFunction
    handle.def(
        "clang_sortCodeCompletionResults",
        static_cast<pybind11_weaver::FnPtrT<void, void(CXCompletionResult *,
                                                       unsigned int)>::type>(
            &clang_sortCodeCompletionResults),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_sortCodeCompletionResults(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_sortCodeCompletionResults(EntityScope parent_h,
                                                HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_sortCodeCompletionResults"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_sortCodeCompletionResults

using Entity_clang_sortCodeCompletionResults =
    Bind_clang_sortCodeCompletionResults<>;

#else

struct Entity_clang_sortCodeCompletionResults
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_sortCodeCompletionResults(EntityScope parent_h) {}
  static const char *Key() { return "clang_sortCodeCompletionResults"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_sortCodeCompletionResults

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_suspendTranslationUnit : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Suspend a translation unit in order to free memory associated with it.
 *
 * A suspended translation unit uses significantly less memory but on the other
 * side does not support any other calls than \c clang_reparseTranslationUnit
 * to resume it or \c clang_disposeTranslationUnit to dispose it completely.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_suspendTranslationUnit_AddFunction
    handle.def(
        "clang_suspendTranslationUnit",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> arg0) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(CXTranslationUnitImpl *)>::type>(
                  &clang_suspendTranslationUnit),
              (arg0)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_suspendTranslationUnit(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_suspendTranslationUnit(EntityScope parent_h,
                                             HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_suspendTranslationUnit"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_suspendTranslationUnit

using Entity_clang_suspendTranslationUnit = Bind_clang_suspendTranslationUnit<>;

#else

struct Entity_clang_suspendTranslationUnit
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_suspendTranslationUnit(EntityScope parent_h) {}
  static const char *Key() { return "clang_suspendTranslationUnit"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_suspendTranslationUnit

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_toggleCrashRecovery : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Enable/disable crash recovery.
 *
 * \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero
 *        value enables crash recovery, while 0 disables it.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_toggleCrashRecovery_AddFunction
    handle.def(
        "clang_toggleCrashRecovery",
        static_cast<pybind11_weaver::FnPtrT<void, void(unsigned int)>::type>(
            &clang_toggleCrashRecovery),
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_toggleCrashRecovery(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_toggleCrashRecovery(EntityScope parent_h,
                                          HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_toggleCrashRecovery"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_toggleCrashRecovery

using Entity_clang_toggleCrashRecovery = Bind_clang_toggleCrashRecovery<>;

#else

struct Entity_clang_toggleCrashRecovery
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_toggleCrashRecovery(EntityScope parent_h) {}
  static const char *Key() { return "clang_toggleCrashRecovery"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_toggleCrashRecovery

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_tokenize : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Tokenize the source code described by the given range into raw
 * lexical tokens.
 *
 * \param TU the translation unit whose text is being tokenized.
 *
 * \param Range the source range in which text should be tokenized. All of the
 * tokens produced by tokenization will fall within this source range,
 *
 * \param Tokens this pointer will be set to point to the array of tokens
 * that occur within the given source range. The returned pointer must be
 * freed with clang_disposeTokens() before the translation unit is destroyed.
 *
 * \param NumTokens will be set to the number of tokens in the \c *Tokens
 * array.
 *
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_tokenize_AddFunction
    handle.def(
        "clang_tokenize",
        [](pybind11_weaver::WrappedPtrT<CXTranslationUnitImpl *> TU,
           CXSourceRange Range, pybind11_weaver::WrappedPtrT<CXToken **> Tokens,
           unsigned int *NumTokens) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, void(CXTranslationUnitImpl *, CXSourceRange, CXToken **,
                             unsigned int *)>::type>(&clang_tokenize),
              (TU)->Cptr(), Range, (Tokens)->Cptr(), NumTokens);
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_tokenize(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_tokenize(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_tokenize"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_tokenize

using Entity_clang_tokenize = Bind_clang_tokenize<>;

#else

struct Entity_clang_tokenize : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_tokenize(EntityScope parent_h) {}
  static const char *Key() { return "clang_tokenize"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_tokenize

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_uninstall_llvm_fatal_error_handler : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Removes currently installed error handler (if any).
 * If no error handler is intalled, the default strategy is to print error
 * message to stderr and call exit(1).
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_uninstall_llvm_fatal_error_handler_AddFunction
    handle.def("clang_uninstall_llvm_fatal_error_handler",
               static_cast<pybind11_weaver::FnPtrT<void, void()>::type>(
                   &clang_uninstall_llvm_fatal_error_handler),
               _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_uninstall_llvm_fatal_error_handler(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_uninstall_llvm_fatal_error_handler(EntityScope parent_h,
                                                         HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() {
    return "clang_uninstall_llvm_fatal_error_handler";
  }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_uninstall_llvm_fatal_error_handler

using Entity_clang_uninstall_llvm_fatal_error_handler =
    Bind_clang_uninstall_llvm_fatal_error_handler<>;

#else

struct Entity_clang_uninstall_llvm_fatal_error_handler
    : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_uninstall_llvm_fatal_error_handler(
      EntityScope parent_h) {}
  static const char *Key() {
    return "clang_uninstall_llvm_fatal_error_handler";
  }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_uninstall_llvm_fatal_error_handler

template <class Pybind11T = pybind11::module_ &>
struct Bind_clang_visitChildren : public EntityBase {
  using Pybind11Type = Pybind11T;

  virtual const char *AddFunction() {
    const char *_pb11_weaver_comment_str = R"_pb11_weaver(/**
 * Visit the children of a particular cursor.
 *
 * This function visits all the direct children of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited child. The traversal may be recursive, if the visitor returns
 * \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if
 * the visitor returns \c CXChildVisit_Break.
 *
 * \param parent the cursor whose child may be visited. All kinds of
 * cursors can be visited, including invalid cursors (which, by
 * definition, have no children).
 *
 * \param visitor the visitor function that will be invoked for each
 * child of \p parent.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXChildVisit_Break.
 */)_pb11_weaver";

#ifndef PB11_WEAVER_DISABLE_clang_visitChildren_AddFunction
    handle.def(
        "clang_visitChildren",
        [](CXCursor parent,
           std::function<CXChildVisitResult(
               CXCursor, CXCursor, pybind11_weaver::WrappedPtrT<void *>)>
               visitor,
           pybind11_weaver::WrappedPtrT<void *> client_data) {
          return std::invoke(
              static_cast<pybind11_weaver::FnPtrT<
                  void, unsigned int(
                            CXCursor,
                            CXChildVisitResult(*)(CXCursor, CXCursor, void *),
                            void *)>::type>(&clang_visitChildren),
              parent,
              pybind11_weaver::FnPointerWrapper<
                  CXChildVisitResult, CXCursor, CXCursor,
                  pybind11_weaver::WrappedPtrT<void *>>::
                  GetCptr<CXChildVisitResult, CXCursor, CXCursor, void *>::Run(
                      (visitor), pybind11_weaver::Guardian(),
                      [](CXCursor arg0_0, CXCursor arg0_1, void *arg0_2) {
                        auto to_call = pybind11_weaver::FnPointerWrapper<
                            CXChildVisitResult, CXCursor, CXCursor,
                            pybind11_weaver::WrappedPtrT<void *>>::
                            GetFnProxy(__DATE__ __TIME__ __FILE__, __COUNTER__);
                        return to_call(arg0_0, arg0_1,
                                       pybind11_weaver::WrapP<void *>(arg0_2));
                      },
                      /* clang-format off */
__DATE__ __TIME__ __FILE__, 
__COUNTER__ - 1
                      /* clang-format on */
                      ),
              (client_data)->Cptr());
        },
        _pb11_weaver_comment_str);
#endif
    return _pb11_weaver_comment_str;
  }

  explicit Bind_clang_visitChildren(EntityScope parent_h)
      : handle{static_cast<pybind11::module_ &>(parent_h)} {}

  template <class... HandleArgsT>
  explicit Bind_clang_visitChildren(EntityScope parent_h, HandleArgsT &&...args)
      : handle{std::forward(args)...} {}

  void Update() override { AddFunction(); }

  EntityScope AsScope() override { return EntityScope(handle); }

  static const char *Key() { return "clang_visitChildren"; }

  Pybind11Type handle;
};
#ifndef PB11_WEAVER_DISABLE_Entity_clang_visitChildren

using Entity_clang_visitChildren = Bind_clang_visitChildren<>;

#else

struct Entity_clang_visitChildren : public pybind11_weaver::DisabledEntity {
  explicit Entity_clang_visitChildren(EntityScope parent_h) {}
  static const char *Key() { return "clang_visitChildren"; }
};

#endif // PB11_WEAVER_DISABLE_Entity_clang_visitChildren

/**
 * Create all entities, return a callable guard that can be called to update all
 *entities. If the returned guard is not called, the guard will call the update
 *function on its destruction.
 **/
[[nodiscard]] pybind11_weaver::CallUpdateGuard
DeclFn(pybind11::module &m,
       const pybind11_weaver::CustomBindingRegistry &registry) {
  pybind11_weaver::_PointerWrapperBase::FastBind(m);
  pybind11_weaver::PointerWrapper<CXAPISetImpl *>::FastBind(m, "CXAPISetImplp");
  pybind11_weaver::PointerWrapper<CXAPISetImpl **>::FastBind(m,
                                                             "CXAPISetImplpp");
  pybind11_weaver::PointerWrapper<CXCursor **>::FastBind(m, "CXCursorpp");
  pybind11_weaver::PointerWrapper<CXCursorSetImpl *>::FastBind(
      m, "CXCursorSetImplp");
  pybind11_weaver::PointerWrapper<CXModuleMapDescriptorImpl *>::FastBind(
      m, "CXModuleMapDescriptorImplp");
  pybind11_weaver::PointerWrapper<CXTargetInfoImpl *>::FastBind(
      m, "CXTargetInfoImplp");
  pybind11_weaver::PointerWrapper<CXToken **>::FastBind(m, "CXTokenpp");
  pybind11_weaver::PointerWrapper<CXTranslationUnitImpl *>::FastBind(
      m, "CXTranslationUnitImplp");
  pybind11_weaver::PointerWrapper<CXTranslationUnitImpl **>::FastBind(
      m, "CXTranslationUnitImplpp");
  pybind11_weaver::PointerWrapper<CXVirtualFileOverlayImpl *>::FastBind(
      m, "CXVirtualFileOverlayImplp");
  pybind11_weaver::PointerWrapper<char **>::FastBind(m, "charpp");
  pybind11_weaver::PointerWrapper<const CXIdxAttrInfo *const *>::FastBind(
      m, "constCXIdxAttrInfopconstp");
  pybind11_weaver::PointerWrapper<const CXIdxBaseClassInfo *const *>::FastBind(
      m, "constCXIdxBaseClassInfopconstp");
  pybind11_weaver::PointerWrapper<const CXIdxObjCProtocolRefInfo *const *>::
      FastBind(m, "constCXIdxObjCProtocolRefInfopconstp");
  pybind11_weaver::PointerWrapper<const char **>::FastBind(m, "constcharpp");
  pybind11_weaver::PointerWrapper<const char *const *>::FastBind(
      m, "constcharpconstp");
  pybind11_weaver::PointerWrapper<const void *>::FastBind(m, "constvoidp");
  pybind11_weaver::PointerWrapper<void *>::FastBind(m, "voidp");
  pybind11_weaver::PointerWrapper<void **>::FastBind(m, "voidpp");

  auto v0 = pybind11_weaver::CreateEntity<Entity_CXAvailabilityKind>(
      EntityScope(m), registry);
  auto v1 = pybind11_weaver::CreateEntity<Entity_CXCallingConv>(EntityScope(m),
                                                                registry);
  auto v2 = pybind11_weaver::CreateEntity<Entity_CXChildVisitResult>(
      EntityScope(m), registry);
  auto v3 = pybind11_weaver::CreateEntity<Entity_CXCodeCompleteResults>(
      EntityScope(m), registry);
  auto v4 = pybind11_weaver::CreateEntity<Entity_CXCodeComplete_Flags>(
      EntityScope(m), registry);
  auto v5 =
      pybind11_weaver::CreateEntity<Entity_CXComment>(EntityScope(m), registry);
  auto v6 =
      pybind11_weaver::CreateEntity<Entity_CXCommentInlineCommandRenderKind>(
          EntityScope(m), registry);
  auto v7 = pybind11_weaver::CreateEntity<Entity_CXCommentKind>(EntityScope(m),
                                                                registry);
  auto v8 = pybind11_weaver::CreateEntity<Entity_CXCommentParamPassDirection>(
      EntityScope(m), registry);
  auto v9 = pybind11_weaver::CreateEntity<Entity_CXCompilationDatabase_Error>(
      EntityScope(m), registry);
  auto v10 = pybind11_weaver::CreateEntity<Entity_CXCompletionChunkKind>(
      EntityScope(m), registry);
  auto v11 = pybind11_weaver::CreateEntity<Entity_CXCompletionContext>(
      EntityScope(m), registry);
  auto v12 = pybind11_weaver::CreateEntity<Entity_CXCompletionResult>(
      EntityScope(m), registry);
  auto v13 =
      pybind11_weaver::CreateEntity<Entity_CXCursor>(EntityScope(m), registry);
  auto v14 = pybind11_weaver::CreateEntity<Entity_CXCursorAndRangeVisitor>(
      EntityScope(m), registry);
  auto v15 = pybind11_weaver::CreateEntity<Entity_CXCursorKind>(EntityScope(m),
                                                                registry);
  auto v16 =
      pybind11_weaver::CreateEntity<Entity_CXCursor_ExceptionSpecificationKind>(
          EntityScope(m), registry);
  auto v17 = pybind11_weaver::CreateEntity<Entity_CXDiagnosticDisplayOptions>(
      EntityScope(m), registry);
  auto v18 = pybind11_weaver::CreateEntity<Entity_CXDiagnosticSeverity>(
      EntityScope(m), registry);
  auto v19 = pybind11_weaver::CreateEntity<Entity_CXErrorCode>(EntityScope(m),
                                                               registry);
  auto v20 = pybind11_weaver::CreateEntity<Entity_CXEvalResultKind>(
      EntityScope(m), registry);
  auto v21 = pybind11_weaver::CreateEntity<Entity_CXFileUniqueID>(
      EntityScope(m), registry);
  auto v22 = pybind11_weaver::CreateEntity<Entity_CXGlobalOptFlags>(
      EntityScope(m), registry);
  auto v23 = pybind11_weaver::CreateEntity<Entity_CXIdxAttrInfo>(EntityScope(m),
                                                                 registry);
  auto v24 = pybind11_weaver::CreateEntity<Entity_CXIdxAttrKind>(EntityScope(m),
                                                                 registry);
  auto v25 = pybind11_weaver::CreateEntity<Entity_CXIdxBaseClassInfo>(
      EntityScope(m), registry);
  auto v26 = pybind11_weaver::CreateEntity<Entity_CXIdxCXXClassDeclInfo>(
      EntityScope(m), registry);
  auto v27 = pybind11_weaver::CreateEntity<Entity_CXIdxContainerInfo>(
      EntityScope(m), registry);
  auto v28 = pybind11_weaver::CreateEntity<Entity_CXIdxDeclInfo>(EntityScope(m),
                                                                 registry);
  auto v29 = pybind11_weaver::CreateEntity<Entity_CXIdxDeclInfoFlags>(
      EntityScope(m), registry);
  auto v30 = pybind11_weaver::CreateEntity<Entity_CXIdxEntityCXXTemplateKind>(
      EntityScope(m), registry);
  auto v31 = pybind11_weaver::CreateEntity<Entity_CXIdxEntityInfo>(
      EntityScope(m), registry);
  auto v32 = pybind11_weaver::CreateEntity<Entity_CXIdxEntityKind>(
      EntityScope(m), registry);
  auto v33 = pybind11_weaver::CreateEntity<Entity_CXIdxEntityLanguage>(
      EntityScope(m), registry);
  auto v34 = pybind11_weaver::CreateEntity<Entity_CXIdxEntityRefInfo>(
      EntityScope(m), registry);
  auto v35 = pybind11_weaver::CreateEntity<Entity_CXIdxEntityRefKind>(
      EntityScope(m), registry);
  auto v36 =
      pybind11_weaver::CreateEntity<Entity_CXIdxIBOutletCollectionAttrInfo>(
          EntityScope(m), registry);
  auto v37 = pybind11_weaver::CreateEntity<Entity_CXIdxImportedASTFileInfo>(
      EntityScope(m), registry);
  auto v38 = pybind11_weaver::CreateEntity<Entity_CXIdxIncludedFileInfo>(
      EntityScope(m), registry);
  auto v39 =
      pybind11_weaver::CreateEntity<Entity_CXIdxLoc>(EntityScope(m), registry);
  auto v40 = pybind11_weaver::CreateEntity<Entity_CXIdxObjCCategoryDeclInfo>(
      EntityScope(m), registry);
  auto v41 = pybind11_weaver::CreateEntity<Entity_CXIdxObjCContainerDeclInfo>(
      EntityScope(m), registry);
  auto v42 = pybind11_weaver::CreateEntity<Entity_CXIdxObjCContainerKind>(
      EntityScope(m), registry);
  auto v43 = pybind11_weaver::CreateEntity<Entity_CXIdxObjCInterfaceDeclInfo>(
      EntityScope(m), registry);
  auto v44 = pybind11_weaver::CreateEntity<Entity_CXIdxObjCPropertyDeclInfo>(
      EntityScope(m), registry);
  auto v45 = pybind11_weaver::CreateEntity<Entity_CXIdxObjCProtocolRefInfo>(
      EntityScope(m), registry);
  auto v46 = pybind11_weaver::CreateEntity<Entity_CXIdxObjCProtocolRefListInfo>(
      EntityScope(m), registry);
  auto v47 = pybind11_weaver::CreateEntity<Entity_CXIndexOptFlags>(
      EntityScope(m), registry);
  auto v48 = pybind11_weaver::CreateEntity<Entity_CXLanguageKind>(
      EntityScope(m), registry);
  auto v49 = pybind11_weaver::CreateEntity<Entity_CXLinkageKind>(EntityScope(m),
                                                                 registry);
  auto v50 = pybind11_weaver::CreateEntity<Entity_CXLoadDiag_Error>(
      EntityScope(m), registry);
  auto v51 = pybind11_weaver::CreateEntity<Entity_CXNameRefFlags>(
      EntityScope(m), registry);
  auto v52 = pybind11_weaver::CreateEntity<Entity_CXObjCDeclQualifierKind>(
      EntityScope(m), registry);
  auto v53 = pybind11_weaver::CreateEntity<Entity_CXObjCPropertyAttrKind>(
      EntityScope(m), registry);
  auto v54 = pybind11_weaver::CreateEntity<Entity_CXPlatformAvailability>(
      EntityScope(m), registry);
  auto v55 = pybind11_weaver::CreateEntity<Entity_CXPrintingPolicyProperty>(
      EntityScope(m), registry);
  auto v56 = pybind11_weaver::CreateEntity<Entity_CXRefQualifierKind>(
      EntityScope(m), registry);
  auto v57 = pybind11_weaver::CreateEntity<Entity_CXReparse_Flags>(
      EntityScope(m), registry);
  auto v58 =
      pybind11_weaver::CreateEntity<Entity_CXResult>(EntityScope(m), registry);
  auto v59 = pybind11_weaver::CreateEntity<Entity_CXSaveError>(EntityScope(m),
                                                               registry);
  auto v60 = pybind11_weaver::CreateEntity<Entity_CXSaveTranslationUnit_Flags>(
      EntityScope(m), registry);
  auto v61 = pybind11_weaver::CreateEntity<Entity_CXSourceLocation>(
      EntityScope(m), registry);
  auto v62 = pybind11_weaver::CreateEntity<Entity_CXSourceRange>(EntityScope(m),
                                                                 registry);
  auto v63 = pybind11_weaver::CreateEntity<Entity_CXSourceRangeList>(
      EntityScope(m), registry);
  auto v64 =
      pybind11_weaver::CreateEntity<Entity_CXString>(EntityScope(m), registry);
  auto v65 = pybind11_weaver::CreateEntity<Entity_CXStringSet>(EntityScope(m),
                                                               registry);
  auto v66 = pybind11_weaver::CreateEntity<Entity_CXSymbolRole>(EntityScope(m),
                                                                registry);
  auto v67 =
      pybind11_weaver::CreateEntity<Entity_CXTLSKind>(EntityScope(m), registry);
  auto v68 = pybind11_weaver::CreateEntity<Entity_CXTUResourceUsage>(
      EntityScope(m), registry);
  auto v69 = pybind11_weaver::CreateEntity<Entity_CXTUResourceUsageEntry>(
      EntityScope(m), registry);
  auto v70 = pybind11_weaver::CreateEntity<Entity_CXTUResourceUsageKind>(
      EntityScope(m), registry);
  auto v71 = pybind11_weaver::CreateEntity<Entity_CXTemplateArgumentKind>(
      EntityScope(m), registry);
  auto v72 =
      pybind11_weaver::CreateEntity<Entity_CXToken>(EntityScope(m), registry);
  auto v73 = pybind11_weaver::CreateEntity<Entity_CXTokenKind>(EntityScope(m),
                                                               registry);
  auto v74 = pybind11_weaver::CreateEntity<Entity_CXTranslationUnit_Flags>(
      EntityScope(m), registry);
  auto v75 =
      pybind11_weaver::CreateEntity<Entity_CXType>(EntityScope(m), registry);
  auto v76 = pybind11_weaver::CreateEntity<Entity_CXTypeKind>(EntityScope(m),
                                                              registry);
  auto v77 = pybind11_weaver::CreateEntity<Entity_CXTypeLayoutError>(
      EntityScope(m), registry);
  auto v78 = pybind11_weaver::CreateEntity<Entity_CXTypeNullabilityKind>(
      EntityScope(m), registry);
  auto v79 = pybind11_weaver::CreateEntity<Entity_CXUnsavedFile>(EntityScope(m),
                                                                 registry);
  auto v80 =
      pybind11_weaver::CreateEntity<Entity_CXVersion>(EntityScope(m), registry);
  auto v81 = pybind11_weaver::CreateEntity<Entity_CXVisibilityKind>(
      EntityScope(m), registry);
  auto v82 = pybind11_weaver::CreateEntity<Entity_CXVisitorResult>(
      EntityScope(m), registry);
  auto v83 = pybind11_weaver::CreateEntity<Entity_CX_CXXAccessSpecifier>(
      EntityScope(m), registry);
  auto v84 = pybind11_weaver::CreateEntity<Entity_CX_StorageClass>(
      EntityScope(m), registry);
  auto v85 = pybind11_weaver::CreateEntity<Entity_IndexerCallbacks>(
      EntityScope(m), registry);
  auto v86 = pybind11_weaver::CreateEntity<
      Entity_clang_BlockCommandComment_getArgText>(EntityScope(m), registry);
  auto v87 = pybind11_weaver::CreateEntity<
      Entity_clang_BlockCommandComment_getCommandName>(EntityScope(m),
                                                       registry);
  auto v88 = pybind11_weaver::CreateEntity<
      Entity_clang_BlockCommandComment_getNumArgs>(EntityScope(m), registry);
  auto v89 = pybind11_weaver::CreateEntity<
      Entity_clang_BlockCommandComment_getParagraph>(EntityScope(m), registry);
  auto v90 = pybind11_weaver::CreateEntity<Entity_clang_CXCursorSet_contains>(
      EntityScope(m), registry);
  auto v91 = pybind11_weaver::CreateEntity<Entity_clang_CXCursorSet_insert>(
      EntityScope(m), registry);
  auto v92 =
      pybind11_weaver::CreateEntity<Entity_clang_CXIndex_getGlobalOptions>(
          EntityScope(m), registry);
  auto v93 =
      pybind11_weaver::CreateEntity<Entity_clang_CXIndex_setGlobalOptions>(
          EntityScope(m), registry);
  auto v94 = pybind11_weaver::CreateEntity<
      Entity_clang_CXIndex_setInvocationEmissionPathOption>(EntityScope(m),
                                                            registry);
  auto v95 = pybind11_weaver::CreateEntity<Entity_clang_CXRewriter_create>(
      EntityScope(m), registry);
  auto v96 = pybind11_weaver::CreateEntity<Entity_clang_CXRewriter_dispose>(
      EntityScope(m), registry);
  auto v97 =
      pybind11_weaver::CreateEntity<Entity_clang_CXRewriter_insertTextBefore>(
          EntityScope(m), registry);
  auto v98 = pybind11_weaver::CreateEntity<
      Entity_clang_CXRewriter_overwriteChangedFiles>(EntityScope(m), registry);
  auto v99 = pybind11_weaver::CreateEntity<Entity_clang_CXRewriter_removeText>(
      EntityScope(m), registry);
  auto v100 =
      pybind11_weaver::CreateEntity<Entity_clang_CXRewriter_replaceText>(
          EntityScope(m), registry);
  auto v101 = pybind11_weaver::CreateEntity<
      Entity_clang_CXRewriter_writeMainFileToStdOut>(EntityScope(m), registry);
  auto v102 = pybind11_weaver::CreateEntity<
      Entity_clang_CXXConstructor_isConvertingConstructor>(EntityScope(m),
                                                           registry);
  auto v103 = pybind11_weaver::CreateEntity<
      Entity_clang_CXXConstructor_isCopyConstructor>(EntityScope(m), registry);
  auto v104 = pybind11_weaver::CreateEntity<
      Entity_clang_CXXConstructor_isDefaultConstructor>(EntityScope(m),
                                                        registry);
  auto v105 = pybind11_weaver::CreateEntity<
      Entity_clang_CXXConstructor_isMoveConstructor>(EntityScope(m), registry);
  auto v106 = pybind11_weaver::CreateEntity<Entity_clang_CXXField_isMutable>(
      EntityScope(m), registry);
  auto v107 = pybind11_weaver::CreateEntity<Entity_clang_CXXMethod_isConst>(
      EntityScope(m), registry);
  auto v108 = pybind11_weaver::CreateEntity<
      Entity_clang_CXXMethod_isCopyAssignmentOperator>(EntityScope(m),
                                                       registry);
  auto v109 = pybind11_weaver::CreateEntity<Entity_clang_CXXMethod_isDefaulted>(
      EntityScope(m), registry);
  auto v110 = pybind11_weaver::CreateEntity<Entity_clang_CXXMethod_isDeleted>(
      EntityScope(m), registry);
  auto v111 = pybind11_weaver::CreateEntity<
      Entity_clang_CXXMethod_isMoveAssignmentOperator>(EntityScope(m),
                                                       registry);
  auto v112 =
      pybind11_weaver::CreateEntity<Entity_clang_CXXMethod_isPureVirtual>(
          EntityScope(m), registry);
  auto v113 = pybind11_weaver::CreateEntity<Entity_clang_CXXMethod_isStatic>(
      EntityScope(m), registry);
  auto v114 = pybind11_weaver::CreateEntity<Entity_clang_CXXMethod_isVirtual>(
      EntityScope(m), registry);
  auto v115 = pybind11_weaver::CreateEntity<Entity_clang_CXXRecord_isAbstract>(
      EntityScope(m), registry);
  auto v116 = pybind11_weaver::CreateEntity<Entity_clang_Comment_getChild>(
      EntityScope(m), registry);
  auto v117 = pybind11_weaver::CreateEntity<Entity_clang_Comment_getKind>(
      EntityScope(m), registry);
  auto v118 =
      pybind11_weaver::CreateEntity<Entity_clang_Comment_getNumChildren>(
          EntityScope(m), registry);
  auto v119 = pybind11_weaver::CreateEntity<Entity_clang_Comment_isWhitespace>(
      EntityScope(m), registry);
  auto v120 =
      pybind11_weaver::CreateEntity<Entity_clang_CompilationDatabase_dispose>(
          EntityScope(m), registry);
  auto v121 = pybind11_weaver::CreateEntity<
      Entity_clang_CompilationDatabase_fromDirectory>(EntityScope(m), registry);
  auto v122 = pybind11_weaver::CreateEntity<
      Entity_clang_CompilationDatabase_getAllCompileCommands>(EntityScope(m),
                                                              registry);
  auto v123 = pybind11_weaver::CreateEntity<
      Entity_clang_CompilationDatabase_getCompileCommands>(EntityScope(m),
                                                           registry);
  auto v124 = pybind11_weaver::CreateEntity<Entity_clang_CompileCommand_getArg>(
      EntityScope(m), registry);
  auto v125 =
      pybind11_weaver::CreateEntity<Entity_clang_CompileCommand_getDirectory>(
          EntityScope(m), registry);
  auto v126 =
      pybind11_weaver::CreateEntity<Entity_clang_CompileCommand_getFilename>(
          EntityScope(m), registry);
  auto v127 = pybind11_weaver::CreateEntity<
      Entity_clang_CompileCommand_getMappedSourceContent>(EntityScope(m),
                                                          registry);
  auto v128 = pybind11_weaver::CreateEntity<
      Entity_clang_CompileCommand_getMappedSourcePath>(EntityScope(m),
                                                       registry);
  auto v129 =
      pybind11_weaver::CreateEntity<Entity_clang_CompileCommand_getNumArgs>(
          EntityScope(m), registry);
  auto v130 = pybind11_weaver::CreateEntity<
      Entity_clang_CompileCommand_getNumMappedSources>(EntityScope(m),
                                                       registry);
  auto v131 =
      pybind11_weaver::CreateEntity<Entity_clang_CompileCommands_dispose>(
          EntityScope(m), registry);
  auto v132 =
      pybind11_weaver::CreateEntity<Entity_clang_CompileCommands_getCommand>(
          EntityScope(m), registry);
  auto v133 =
      pybind11_weaver::CreateEntity<Entity_clang_CompileCommands_getSize>(
          EntityScope(m), registry);
  auto v134 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_Evaluate>(
      EntityScope(m), registry);
  auto v135 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_getArgument>(
      EntityScope(m), registry);
  auto v136 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getBriefCommentText>(
          EntityScope(m), registry);
  auto v137 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getCXXManglings>(
          EntityScope(m), registry);
  auto v138 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getCommentRange>(
          EntityScope(m), registry);
  auto v139 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_getMangling>(
      EntityScope(m), registry);
  auto v140 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_getModule>(
      EntityScope(m), registry);
  auto v141 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getNumArguments>(
          EntityScope(m), registry);
  auto v142 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getNumTemplateArguments>(EntityScope(m), registry);
  auto v143 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getObjCDeclQualifiers>(
          EntityScope(m), registry);
  auto v144 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getObjCManglings>(
          EntityScope(m), registry);
  auto v145 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getObjCPropertyAttributes>(EntityScope(m), registry);
  auto v146 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getObjCPropertyGetterName>(EntityScope(m), registry);
  auto v147 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getObjCPropertySetterName>(EntityScope(m), registry);
  auto v148 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getObjCSelectorIndex>(
          EntityScope(m), registry);
  auto v149 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getOffsetOfField>(
          EntityScope(m), registry);
  auto v150 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getParsedComment>(
          EntityScope(m), registry);
  auto v151 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getRawCommentText>(
          EntityScope(m), registry);
  auto v152 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getReceiverType>(
          EntityScope(m), registry);
  auto v153 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getSpellingNameRange>(
          EntityScope(m), registry);
  auto v154 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getStorageClass>(
          EntityScope(m), registry);
  auto v155 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getTemplateArgumentKind>(EntityScope(m), registry);
  auto v156 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getTemplateArgumentType>(EntityScope(m), registry);
  auto v157 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getTemplateArgumentUnsignedValue>(EntityScope(m),
                                                            registry);
  auto v158 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_getTemplateArgumentValue>(EntityScope(m), registry);
  auto v159 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getTranslationUnit>(
          EntityScope(m), registry);
  auto v160 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_getVarDeclInitializer>(
          EntityScope(m), registry);
  auto v161 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_hasAttrs>(
      EntityScope(m), registry);
  auto v162 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_hasVarDeclExternalStorage>(EntityScope(m), registry);
  auto v163 = pybind11_weaver::CreateEntity<
      Entity_clang_Cursor_hasVarDeclGlobalStorage>(EntityScope(m), registry);
  auto v164 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_isAnonymous>(
      EntityScope(m), registry);
  auto v165 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_isAnonymousRecordDecl>(
          EntityScope(m), registry);
  auto v166 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_isBitField>(
      EntityScope(m), registry);
  auto v167 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_isDynamicCall>(
      EntityScope(m), registry);
  auto v168 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_isExternalSymbol>(
          EntityScope(m), registry);
  auto v169 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_isFunctionInlined>(
          EntityScope(m), registry);
  auto v170 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_isInlineNamespace>(
          EntityScope(m), registry);
  auto v171 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_isMacroBuiltin>(
      EntityScope(m), registry);
  auto v172 =
      pybind11_weaver::CreateEntity<Entity_clang_Cursor_isMacroFunctionLike>(
          EntityScope(m), registry);
  auto v173 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_isNull>(
      EntityScope(m), registry);
  auto v174 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_isObjCOptional>(
      EntityScope(m), registry);
  auto v175 = pybind11_weaver::CreateEntity<Entity_clang_Cursor_isVariadic>(
      EntityScope(m), registry);
  auto v176 = pybind11_weaver::CreateEntity<Entity_clang_EnumDecl_isScoped>(
      EntityScope(m), registry);
  auto v177 = pybind11_weaver::CreateEntity<Entity_clang_EvalResult_dispose>(
      EntityScope(m), registry);
  auto v178 =
      pybind11_weaver::CreateEntity<Entity_clang_EvalResult_getAsDouble>(
          EntityScope(m), registry);
  auto v179 = pybind11_weaver::CreateEntity<Entity_clang_EvalResult_getAsInt>(
      EntityScope(m), registry);
  auto v180 =
      pybind11_weaver::CreateEntity<Entity_clang_EvalResult_getAsLongLong>(
          EntityScope(m), registry);
  auto v181 = pybind11_weaver::CreateEntity<Entity_clang_EvalResult_getAsStr>(
      EntityScope(m), registry);
  auto v182 =
      pybind11_weaver::CreateEntity<Entity_clang_EvalResult_getAsUnsigned>(
          EntityScope(m), registry);
  auto v183 = pybind11_weaver::CreateEntity<Entity_clang_EvalResult_getKind>(
      EntityScope(m), registry);
  auto v184 =
      pybind11_weaver::CreateEntity<Entity_clang_EvalResult_isUnsignedInt>(
          EntityScope(m), registry);
  auto v185 = pybind11_weaver::CreateEntity<Entity_clang_File_isEqual>(
      EntityScope(m), registry);
  auto v186 =
      pybind11_weaver::CreateEntity<Entity_clang_File_tryGetRealPathName>(
          EntityScope(m), registry);
  auto v187 = pybind11_weaver::CreateEntity<Entity_clang_FullComment_getAsHTML>(
      EntityScope(m), registry);
  auto v188 = pybind11_weaver::CreateEntity<Entity_clang_FullComment_getAsXML>(
      EntityScope(m), registry);
  auto v189 = pybind11_weaver::CreateEntity<
      Entity_clang_HTMLStartTagComment_isSelfClosing>(EntityScope(m), registry);
  auto v190 =
      pybind11_weaver::CreateEntity<Entity_clang_HTMLStartTag_getAttrName>(
          EntityScope(m), registry);
  auto v191 =
      pybind11_weaver::CreateEntity<Entity_clang_HTMLStartTag_getAttrValue>(
          EntityScope(m), registry);
  auto v192 =
      pybind11_weaver::CreateEntity<Entity_clang_HTMLStartTag_getNumAttrs>(
          EntityScope(m), registry);
  auto v193 =
      pybind11_weaver::CreateEntity<Entity_clang_HTMLTagComment_getAsString>(
          EntityScope(m), registry);
  auto v194 =
      pybind11_weaver::CreateEntity<Entity_clang_HTMLTagComment_getTagName>(
          EntityScope(m), registry);
  auto v195 = pybind11_weaver::CreateEntity<Entity_clang_IndexAction_create>(
      EntityScope(m), registry);
  auto v196 = pybind11_weaver::CreateEntity<Entity_clang_IndexAction_dispose>(
      EntityScope(m), registry);
  auto v197 = pybind11_weaver::CreateEntity<
      Entity_clang_InlineCommandComment_getArgText>(EntityScope(m), registry);
  auto v198 = pybind11_weaver::CreateEntity<
      Entity_clang_InlineCommandComment_getCommandName>(EntityScope(m),
                                                        registry);
  auto v199 = pybind11_weaver::CreateEntity<
      Entity_clang_InlineCommandComment_getNumArgs>(EntityScope(m), registry);
  auto v200 = pybind11_weaver::CreateEntity<
      Entity_clang_InlineCommandComment_getRenderKind>(EntityScope(m),
                                                       registry);
  auto v201 = pybind11_weaver::CreateEntity<
      Entity_clang_InlineContentComment_hasTrailingNewline>(EntityScope(m),
                                                            registry);
  auto v202 =
      pybind11_weaver::CreateEntity<Entity_clang_Location_isFromMainFile>(
          EntityScope(m), registry);
  auto v203 =
      pybind11_weaver::CreateEntity<Entity_clang_Location_isInSystemHeader>(
          EntityScope(m), registry);
  auto v204 =
      pybind11_weaver::CreateEntity<Entity_clang_ModuleMapDescriptor_create>(
          EntityScope(m), registry);
  auto v205 =
      pybind11_weaver::CreateEntity<Entity_clang_ModuleMapDescriptor_dispose>(
          EntityScope(m), registry);
  auto v206 = pybind11_weaver::CreateEntity<
      Entity_clang_ModuleMapDescriptor_setFrameworkModuleName>(EntityScope(m),
                                                               registry);
  auto v207 = pybind11_weaver::CreateEntity<
      Entity_clang_ModuleMapDescriptor_setUmbrellaHeader>(EntityScope(m),
                                                          registry);
  auto v208 = pybind11_weaver::CreateEntity<
      Entity_clang_ModuleMapDescriptor_writeToBuffer>(EntityScope(m), registry);
  auto v209 = pybind11_weaver::CreateEntity<Entity_clang_Module_getASTFile>(
      EntityScope(m), registry);
  auto v210 = pybind11_weaver::CreateEntity<Entity_clang_Module_getFullName>(
      EntityScope(m), registry);
  auto v211 = pybind11_weaver::CreateEntity<Entity_clang_Module_getName>(
      EntityScope(m), registry);
  auto v212 =
      pybind11_weaver::CreateEntity<Entity_clang_Module_getNumTopLevelHeaders>(
          EntityScope(m), registry);
  auto v213 = pybind11_weaver::CreateEntity<Entity_clang_Module_getParent>(
      EntityScope(m), registry);
  auto v214 =
      pybind11_weaver::CreateEntity<Entity_clang_Module_getTopLevelHeader>(
          EntityScope(m), registry);
  auto v215 = pybind11_weaver::CreateEntity<Entity_clang_Module_isSystem>(
      EntityScope(m), registry);
  auto v216 = pybind11_weaver::CreateEntity<
      Entity_clang_ParamCommandComment_getDirection>(EntityScope(m), registry);
  auto v217 = pybind11_weaver::CreateEntity<
      Entity_clang_ParamCommandComment_getParamIndex>(EntityScope(m), registry);
  auto v218 = pybind11_weaver::CreateEntity<
      Entity_clang_ParamCommandComment_getParamName>(EntityScope(m), registry);
  auto v219 = pybind11_weaver::CreateEntity<
      Entity_clang_ParamCommandComment_isDirectionExplicit>(EntityScope(m),
                                                            registry);
  auto v220 = pybind11_weaver::CreateEntity<
      Entity_clang_ParamCommandComment_isParamIndexValid>(EntityScope(m),
                                                          registry);
  auto v221 =
      pybind11_weaver::CreateEntity<Entity_clang_PrintingPolicy_dispose>(
          EntityScope(m), registry);
  auto v222 =
      pybind11_weaver::CreateEntity<Entity_clang_PrintingPolicy_getProperty>(
          EntityScope(m), registry);
  auto v223 =
      pybind11_weaver::CreateEntity<Entity_clang_PrintingPolicy_setProperty>(
          EntityScope(m), registry);
  auto v224 = pybind11_weaver::CreateEntity<Entity_clang_Range_isNull>(
      EntityScope(m), registry);
  auto v225 =
      pybind11_weaver::CreateEntity<Entity_clang_TParamCommandComment_getDepth>(
          EntityScope(m), registry);
  auto v226 =
      pybind11_weaver::CreateEntity<Entity_clang_TParamCommandComment_getIndex>(
          EntityScope(m), registry);
  auto v227 = pybind11_weaver::CreateEntity<
      Entity_clang_TParamCommandComment_getParamName>(EntityScope(m), registry);
  auto v228 = pybind11_weaver::CreateEntity<
      Entity_clang_TParamCommandComment_isParamPositionValid>(EntityScope(m),
                                                              registry);
  auto v229 = pybind11_weaver::CreateEntity<Entity_clang_TargetInfo_dispose>(
      EntityScope(m), registry);
  auto v230 =
      pybind11_weaver::CreateEntity<Entity_clang_TargetInfo_getPointerWidth>(
          EntityScope(m), registry);
  auto v231 = pybind11_weaver::CreateEntity<Entity_clang_TargetInfo_getTriple>(
      EntityScope(m), registry);
  auto v232 = pybind11_weaver::CreateEntity<Entity_clang_TextComment_getText>(
      EntityScope(m), registry);
  auto v233 = pybind11_weaver::CreateEntity<Entity_clang_Type_getAlignOf>(
      EntityScope(m), registry);
  auto v234 =
      pybind11_weaver::CreateEntity<Entity_clang_Type_getCXXRefQualifier>(
          EntityScope(m), registry);
  auto v235 = pybind11_weaver::CreateEntity<Entity_clang_Type_getClassType>(
      EntityScope(m), registry);
  auto v236 = pybind11_weaver::CreateEntity<Entity_clang_Type_getModifiedType>(
      EntityScope(m), registry);
  auto v237 = pybind11_weaver::CreateEntity<Entity_clang_Type_getNamedType>(
      EntityScope(m), registry);
  auto v238 = pybind11_weaver::CreateEntity<Entity_clang_Type_getNullability>(
      EntityScope(m), registry);
  auto v239 =
      pybind11_weaver::CreateEntity<Entity_clang_Type_getNumObjCProtocolRefs>(
          EntityScope(m), registry);
  auto v240 =
      pybind11_weaver::CreateEntity<Entity_clang_Type_getNumObjCTypeArgs>(
          EntityScope(m), registry);
  auto v241 =
      pybind11_weaver::CreateEntity<Entity_clang_Type_getNumTemplateArguments>(
          EntityScope(m), registry);
  auto v242 = pybind11_weaver::CreateEntity<Entity_clang_Type_getObjCEncoding>(
      EntityScope(m), registry);
  auto v243 =
      pybind11_weaver::CreateEntity<Entity_clang_Type_getObjCObjectBaseType>(
          EntityScope(m), registry);
  auto v244 =
      pybind11_weaver::CreateEntity<Entity_clang_Type_getObjCProtocolDecl>(
          EntityScope(m), registry);
  auto v245 = pybind11_weaver::CreateEntity<Entity_clang_Type_getObjCTypeArg>(
      EntityScope(m), registry);
  auto v246 = pybind11_weaver::CreateEntity<Entity_clang_Type_getOffsetOf>(
      EntityScope(m), registry);
  auto v247 = pybind11_weaver::CreateEntity<Entity_clang_Type_getSizeOf>(
      EntityScope(m), registry);
  auto v248 = pybind11_weaver::CreateEntity<
      Entity_clang_Type_getTemplateArgumentAsType>(EntityScope(m), registry);
  auto v249 = pybind11_weaver::CreateEntity<Entity_clang_Type_getValueType>(
      EntityScope(m), registry);
  auto v250 =
      pybind11_weaver::CreateEntity<Entity_clang_Type_isTransparentTagTypedef>(
          EntityScope(m), registry);
  auto v251 = pybind11_weaver::CreateEntity<Entity_clang_Type_visitFields>(
      EntityScope(m), registry);
  auto v252 = pybind11_weaver::CreateEntity<
      Entity_clang_VerbatimBlockLineComment_getText>(EntityScope(m), registry);
  auto v253 =
      pybind11_weaver::CreateEntity<Entity_clang_VerbatimLineComment_getText>(
          EntityScope(m), registry);
  auto v254 = pybind11_weaver::CreateEntity<
      Entity_clang_VirtualFileOverlay_addFileMapping>(EntityScope(m), registry);
  auto v255 =
      pybind11_weaver::CreateEntity<Entity_clang_VirtualFileOverlay_create>(
          EntityScope(m), registry);
  auto v256 =
      pybind11_weaver::CreateEntity<Entity_clang_VirtualFileOverlay_dispose>(
          EntityScope(m), registry);
  auto v257 = pybind11_weaver::CreateEntity<
      Entity_clang_VirtualFileOverlay_setCaseSensitivity>(EntityScope(m),
                                                          registry);
  auto v258 = pybind11_weaver::CreateEntity<
      Entity_clang_VirtualFileOverlay_writeToBuffer>(EntityScope(m), registry);
  auto v259 = pybind11_weaver::CreateEntity<Entity_clang_annotateTokens>(
      EntityScope(m), registry);
  auto v260 = pybind11_weaver::CreateEntity<Entity_clang_codeCompleteAt>(
      EntityScope(m), registry);
  auto v261 =
      pybind11_weaver::CreateEntity<Entity_clang_codeCompleteGetContainerKind>(
          EntityScope(m), registry);
  auto v262 =
      pybind11_weaver::CreateEntity<Entity_clang_codeCompleteGetContainerUSR>(
          EntityScope(m), registry);
  auto v263 =
      pybind11_weaver::CreateEntity<Entity_clang_codeCompleteGetContexts>(
          EntityScope(m), registry);
  auto v264 =
      pybind11_weaver::CreateEntity<Entity_clang_codeCompleteGetDiagnostic>(
          EntityScope(m), registry);
  auto v265 =
      pybind11_weaver::CreateEntity<Entity_clang_codeCompleteGetNumDiagnostics>(
          EntityScope(m), registry);
  auto v266 =
      pybind11_weaver::CreateEntity<Entity_clang_codeCompleteGetObjCSelector>(
          EntityScope(m), registry);
  auto v267 =
      pybind11_weaver::CreateEntity<Entity_clang_constructUSR_ObjCCategory>(
          EntityScope(m), registry);
  auto v268 =
      pybind11_weaver::CreateEntity<Entity_clang_constructUSR_ObjCClass>(
          EntityScope(m), registry);
  auto v269 = pybind11_weaver::CreateEntity<Entity_clang_constructUSR_ObjCIvar>(
      EntityScope(m), registry);
  auto v270 =
      pybind11_weaver::CreateEntity<Entity_clang_constructUSR_ObjCMethod>(
          EntityScope(m), registry);
  auto v271 =
      pybind11_weaver::CreateEntity<Entity_clang_constructUSR_ObjCProperty>(
          EntityScope(m), registry);
  auto v272 =
      pybind11_weaver::CreateEntity<Entity_clang_constructUSR_ObjCProtocol>(
          EntityScope(m), registry);
  auto v273 = pybind11_weaver::CreateEntity<Entity_clang_createAPISet>(
      EntityScope(m), registry);
  auto v274 = pybind11_weaver::CreateEntity<Entity_clang_createCXCursorSet>(
      EntityScope(m), registry);
  auto v275 = pybind11_weaver::CreateEntity<Entity_clang_createIndex>(
      EntityScope(m), registry);
  auto v276 = pybind11_weaver::CreateEntity<Entity_clang_createTranslationUnit>(
      EntityScope(m), registry);
  auto v277 =
      pybind11_weaver::CreateEntity<Entity_clang_createTranslationUnit2>(
          EntityScope(m), registry);
  auto v278 = pybind11_weaver::CreateEntity<
      Entity_clang_createTranslationUnitFromSourceFile>(EntityScope(m),
                                                        registry);
  auto v279 =
      pybind11_weaver::CreateEntity<Entity_clang_defaultCodeCompleteOptions>(
          EntityScope(m), registry);
  auto v280 = pybind11_weaver::CreateEntity<
      Entity_clang_defaultDiagnosticDisplayOptions>(EntityScope(m), registry);
  auto v281 = pybind11_weaver::CreateEntity<
      Entity_clang_defaultEditingTranslationUnitOptions>(EntityScope(m),
                                                         registry);
  auto v282 = pybind11_weaver::CreateEntity<Entity_clang_defaultReparseOptions>(
      EntityScope(m), registry);
  auto v283 = pybind11_weaver::CreateEntity<Entity_clang_defaultSaveOptions>(
      EntityScope(m), registry);
  auto v284 = pybind11_weaver::CreateEntity<Entity_clang_disposeAPISet>(
      EntityScope(m), registry);
  auto v285 = pybind11_weaver::CreateEntity<Entity_clang_disposeCXCursorSet>(
      EntityScope(m), registry);
  auto v286 =
      pybind11_weaver::CreateEntity<Entity_clang_disposeCXPlatformAvailability>(
          EntityScope(m), registry);
  auto v287 =
      pybind11_weaver::CreateEntity<Entity_clang_disposeCXTUResourceUsage>(
          EntityScope(m), registry);
  auto v288 =
      pybind11_weaver::CreateEntity<Entity_clang_disposeCodeCompleteResults>(
          EntityScope(m), registry);
  auto v289 = pybind11_weaver::CreateEntity<Entity_clang_disposeDiagnostic>(
      EntityScope(m), registry);
  auto v290 = pybind11_weaver::CreateEntity<Entity_clang_disposeDiagnosticSet>(
      EntityScope(m), registry);
  auto v291 = pybind11_weaver::CreateEntity<Entity_clang_disposeIndex>(
      EntityScope(m), registry);
  auto v292 =
      pybind11_weaver::CreateEntity<Entity_clang_disposeOverriddenCursors>(
          EntityScope(m), registry);
  auto v293 =
      pybind11_weaver::CreateEntity<Entity_clang_disposeSourceRangeList>(
          EntityScope(m), registry);
  auto v294 = pybind11_weaver::CreateEntity<Entity_clang_disposeString>(
      EntityScope(m), registry);
  auto v295 = pybind11_weaver::CreateEntity<Entity_clang_disposeStringSet>(
      EntityScope(m), registry);
  auto v296 = pybind11_weaver::CreateEntity<Entity_clang_disposeTokens>(
      EntityScope(m), registry);
  auto v297 =
      pybind11_weaver::CreateEntity<Entity_clang_disposeTranslationUnit>(
          EntityScope(m), registry);
  auto v298 = pybind11_weaver::CreateEntity<Entity_clang_enableStackTraces>(
      EntityScope(m), registry);
  auto v299 = pybind11_weaver::CreateEntity<Entity_clang_equalCursors>(
      EntityScope(m), registry);
  auto v300 = pybind11_weaver::CreateEntity<Entity_clang_equalLocations>(
      EntityScope(m), registry);
  auto v301 = pybind11_weaver::CreateEntity<Entity_clang_equalRanges>(
      EntityScope(m), registry);
  auto v302 = pybind11_weaver::CreateEntity<Entity_clang_equalTypes>(
      EntityScope(m), registry);
  auto v303 = pybind11_weaver::CreateEntity<Entity_clang_executeOnThread>(
      EntityScope(m), registry);
  auto v304 = pybind11_weaver::CreateEntity<Entity_clang_findIncludesInFile>(
      EntityScope(m), registry);
  auto v305 = pybind11_weaver::CreateEntity<Entity_clang_findReferencesInFile>(
      EntityScope(m), registry);
  auto v306 = pybind11_weaver::CreateEntity<Entity_clang_formatDiagnostic>(
      EntityScope(m), registry);
  auto v307 = pybind11_weaver::CreateEntity<Entity_clang_free>(EntityScope(m),
                                                               registry);
  auto v308 = pybind11_weaver::CreateEntity<Entity_clang_getAddressSpace>(
      EntityScope(m), registry);
  auto v309 = pybind11_weaver::CreateEntity<Entity_clang_getAllSkippedRanges>(
      EntityScope(m), registry);
  auto v310 = pybind11_weaver::CreateEntity<Entity_clang_getArgType>(
      EntityScope(m), registry);
  auto v311 = pybind11_weaver::CreateEntity<Entity_clang_getArrayElementType>(
      EntityScope(m), registry);
  auto v312 = pybind11_weaver::CreateEntity<Entity_clang_getArraySize>(
      EntityScope(m), registry);
  auto v313 =
      pybind11_weaver::CreateEntity<Entity_clang_getBuildSessionTimestamp>(
          EntityScope(m), registry);
  auto v314 = pybind11_weaver::CreateEntity<Entity_clang_getCString>(
      EntityScope(m), registry);
  auto v315 = pybind11_weaver::CreateEntity<Entity_clang_getCXTUResourceUsage>(
      EntityScope(m), registry);
  auto v316 = pybind11_weaver::CreateEntity<Entity_clang_getCXXAccessSpecifier>(
      EntityScope(m), registry);
  auto v317 = pybind11_weaver::CreateEntity<Entity_clang_getCanonicalCursor>(
      EntityScope(m), registry);
  auto v318 = pybind11_weaver::CreateEntity<Entity_clang_getCanonicalType>(
      EntityScope(m), registry);
  auto v319 = pybind11_weaver::CreateEntity<Entity_clang_getChildDiagnostics>(
      EntityScope(m), registry);
  auto v320 = pybind11_weaver::CreateEntity<Entity_clang_getClangVersion>(
      EntityScope(m), registry);
  auto v321 =
      pybind11_weaver::CreateEntity<Entity_clang_getCompletionAnnotation>(
          EntityScope(m), registry);
  auto v322 =
      pybind11_weaver::CreateEntity<Entity_clang_getCompletionAvailability>(
          EntityScope(m), registry);
  auto v323 =
      pybind11_weaver::CreateEntity<Entity_clang_getCompletionBriefComment>(
          EntityScope(m), registry);
  auto v324 = pybind11_weaver::CreateEntity<
      Entity_clang_getCompletionChunkCompletionString>(EntityScope(m),
                                                       registry);
  auto v325 =
      pybind11_weaver::CreateEntity<Entity_clang_getCompletionChunkKind>(
          EntityScope(m), registry);
  auto v326 =
      pybind11_weaver::CreateEntity<Entity_clang_getCompletionChunkText>(
          EntityScope(m), registry);
  auto v327 = pybind11_weaver::CreateEntity<Entity_clang_getCompletionFixIt>(
      EntityScope(m), registry);
  auto v328 =
      pybind11_weaver::CreateEntity<Entity_clang_getCompletionNumAnnotations>(
          EntityScope(m), registry);
  auto v329 =
      pybind11_weaver::CreateEntity<Entity_clang_getCompletionNumFixIts>(
          EntityScope(m), registry);
  auto v330 = pybind11_weaver::CreateEntity<Entity_clang_getCompletionParent>(
      EntityScope(m), registry);
  auto v331 = pybind11_weaver::CreateEntity<Entity_clang_getCompletionPriority>(
      EntityScope(m), registry);
  auto v332 = pybind11_weaver::CreateEntity<Entity_clang_getCursor>(
      EntityScope(m), registry);
  auto v333 = pybind11_weaver::CreateEntity<Entity_clang_getCursorAvailability>(
      EntityScope(m), registry);
  auto v334 =
      pybind11_weaver::CreateEntity<Entity_clang_getCursorCompletionString>(
          EntityScope(m), registry);
  auto v335 = pybind11_weaver::CreateEntity<Entity_clang_getCursorDefinition>(
      EntityScope(m), registry);
  auto v336 = pybind11_weaver::CreateEntity<Entity_clang_getCursorDisplayName>(
      EntityScope(m), registry);
  auto v337 = pybind11_weaver::CreateEntity<
      Entity_clang_getCursorExceptionSpecificationType>(EntityScope(m),
                                                        registry);
  auto v338 = pybind11_weaver::CreateEntity<Entity_clang_getCursorExtent>(
      EntityScope(m), registry);
  auto v339 = pybind11_weaver::CreateEntity<Entity_clang_getCursorKind>(
      EntityScope(m), registry);
  auto v340 = pybind11_weaver::CreateEntity<Entity_clang_getCursorKindSpelling>(
      EntityScope(m), registry);
  auto v341 = pybind11_weaver::CreateEntity<Entity_clang_getCursorLanguage>(
      EntityScope(m), registry);
  auto v342 =
      pybind11_weaver::CreateEntity<Entity_clang_getCursorLexicalParent>(
          EntityScope(m), registry);
  auto v343 = pybind11_weaver::CreateEntity<Entity_clang_getCursorLinkage>(
      EntityScope(m), registry);
  auto v344 = pybind11_weaver::CreateEntity<Entity_clang_getCursorLocation>(
      EntityScope(m), registry);
  auto v345 =
      pybind11_weaver::CreateEntity<Entity_clang_getCursorPlatformAvailability>(
          EntityScope(m), registry);
  auto v346 =
      pybind11_weaver::CreateEntity<Entity_clang_getCursorPrettyPrinted>(
          EntityScope(m), registry);
  auto v347 =
      pybind11_weaver::CreateEntity<Entity_clang_getCursorPrintingPolicy>(
          EntityScope(m), registry);
  auto v348 =
      pybind11_weaver::CreateEntity<Entity_clang_getCursorReferenceNameRange>(
          EntityScope(m), registry);
  auto v349 = pybind11_weaver::CreateEntity<Entity_clang_getCursorReferenced>(
      EntityScope(m), registry);
  auto v350 = pybind11_weaver::CreateEntity<Entity_clang_getCursorResultType>(
      EntityScope(m), registry);
  auto v351 =
      pybind11_weaver::CreateEntity<Entity_clang_getCursorSemanticParent>(
          EntityScope(m), registry);
  auto v352 = pybind11_weaver::CreateEntity<Entity_clang_getCursorSpelling>(
      EntityScope(m), registry);
  auto v353 = pybind11_weaver::CreateEntity<Entity_clang_getCursorTLSKind>(
      EntityScope(m), registry);
  auto v354 = pybind11_weaver::CreateEntity<Entity_clang_getCursorType>(
      EntityScope(m), registry);
  auto v355 = pybind11_weaver::CreateEntity<Entity_clang_getCursorUSR>(
      EntityScope(m), registry);
  auto v356 = pybind11_weaver::CreateEntity<Entity_clang_getCursorVisibility>(
      EntityScope(m), registry);
  auto v357 =
      pybind11_weaver::CreateEntity<Entity_clang_getDeclObjCTypeEncoding>(
          EntityScope(m), registry);
  auto v358 = pybind11_weaver::CreateEntity<
      Entity_clang_getDefinitionSpellingAndExtent>(EntityScope(m), registry);
  auto v359 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnostic>(
      EntityScope(m), registry);
  auto v360 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticCategory>(
      EntityScope(m), registry);
  auto v361 =
      pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticCategoryName>(
          EntityScope(m), registry);
  auto v362 =
      pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticCategoryText>(
          EntityScope(m), registry);
  auto v363 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticFixIt>(
      EntityScope(m), registry);
  auto v364 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticInSet>(
      EntityScope(m), registry);
  auto v365 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticLocation>(
      EntityScope(m), registry);
  auto v366 =
      pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticNumFixIts>(
          EntityScope(m), registry);
  auto v367 =
      pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticNumRanges>(
          EntityScope(m), registry);
  auto v368 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticOption>(
      EntityScope(m), registry);
  auto v369 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticRange>(
      EntityScope(m), registry);
  auto v370 =
      pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticSetFromTU>(
          EntityScope(m), registry);
  auto v371 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticSeverity>(
      EntityScope(m), registry);
  auto v372 = pybind11_weaver::CreateEntity<Entity_clang_getDiagnosticSpelling>(
      EntityScope(m), registry);
  auto v373 = pybind11_weaver::CreateEntity<Entity_clang_getElementType>(
      EntityScope(m), registry);
  auto v374 = pybind11_weaver::CreateEntity<
      Entity_clang_getEnumConstantDeclUnsignedValue>(EntityScope(m), registry);
  auto v375 =
      pybind11_weaver::CreateEntity<Entity_clang_getEnumConstantDeclValue>(
          EntityScope(m), registry);
  auto v376 =
      pybind11_weaver::CreateEntity<Entity_clang_getEnumDeclIntegerType>(
          EntityScope(m), registry);
  auto v377 =
      pybind11_weaver::CreateEntity<Entity_clang_getExceptionSpecificationType>(
          EntityScope(m), registry);
  auto v378 = pybind11_weaver::CreateEntity<Entity_clang_getExpansionLocation>(
      EntityScope(m), registry);
  auto v379 = pybind11_weaver::CreateEntity<Entity_clang_getFieldDeclBitWidth>(
      EntityScope(m), registry);
  auto v380 = pybind11_weaver::CreateEntity<Entity_clang_getFile>(
      EntityScope(m), registry);
  auto v381 = pybind11_weaver::CreateEntity<Entity_clang_getFileContents>(
      EntityScope(m), registry);
  auto v382 = pybind11_weaver::CreateEntity<Entity_clang_getFileLocation>(
      EntityScope(m), registry);
  auto v383 = pybind11_weaver::CreateEntity<Entity_clang_getFileName>(
      EntityScope(m), registry);
  auto v384 = pybind11_weaver::CreateEntity<Entity_clang_getFileTime>(
      EntityScope(m), registry);
  auto v385 = pybind11_weaver::CreateEntity<Entity_clang_getFileUniqueID>(
      EntityScope(m), registry);
  auto v386 =
      pybind11_weaver::CreateEntity<Entity_clang_getFunctionTypeCallingConv>(
          EntityScope(m), registry);
  auto v387 =
      pybind11_weaver::CreateEntity<Entity_clang_getIBOutletCollectionType>(
          EntityScope(m), registry);
  auto v388 = pybind11_weaver::CreateEntity<Entity_clang_getIncludedFile>(
      EntityScope(m), registry);
  auto v389 = pybind11_weaver::CreateEntity<Entity_clang_getInclusions>(
      EntityScope(m), registry);
  auto v390 =
      pybind11_weaver::CreateEntity<Entity_clang_getInstantiationLocation>(
          EntityScope(m), registry);
  auto v391 = pybind11_weaver::CreateEntity<Entity_clang_getLocation>(
      EntityScope(m), registry);
  auto v392 = pybind11_weaver::CreateEntity<Entity_clang_getLocationForOffset>(
      EntityScope(m), registry);
  auto v393 = pybind11_weaver::CreateEntity<Entity_clang_getModuleForFile>(
      EntityScope(m), registry);
  auto v394 = pybind11_weaver::CreateEntity<Entity_clang_getNonReferenceType>(
      EntityScope(m), registry);
  auto v395 = pybind11_weaver::CreateEntity<Entity_clang_getNullCursor>(
      EntityScope(m), registry);
  auto v396 = pybind11_weaver::CreateEntity<Entity_clang_getNullLocation>(
      EntityScope(m), registry);
  auto v397 = pybind11_weaver::CreateEntity<Entity_clang_getNullRange>(
      EntityScope(m), registry);
  auto v398 = pybind11_weaver::CreateEntity<Entity_clang_getNumArgTypes>(
      EntityScope(m), registry);
  auto v399 =
      pybind11_weaver::CreateEntity<Entity_clang_getNumCompletionChunks>(
          EntityScope(m), registry);
  auto v400 = pybind11_weaver::CreateEntity<Entity_clang_getNumDiagnostics>(
      EntityScope(m), registry);
  auto v401 =
      pybind11_weaver::CreateEntity<Entity_clang_getNumDiagnosticsInSet>(
          EntityScope(m), registry);
  auto v402 = pybind11_weaver::CreateEntity<Entity_clang_getNumElements>(
      EntityScope(m), registry);
  auto v403 = pybind11_weaver::CreateEntity<Entity_clang_getNumOverloadedDecls>(
      EntityScope(m), registry);
  auto v404 = pybind11_weaver::CreateEntity<Entity_clang_getOverloadedDecl>(
      EntityScope(m), registry);
  auto v405 = pybind11_weaver::CreateEntity<Entity_clang_getOverriddenCursors>(
      EntityScope(m), registry);
  auto v406 = pybind11_weaver::CreateEntity<Entity_clang_getPointeeType>(
      EntityScope(m), registry);
  auto v407 = pybind11_weaver::CreateEntity<Entity_clang_getPresumedLocation>(
      EntityScope(m), registry);
  auto v408 = pybind11_weaver::CreateEntity<Entity_clang_getRange>(
      EntityScope(m), registry);
  auto v409 = pybind11_weaver::CreateEntity<Entity_clang_getRangeEnd>(
      EntityScope(m), registry);
  auto v410 = pybind11_weaver::CreateEntity<Entity_clang_getRangeStart>(
      EntityScope(m), registry);
  auto v411 = pybind11_weaver::CreateEntity<Entity_clang_getRemappings>(
      EntityScope(m), registry);
  auto v412 =
      pybind11_weaver::CreateEntity<Entity_clang_getRemappingsFromFileList>(
          EntityScope(m), registry);
  auto v413 = pybind11_weaver::CreateEntity<Entity_clang_getResultType>(
      EntityScope(m), registry);
  auto v414 = pybind11_weaver::CreateEntity<Entity_clang_getSkippedRanges>(
      EntityScope(m), registry);
  auto v415 =
      pybind11_weaver::CreateEntity<Entity_clang_getSpecializedCursorTemplate>(
          EntityScope(m), registry);
  auto v416 = pybind11_weaver::CreateEntity<Entity_clang_getSpellingLocation>(
      EntityScope(m), registry);
  auto v417 =
      pybind11_weaver::CreateEntity<Entity_clang_getSymbolGraphForCursor>(
          EntityScope(m), registry);
  auto v418 = pybind11_weaver::CreateEntity<Entity_clang_getSymbolGraphForUSR>(
      EntityScope(m), registry);
  auto v419 =
      pybind11_weaver::CreateEntity<Entity_clang_getTUResourceUsageName>(
          EntityScope(m), registry);
  auto v420 = pybind11_weaver::CreateEntity<Entity_clang_getTemplateCursorKind>(
      EntityScope(m), registry);
  auto v421 = pybind11_weaver::CreateEntity<Entity_clang_getToken>(
      EntityScope(m), registry);
  auto v422 = pybind11_weaver::CreateEntity<Entity_clang_getTokenExtent>(
      EntityScope(m), registry);
  auto v423 = pybind11_weaver::CreateEntity<Entity_clang_getTokenKind>(
      EntityScope(m), registry);
  auto v424 = pybind11_weaver::CreateEntity<Entity_clang_getTokenLocation>(
      EntityScope(m), registry);
  auto v425 = pybind11_weaver::CreateEntity<Entity_clang_getTokenSpelling>(
      EntityScope(m), registry);
  auto v426 =
      pybind11_weaver::CreateEntity<Entity_clang_getTranslationUnitCursor>(
          EntityScope(m), registry);
  auto v427 =
      pybind11_weaver::CreateEntity<Entity_clang_getTranslationUnitSpelling>(
          EntityScope(m), registry);
  auto v428 =
      pybind11_weaver::CreateEntity<Entity_clang_getTranslationUnitTargetInfo>(
          EntityScope(m), registry);
  auto v429 = pybind11_weaver::CreateEntity<Entity_clang_getTypeDeclaration>(
      EntityScope(m), registry);
  auto v430 = pybind11_weaver::CreateEntity<Entity_clang_getTypeKindSpelling>(
      EntityScope(m), registry);
  auto v431 = pybind11_weaver::CreateEntity<Entity_clang_getTypeSpelling>(
      EntityScope(m), registry);
  auto v432 =
      pybind11_weaver::CreateEntity<Entity_clang_getTypedefDeclUnderlyingType>(
          EntityScope(m), registry);
  auto v433 = pybind11_weaver::CreateEntity<Entity_clang_getTypedefName>(
      EntityScope(m), registry);
  auto v434 = pybind11_weaver::CreateEntity<Entity_clang_getUnqualifiedType>(
      EntityScope(m), registry);
  auto v435 = pybind11_weaver::CreateEntity<Entity_clang_hashCursor>(
      EntityScope(m), registry);
  auto v436 =
      pybind11_weaver::CreateEntity<Entity_clang_indexLoc_getCXSourceLocation>(
          EntityScope(m), registry);
  auto v437 =
      pybind11_weaver::CreateEntity<Entity_clang_indexLoc_getFileLocation>(
          EntityScope(m), registry);
  auto v438 = pybind11_weaver::CreateEntity<Entity_clang_indexSourceFile>(
      EntityScope(m), registry);
  auto v439 =
      pybind11_weaver::CreateEntity<Entity_clang_indexSourceFileFullArgv>(
          EntityScope(m), registry);
  auto v440 = pybind11_weaver::CreateEntity<Entity_clang_indexTranslationUnit>(
      EntityScope(m), registry);
  auto v441 =
      pybind11_weaver::CreateEntity<Entity_clang_index_getCXXClassDeclInfo>(
          EntityScope(m), registry);
  auto v442 =
      pybind11_weaver::CreateEntity<Entity_clang_index_getClientContainer>(
          EntityScope(m), registry);
  auto v443 = pybind11_weaver::CreateEntity<Entity_clang_index_getClientEntity>(
      EntityScope(m), registry);
  auto v444 = pybind11_weaver::CreateEntity<
      Entity_clang_index_getIBOutletCollectionAttrInfo>(EntityScope(m),
                                                        registry);
  auto v445 =
      pybind11_weaver::CreateEntity<Entity_clang_index_getObjCCategoryDeclInfo>(
          EntityScope(m), registry);
  auto v446 = pybind11_weaver::CreateEntity<
      Entity_clang_index_getObjCContainerDeclInfo>(EntityScope(m), registry);
  auto v447 = pybind11_weaver::CreateEntity<
      Entity_clang_index_getObjCInterfaceDeclInfo>(EntityScope(m), registry);
  auto v448 =
      pybind11_weaver::CreateEntity<Entity_clang_index_getObjCPropertyDeclInfo>(
          EntityScope(m), registry);
  auto v449 = pybind11_weaver::CreateEntity<
      Entity_clang_index_getObjCProtocolRefListInfo>(EntityScope(m), registry);
  auto v450 = pybind11_weaver::CreateEntity<
      Entity_clang_index_isEntityObjCContainerKind>(EntityScope(m), registry);
  auto v451 =
      pybind11_weaver::CreateEntity<Entity_clang_index_setClientContainer>(
          EntityScope(m), registry);
  auto v452 = pybind11_weaver::CreateEntity<Entity_clang_index_setClientEntity>(
      EntityScope(m), registry);
  auto v453 = pybind11_weaver::CreateEntity<
      Entity_clang_install_aborting_llvm_fatal_error_handler>(EntityScope(m),
                                                              registry);
  auto v454 = pybind11_weaver::CreateEntity<Entity_clang_isAttribute>(
      EntityScope(m), registry);
  auto v455 = pybind11_weaver::CreateEntity<Entity_clang_isConstQualifiedType>(
      EntityScope(m), registry);
  auto v456 = pybind11_weaver::CreateEntity<Entity_clang_isCursorDefinition>(
      EntityScope(m), registry);
  auto v457 = pybind11_weaver::CreateEntity<Entity_clang_isDeclaration>(
      EntityScope(m), registry);
  auto v458 = pybind11_weaver::CreateEntity<Entity_clang_isExpression>(
      EntityScope(m), registry);
  auto v459 =
      pybind11_weaver::CreateEntity<Entity_clang_isFileMultipleIncludeGuarded>(
          EntityScope(m), registry);
  auto v460 =
      pybind11_weaver::CreateEntity<Entity_clang_isFunctionTypeVariadic>(
          EntityScope(m), registry);
  auto v461 = pybind11_weaver::CreateEntity<Entity_clang_isInvalid>(
      EntityScope(m), registry);
  auto v462 = pybind11_weaver::CreateEntity<Entity_clang_isInvalidDeclaration>(
      EntityScope(m), registry);
  auto v463 = pybind11_weaver::CreateEntity<Entity_clang_isPODType>(
      EntityScope(m), registry);
  auto v464 = pybind11_weaver::CreateEntity<Entity_clang_isPreprocessing>(
      EntityScope(m), registry);
  auto v465 = pybind11_weaver::CreateEntity<Entity_clang_isReference>(
      EntityScope(m), registry);
  auto v466 =
      pybind11_weaver::CreateEntity<Entity_clang_isRestrictQualifiedType>(
          EntityScope(m), registry);
  auto v467 = pybind11_weaver::CreateEntity<Entity_clang_isStatement>(
      EntityScope(m), registry);
  auto v468 = pybind11_weaver::CreateEntity<Entity_clang_isTranslationUnit>(
      EntityScope(m), registry);
  auto v469 = pybind11_weaver::CreateEntity<Entity_clang_isUnexposed>(
      EntityScope(m), registry);
  auto v470 = pybind11_weaver::CreateEntity<Entity_clang_isVirtualBase>(
      EntityScope(m), registry);
  auto v471 =
      pybind11_weaver::CreateEntity<Entity_clang_isVolatileQualifiedType>(
          EntityScope(m), registry);
  auto v472 = pybind11_weaver::CreateEntity<Entity_clang_loadDiagnostics>(
      EntityScope(m), registry);
  auto v473 = pybind11_weaver::CreateEntity<Entity_clang_parseTranslationUnit>(
      EntityScope(m), registry);
  auto v474 = pybind11_weaver::CreateEntity<Entity_clang_parseTranslationUnit2>(
      EntityScope(m), registry);
  auto v475 =
      pybind11_weaver::CreateEntity<Entity_clang_parseTranslationUnit2FullArgv>(
          EntityScope(m), registry);
  auto v476 = pybind11_weaver::CreateEntity<Entity_clang_remap_dispose>(
      EntityScope(m), registry);
  auto v477 = pybind11_weaver::CreateEntity<Entity_clang_remap_getFilenames>(
      EntityScope(m), registry);
  auto v478 = pybind11_weaver::CreateEntity<Entity_clang_remap_getNumFiles>(
      EntityScope(m), registry);
  auto v479 =
      pybind11_weaver::CreateEntity<Entity_clang_reparseTranslationUnit>(
          EntityScope(m), registry);
  auto v480 = pybind11_weaver::CreateEntity<Entity_clang_saveTranslationUnit>(
      EntityScope(m), registry);
  auto v481 =
      pybind11_weaver::CreateEntity<Entity_clang_sortCodeCompletionResults>(
          EntityScope(m), registry);
  auto v482 =
      pybind11_weaver::CreateEntity<Entity_clang_suspendTranslationUnit>(
          EntityScope(m), registry);
  auto v483 = pybind11_weaver::CreateEntity<Entity_clang_toggleCrashRecovery>(
      EntityScope(m), registry);
  auto v484 = pybind11_weaver::CreateEntity<Entity_clang_tokenize>(
      EntityScope(m), registry);
  auto v485 = pybind11_weaver::CreateEntity<
      Entity_clang_uninstall_llvm_fatal_error_handler>(EntityScope(m),
                                                       registry);
  auto v486 = pybind11_weaver::CreateEntity<Entity_clang_visitChildren>(
      EntityScope(m), registry);

  auto update_fn = [=]() {
    v0->Update();
    v1->Update();
    v2->Update();
    v3->Update();
    v4->Update();
    v5->Update();
    v6->Update();
    v7->Update();
    v8->Update();
    v9->Update();
    v10->Update();
    v11->Update();
    v12->Update();
    v13->Update();
    v14->Update();
    v15->Update();
    v16->Update();
    v17->Update();
    v18->Update();
    v19->Update();
    v20->Update();
    v21->Update();
    v22->Update();
    v23->Update();
    v24->Update();
    v25->Update();
    v26->Update();
    v27->Update();
    v28->Update();
    v29->Update();
    v30->Update();
    v31->Update();
    v32->Update();
    v33->Update();
    v34->Update();
    v35->Update();
    v36->Update();
    v37->Update();
    v38->Update();
    v39->Update();
    v40->Update();
    v41->Update();
    v42->Update();
    v43->Update();
    v44->Update();
    v45->Update();
    v46->Update();
    v47->Update();
    v48->Update();
    v49->Update();
    v50->Update();
    v51->Update();
    v52->Update();
    v53->Update();
    v54->Update();
    v55->Update();
    v56->Update();
    v57->Update();
    v58->Update();
    v59->Update();
    v60->Update();
    v61->Update();
    v62->Update();
    v63->Update();
    v64->Update();
    v65->Update();
    v66->Update();
    v67->Update();
    v68->Update();
    v69->Update();
    v70->Update();
    v71->Update();
    v72->Update();
    v73->Update();
    v74->Update();
    v75->Update();
    v76->Update();
    v77->Update();
    v78->Update();
    v79->Update();
    v80->Update();
    v81->Update();
    v82->Update();
    v83->Update();
    v84->Update();
    v85->Update();
    v86->Update();
    v87->Update();
    v88->Update();
    v89->Update();
    v90->Update();
    v91->Update();
    v92->Update();
    v93->Update();
    v94->Update();
    v95->Update();
    v96->Update();
    v97->Update();
    v98->Update();
    v99->Update();
    v100->Update();
    v101->Update();
    v102->Update();
    v103->Update();
    v104->Update();
    v105->Update();
    v106->Update();
    v107->Update();
    v108->Update();
    v109->Update();
    v110->Update();
    v111->Update();
    v112->Update();
    v113->Update();
    v114->Update();
    v115->Update();
    v116->Update();
    v117->Update();
    v118->Update();
    v119->Update();
    v120->Update();
    v121->Update();
    v122->Update();
    v123->Update();
    v124->Update();
    v125->Update();
    v126->Update();
    v127->Update();
    v128->Update();
    v129->Update();
    v130->Update();
    v131->Update();
    v132->Update();
    v133->Update();
    v134->Update();
    v135->Update();
    v136->Update();
    v137->Update();
    v138->Update();
    v139->Update();
    v140->Update();
    v141->Update();
    v142->Update();
    v143->Update();
    v144->Update();
    v145->Update();
    v146->Update();
    v147->Update();
    v148->Update();
    v149->Update();
    v150->Update();
    v151->Update();
    v152->Update();
    v153->Update();
    v154->Update();
    v155->Update();
    v156->Update();
    v157->Update();
    v158->Update();
    v159->Update();
    v160->Update();
    v161->Update();
    v162->Update();
    v163->Update();
    v164->Update();
    v165->Update();
    v166->Update();
    v167->Update();
    v168->Update();
    v169->Update();
    v170->Update();
    v171->Update();
    v172->Update();
    v173->Update();
    v174->Update();
    v175->Update();
    v176->Update();
    v177->Update();
    v178->Update();
    v179->Update();
    v180->Update();
    v181->Update();
    v182->Update();
    v183->Update();
    v184->Update();
    v185->Update();
    v186->Update();
    v187->Update();
    v188->Update();
    v189->Update();
    v190->Update();
    v191->Update();
    v192->Update();
    v193->Update();
    v194->Update();
    v195->Update();
    v196->Update();
    v197->Update();
    v198->Update();
    v199->Update();
    v200->Update();
    v201->Update();
    v202->Update();
    v203->Update();
    v204->Update();
    v205->Update();
    v206->Update();
    v207->Update();
    v208->Update();
    v209->Update();
    v210->Update();
    v211->Update();
    v212->Update();
    v213->Update();
    v214->Update();
    v215->Update();
    v216->Update();
    v217->Update();
    v218->Update();
    v219->Update();
    v220->Update();
    v221->Update();
    v222->Update();
    v223->Update();
    v224->Update();
    v225->Update();
    v226->Update();
    v227->Update();
    v228->Update();
    v229->Update();
    v230->Update();
    v231->Update();
    v232->Update();
    v233->Update();
    v234->Update();
    v235->Update();
    v236->Update();
    v237->Update();
    v238->Update();
    v239->Update();
    v240->Update();
    v241->Update();
    v242->Update();
    v243->Update();
    v244->Update();
    v245->Update();
    v246->Update();
    v247->Update();
    v248->Update();
    v249->Update();
    v250->Update();
    v251->Update();
    v252->Update();
    v253->Update();
    v254->Update();
    v255->Update();
    v256->Update();
    v257->Update();
    v258->Update();
    v259->Update();
    v260->Update();
    v261->Update();
    v262->Update();
    v263->Update();
    v264->Update();
    v265->Update();
    v266->Update();
    v267->Update();
    v268->Update();
    v269->Update();
    v270->Update();
    v271->Update();
    v272->Update();
    v273->Update();
    v274->Update();
    v275->Update();
    v276->Update();
    v277->Update();
    v278->Update();
    v279->Update();
    v280->Update();
    v281->Update();
    v282->Update();
    v283->Update();
    v284->Update();
    v285->Update();
    v286->Update();
    v287->Update();
    v288->Update();
    v289->Update();
    v290->Update();
    v291->Update();
    v292->Update();
    v293->Update();
    v294->Update();
    v295->Update();
    v296->Update();
    v297->Update();
    v298->Update();
    v299->Update();
    v300->Update();
    v301->Update();
    v302->Update();
    v303->Update();
    v304->Update();
    v305->Update();
    v306->Update();
    v307->Update();
    v308->Update();
    v309->Update();
    v310->Update();
    v311->Update();
    v312->Update();
    v313->Update();
    v314->Update();
    v315->Update();
    v316->Update();
    v317->Update();
    v318->Update();
    v319->Update();
    v320->Update();
    v321->Update();
    v322->Update();
    v323->Update();
    v324->Update();
    v325->Update();
    v326->Update();
    v327->Update();
    v328->Update();
    v329->Update();
    v330->Update();
    v331->Update();
    v332->Update();
    v333->Update();
    v334->Update();
    v335->Update();
    v336->Update();
    v337->Update();
    v338->Update();
    v339->Update();
    v340->Update();
    v341->Update();
    v342->Update();
    v343->Update();
    v344->Update();
    v345->Update();
    v346->Update();
    v347->Update();
    v348->Update();
    v349->Update();
    v350->Update();
    v351->Update();
    v352->Update();
    v353->Update();
    v354->Update();
    v355->Update();
    v356->Update();
    v357->Update();
    v358->Update();
    v359->Update();
    v360->Update();
    v361->Update();
    v362->Update();
    v363->Update();
    v364->Update();
    v365->Update();
    v366->Update();
    v367->Update();
    v368->Update();
    v369->Update();
    v370->Update();
    v371->Update();
    v372->Update();
    v373->Update();
    v374->Update();
    v375->Update();
    v376->Update();
    v377->Update();
    v378->Update();
    v379->Update();
    v380->Update();
    v381->Update();
    v382->Update();
    v383->Update();
    v384->Update();
    v385->Update();
    v386->Update();
    v387->Update();
    v388->Update();
    v389->Update();
    v390->Update();
    v391->Update();
    v392->Update();
    v393->Update();
    v394->Update();
    v395->Update();
    v396->Update();
    v397->Update();
    v398->Update();
    v399->Update();
    v400->Update();
    v401->Update();
    v402->Update();
    v403->Update();
    v404->Update();
    v405->Update();
    v406->Update();
    v407->Update();
    v408->Update();
    v409->Update();
    v410->Update();
    v411->Update();
    v412->Update();
    v413->Update();
    v414->Update();
    v415->Update();
    v416->Update();
    v417->Update();
    v418->Update();
    v419->Update();
    v420->Update();
    v421->Update();
    v422->Update();
    v423->Update();
    v424->Update();
    v425->Update();
    v426->Update();
    v427->Update();
    v428->Update();
    v429->Update();
    v430->Update();
    v431->Update();
    v432->Update();
    v433->Update();
    v434->Update();
    v435->Update();
    v436->Update();
    v437->Update();
    v438->Update();
    v439->Update();
    v440->Update();
    v441->Update();
    v442->Update();
    v443->Update();
    v444->Update();
    v445->Update();
    v446->Update();
    v447->Update();
    v448->Update();
    v449->Update();
    v450->Update();
    v451->Update();
    v452->Update();
    v453->Update();
    v454->Update();
    v455->Update();
    v456->Update();
    v457->Update();
    v458->Update();
    v459->Update();
    v460->Update();
    v461->Update();
    v462->Update();
    v463->Update();
    v464->Update();
    v465->Update();
    v466->Update();
    v467->Update();
    v468->Update();
    v469->Update();
    v470->Update();
    v471->Update();
    v472->Update();
    v473->Update();
    v474->Update();
    v475->Update();
    v476->Update();
    v477->Update();
    v478->Update();
    v479->Update();
    v480->Update();
    v481->Update();
    v482->Update();
    v483->Update();
    v484->Update();
    v485->Update();
    v486->Update();
  };
  return {update_fn};
}

} // anonymous namespace
